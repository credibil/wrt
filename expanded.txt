#![feature(prelude_import)]
//! # WASI Bindings
//!
//! This module generates and exports WASI Guest bindings for local wit worlds.
//! The bindings are exported in as similar a manner to those in the Bytecode
//! Alliance's [wasi] crate.
//!
//! [wasi]: https://github.com/bytecodealliance/wasi
#[macro_use]
extern crate std;
#[prelude_import]
use std::prelude::rust_2024::*;
/// Bindings for the `wasi:blobstore` world.
/// See (<https://github.com/WebAssembly/wasi-blobstore/>)
pub mod blobstore {
    pub use self::wasi::blobstore::*;
    #[allow(dead_code, clippy::all)]
    pub mod wasi {
        pub mod blobstore {
            /// Types used by blobstore
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type InputStream = super::super::super::wasi::io::streams::InputStream;
                pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
                /// name of a container, a collection of objects.
                /// The container name may be any valid UTF-8 string.
                pub type ContainerName = _rt::String;
                /// name of an object within a container
                /// The object name may be any valid UTF-8 string.
                pub type ObjectName = _rt::String;
                /// TODO: define timestamp to include seconds since
                /// Unix epoch and nanoseconds
                /// https://github.com/WebAssembly/wasi-blob-store/issues/7
                pub type Timestamp = u64;
                /// size of an object, in bytes
                pub type ObjectSize = u64;
                pub type Error = _rt::String;
                /// information about a container
                pub struct ContainerMetadata {
                    /// the container's name
                    pub name: ContainerName,
                    /// date and time container was created
                    pub created_at: Timestamp,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ContainerMetadata {
                    #[inline]
                    fn clone(&self) -> ContainerMetadata {
                        ContainerMetadata {
                            name: ::core::clone::Clone::clone(&self.name),
                            created_at: ::core::clone::Clone::clone(&self.created_at),
                        }
                    }
                }
                impl ::core::fmt::Debug for ContainerMetadata {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ContainerMetadata")
                            .field("name", &self.name)
                            .field("created-at", &self.created_at)
                            .finish()
                    }
                }
                /// information about an object
                pub struct ObjectMetadata {
                    /// the object's name
                    pub name: ObjectName,
                    /// the object's parent container
                    pub container: ContainerName,
                    /// date and time the object was created
                    pub created_at: Timestamp,
                    /// size of the object, in bytes
                    pub size: ObjectSize,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ObjectMetadata {
                    #[inline]
                    fn clone(&self) -> ObjectMetadata {
                        ObjectMetadata {
                            name: ::core::clone::Clone::clone(&self.name),
                            container: ::core::clone::Clone::clone(&self.container),
                            created_at: ::core::clone::Clone::clone(&self.created_at),
                            size: ::core::clone::Clone::clone(&self.size),
                        }
                    }
                }
                impl ::core::fmt::Debug for ObjectMetadata {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ObjectMetadata")
                            .field("name", &self.name)
                            .field("container", &self.container)
                            .field("created-at", &self.created_at)
                            .field("size", &self.size)
                            .finish()
                    }
                }
                /// identifier for an object that includes its container name
                pub struct ObjectId {
                    pub container: ContainerName,
                    pub object: ObjectName,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ObjectId {
                    #[inline]
                    fn clone(&self) -> ObjectId {
                        ObjectId {
                            container: ::core::clone::Clone::clone(&self.container),
                            object: ::core::clone::Clone::clone(&self.object),
                        }
                    }
                }
                impl ::core::fmt::Debug for ObjectId {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ObjectId")
                            .field("container", &self.container)
                            .field("object", &self.object)
                            .finish()
                    }
                }
                /// A data is the data stored in a data blob. The value can be of any type
                /// that can be represented in a byte array. It provides a way to write the value
                /// to the output-stream defined in the `wasi-io` interface.
                /// Soon: switch to `resource value { ... }`
                #[repr(transparent)]
                pub struct OutgoingValue {
                    handle: _rt::Resource<OutgoingValue>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for OutgoingValue {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "OutgoingValue",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl OutgoingValue {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for OutgoingValue {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                /// A incoming-value is a wrapper around a value. It provides a way to read the value
                /// from the input-stream defined in the `wasi-io` interface.
                ///
                /// The incoming-value provides two ways to consume the value:
                /// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the
                ///    value as a list of bytes.
                /// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the
                ///    value as an input-stream.
                /// Soon: switch to `resource incoming-value { ... }`
                #[repr(transparent)]
                pub struct IncomingValue {
                    handle: _rt::Resource<IncomingValue>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for IncomingValue {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncomingValue",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl IncomingValue {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for IncomingValue {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                pub type IncomingValueAsyncBody = InputStream;
                pub type IncomingValueSyncBody = _rt::Vec<u8>;
                impl OutgoingValue {
                    #[allow(unused_unsafe, clippy::all)]
                    #[allow(async_fn_in_trait)]
                    pub fn new_outgoing_value() -> OutgoingValue {
                        unsafe {
                            unsafe extern "C" fn wit_import0() -> i32 {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            let ret = wit_import0();
                            OutgoingValue::from_handle(ret as u32)
                        }
                    }
                }
                impl OutgoingValue {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Returns a stream for writing the value contents.
                    ///
                    /// The returned `output-stream` is a child resource: it must be dropped
                    /// before the parent `outgoing-value` resource is dropped (or finished),
                    /// otherwise the `outgoing-value` drop or `finish` will trap.
                    ///
                    /// Returns success on the first call: the `output-stream` resource for
                    /// this `outgoing-value` may be retrieved at most once. Subsequent calls
                    /// will return error.
                    #[allow(async_fn_in_trait)]
                    pub fn outgoing_value_write_body(
                        &self,
                    ) -> Result<OutputStream, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result7 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        super::super::super::wasi::io::streams::OutputStream::from_handle(
                                            l3 as u32,
                                        )
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l5 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        _rt::string_lift(bytes6)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl OutgoingValue {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Finalize an outgoing value. This must be
                    /// called to signal that the outgoing value is complete. If the `outgoing-value`
                    /// is dropped without calling `outgoing-value.finalize`, the implementation
                    /// should treat the value as corrupted.
                    #[allow(async_fn_in_trait)]
                    pub fn finish(this: OutgoingValue) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((&this).take_handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result6 = match l2 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        let bytes5 = _rt::Vec::from_raw_parts(
                                            l3.cast(),
                                            len5,
                                            len5,
                                        );
                                        _rt::string_lift(bytes5)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result6
                        }
                    }
                }
                impl IncomingValue {
                    #[allow(unused_unsafe, clippy::all)]
                    #[allow(async_fn_in_trait)]
                    pub fn incoming_value_consume_sync(
                        this: IncomingValue,
                    ) -> Result<IncomingValueSyncBody, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((&this).take_handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result9 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l6 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l7 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len8 = l7;
                                        let bytes8 = _rt::Vec::from_raw_parts(
                                            l6.cast(),
                                            len8,
                                            len8,
                                        );
                                        _rt::string_lift(bytes8)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result9
                        }
                    }
                }
                impl IncomingValue {
                    #[allow(unused_unsafe, clippy::all)]
                    #[allow(async_fn_in_trait)]
                    pub fn incoming_value_consume_async(
                        this: IncomingValue,
                    ) -> Result<IncomingValueAsyncBody, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((&this).take_handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result7 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        super::super::super::wasi::io::streams::InputStream::from_handle(
                                            l3 as u32,
                                        )
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l5 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        _rt::string_lift(bytes6)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl IncomingValue {
                    #[allow(unused_unsafe, clippy::all)]
                    #[allow(async_fn_in_trait)]
                    pub fn size(&self) -> u64 {
                        unsafe {
                            unsafe extern "C" fn wit_import0(_: i32) -> i64 {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            let ret = wit_import0((self).handle() as i32);
                            ret as u64
                        }
                    }
                }
            }
            /// a Container is a collection of objects
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod container {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type ContainerMetadata = super::super::super::wasi::blobstore::types::ContainerMetadata;
                pub type Error = super::super::super::wasi::blobstore::types::Error;
                pub type IncomingValue = super::super::super::wasi::blobstore::types::IncomingValue;
                pub type ObjectMetadata = super::super::super::wasi::blobstore::types::ObjectMetadata;
                pub type ObjectName = super::super::super::wasi::blobstore::types::ObjectName;
                pub type OutgoingValue = super::super::super::wasi::blobstore::types::OutgoingValue;
                /// this defines the `container` resource
                #[repr(transparent)]
                pub struct Container {
                    handle: _rt::Resource<Container>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Container {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Container",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl Container {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for Container {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                /// this defines the `stream-object-names` resource which is a representation of stream<object-name>
                #[repr(transparent)]
                pub struct StreamObjectNames {
                    handle: _rt::Resource<StreamObjectNames>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for StreamObjectNames {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "StreamObjectNames",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl StreamObjectNames {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for StreamObjectNames {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// returns container name
                    #[allow(async_fn_in_trait)]
                    pub fn name(&self) -> Result<_rt::String, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result9 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        let bytes5 = _rt::Vec::from_raw_parts(
                                            l3.cast(),
                                            len5,
                                            len5,
                                        );
                                        _rt::string_lift(bytes5)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l6 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l7 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len8 = l7;
                                        let bytes8 = _rt::Vec::from_raw_parts(
                                            l6.cast(),
                                            len8,
                                            len8,
                                        );
                                        _rt::string_lift(bytes8)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result9
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// returns container metadata
                    #[allow(async_fn_in_trait)]
                    pub fn info(&self) -> Result<ContainerMetadata, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 16 + 2 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 16
                                    + 2 * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result10 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0.add(8).cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        let bytes5 = _rt::Vec::from_raw_parts(
                                            l3.cast(),
                                            len5,
                                            len5,
                                        );
                                        let l6 = *ptr0
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        super::super::super::wasi::blobstore::types::ContainerMetadata {
                                            name: _rt::string_lift(bytes5),
                                            created_at: l6 as u64,
                                        }
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l7 = *ptr0.add(8).cast::<*mut u8>();
                                        let l8 = *ptr0
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len9 = l8;
                                        let bytes9 = _rt::Vec::from_raw_parts(
                                            l7.cast(),
                                            len9,
                                            len9,
                                        );
                                        _rt::string_lift(bytes9)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result10
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// retrieves an object or portion of an object, as a resource.
                    /// Start and end offsets are inclusive.
                    /// Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime
                    /// of the data-blob resource, even if the object they came from is later deleted.
                    #[allow(async_fn_in_trait)]
                    pub fn get_data(
                        &self,
                        name: &str,
                        start: u64,
                        end: u64,
                    ) -> Result<IncomingValue, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = name;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i64,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                _rt::as_i64(&start),
                                _rt::as_i64(&end),
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result8 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = *ptr1
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        super::super::super::wasi::blobstore::types::IncomingValue::from_handle(
                                            l4 as u32,
                                        )
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = *ptr1
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l6 = *ptr1
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result8
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// creates or replaces an object with the data blob.
                    #[allow(async_fn_in_trait)]
                    pub fn write_data(
                        &self,
                        name: &str,
                        data: &OutgoingValue,
                    ) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = name;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                (data).handle() as i32,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result7 = match l3 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = *ptr1
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l5 = *ptr1
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        _rt::string_lift(bytes6)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// returns list of objects in the container. Order is undefined.
                    #[allow(async_fn_in_trait)]
                    pub fn list_objects(&self) -> Result<StreamObjectNames, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result7 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        StreamObjectNames::from_handle(l3 as u32)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l5 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        _rt::string_lift(bytes6)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// deletes object.
                    /// does not return error if object did not exist.
                    #[allow(async_fn_in_trait)]
                    pub fn delete_object(&self, name: &str) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = name;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result7 = match l3 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = *ptr1
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l5 = *ptr1
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        _rt::string_lift(bytes6)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// deletes multiple objects in the container
                    #[allow(async_fn_in_trait)]
                    pub fn delete_objects(
                        &self,
                        names: &[ObjectName],
                    ) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec1 = names;
                            let len1 = vec1.len();
                            let layout1 = _rt::alloc::Layout::from_size_align(
                                    vec1.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                                .unwrap();
                            let (result1, _cleanup1) = wit_bindgen::rt::Cleanup::new(
                                layout1,
                            );
                            for (i, e) in vec1.into_iter().enumerate() {
                                let base = result1
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec0 = e;
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                            }
                            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import3(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import3((self).handle() as i32, result1, len1, ptr2);
                            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                            let result8 = match l4 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = *ptr2
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l6 = *ptr2
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result8
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// returns true if the object exists in this container
                    #[allow(async_fn_in_trait)]
                    pub fn has_object(&self, name: &str) -> Result<bool, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = name;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result8 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        _rt::bool_lift(l4 as u8)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = *ptr1
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l6 = *ptr1
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result8
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// returns metadata for the object
                    #[allow(async_fn_in_trait)]
                    pub fn object_info(
                        &self,
                        name: &str,
                    ) -> Result<ObjectMetadata, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 24 + 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 24
                                    + 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = name;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result15 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = *ptr1.add(8).cast::<*mut u8>();
                                        let l5 = *ptr1
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        let l7 = *ptr1
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l8 = *ptr1
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len9 = l8;
                                        let bytes9 = _rt::Vec::from_raw_parts(
                                            l7.cast(),
                                            len9,
                                            len9,
                                        );
                                        let l10 = *ptr1
                                            .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        let l11 = *ptr1
                                            .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        super::super::super::wasi::blobstore::types::ObjectMetadata {
                                            name: _rt::string_lift(bytes6),
                                            container: _rt::string_lift(bytes9),
                                            created_at: l10 as u64,
                                            size: l11 as u64,
                                        }
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l12 = *ptr1.add(8).cast::<*mut u8>();
                                        let l13 = *ptr1
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len14 = l13;
                                        let bytes14 = _rt::Vec::from_raw_parts(
                                            l12.cast(),
                                            len14,
                                            len14,
                                        );
                                        _rt::string_lift(bytes14)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result15
                        }
                    }
                }
                impl Container {
                    #[allow(unused_unsafe, clippy::all)]
                    /// removes all objects within the container, leaving the container empty.
                    #[allow(async_fn_in_trait)]
                    pub fn clear(&self) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result6 = match l2 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        let bytes5 = _rt::Vec::from_raw_parts(
                                            l3.cast(),
                                            len5,
                                            len5,
                                        );
                                        _rt::string_lift(bytes5)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result6
                        }
                    }
                }
                impl StreamObjectNames {
                    #[allow(unused_unsafe, clippy::all)]
                    /// reads the next number of objects from the stream
                    ///
                    /// This function returns the list of objects read, and a boolean indicating if the end of the stream was reached.
                    #[allow(async_fn_in_trait)]
                    pub fn read_stream_object_names(
                        &self,
                        len: u64,
                    ) -> Result<(_rt::Vec<ObjectName>, bool), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result13 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base8 = l3;
                                        let len8 = l4;
                                        let mut result8 = _rt::Vec::with_capacity(len8);
                                        for i in 0..len8 {
                                            let base = base8
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e8 = {
                                                let l5 = *base.add(0).cast::<*mut u8>();
                                                let l6 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len7 = l6;
                                                let bytes7 = _rt::Vec::from_raw_parts(
                                                    l5.cast(),
                                                    len7,
                                                    len7,
                                                );
                                                _rt::string_lift(bytes7)
                                            };
                                            result8.push(e8);
                                        }
                                        _rt::cabi_dealloc(
                                            base8,
                                            len8 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        let l9 = i32::from(
                                            *ptr0
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        (result8, _rt::bool_lift(l9 as u8))
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l10 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l11 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len12 = l11;
                                        let bytes12 = _rt::Vec::from_raw_parts(
                                            l10.cast(),
                                            len12,
                                            len12,
                                        );
                                        _rt::string_lift(bytes12)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result13
                        }
                    }
                }
                impl StreamObjectNames {
                    #[allow(unused_unsafe, clippy::all)]
                    /// skip the next number of objects in the stream
                    ///
                    /// This function returns the number of objects skipped, and a boolean indicating if the end of the stream was reached.
                    #[allow(async_fn_in_trait)]
                    pub fn skip_stream_object_names(
                        &self,
                        num: u64,
                    ) -> Result<(u64, bool), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 24],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, _rt::as_i64(&num), ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result8 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0.add(8).cast::<i64>();
                                        let l4 = i32::from(*ptr0.add(16).cast::<u8>());
                                        (l3 as u64, _rt::bool_lift(l4 as u8))
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = *ptr0.add(8).cast::<*mut u8>();
                                        let l6 = *ptr0
                                            .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result8
                        }
                    }
                }
            }
            /// wasi-cloud Blobstore service definition
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod blobstore {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type Container = super::super::super::wasi::blobstore::container::Container;
                pub type Error = super::super::super::wasi::blobstore::types::Error;
                pub type ContainerName = super::super::super::wasi::blobstore::types::ContainerName;
                pub type ObjectId = super::super::super::wasi::blobstore::types::ObjectId;
                #[allow(unused_unsafe, clippy::all)]
                /// creates a new empty container
                #[allow(async_fn_in_trait)]
                pub fn create_container(name: &str) -> Result<Container, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result8 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>();
                                    super::super::super::wasi::blobstore::container::Container::from_handle(
                                        l4 as u32,
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len7 = l6;
                                    let bytes7 = _rt::Vec::from_raw_parts(
                                        l5.cast(),
                                        len7,
                                        len7,
                                    );
                                    _rt::string_lift(bytes7)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// retrieves a container by name
                #[allow(async_fn_in_trait)]
                pub fn get_container(name: &str) -> Result<Container, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result8 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>();
                                    super::super::super::wasi::blobstore::container::Container::from_handle(
                                        l4 as u32,
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len7 = l6;
                                    let bytes7 = _rt::Vec::from_raw_parts(
                                        l5.cast(),
                                        len7,
                                        len7,
                                    );
                                    _rt::string_lift(bytes7)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// deletes a container and all objects within it
                #[allow(async_fn_in_trait)]
                pub fn delete_container(name: &str) -> Result<(), Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result7 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len6 = l5;
                                    let bytes6 = _rt::Vec::from_raw_parts(
                                        l4.cast(),
                                        len6,
                                        len6,
                                    );
                                    _rt::string_lift(bytes6)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// returns true if the container exists
                #[allow(async_fn_in_trait)]
                pub fn container_exists(name: &str) -> Result<bool, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result8 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    _rt::bool_lift(l4 as u8)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len7 = l6;
                                    let bytes7 = _rt::Vec::from_raw_parts(
                                        l5.cast(),
                                        len7,
                                        len7,
                                    );
                                    _rt::string_lift(bytes7)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// copies (duplicates) an object, to the same or a different container.
                /// returns an error if the target container does not exist.
                /// overwrites destination object if it already existed.
                #[allow(async_fn_in_trait)]
                pub fn copy_object(
                    src: &ObjectId,
                    dest: &ObjectId,
                ) -> Result<(), Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let super::super::super::wasi::blobstore::types::ObjectId {
                            container: container0,
                            object: object0,
                        } = src;
                        let vec1 = container0;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let vec2 = object0;
                        let ptr2 = vec2.as_ptr().cast::<u8>();
                        let len2 = vec2.len();
                        let super::super::super::wasi::blobstore::types::ObjectId {
                            container: container3,
                            object: object3,
                        } = dest;
                        let vec4 = container3;
                        let ptr4 = vec4.as_ptr().cast::<u8>();
                        let len4 = vec4.len();
                        let vec5 = object3;
                        let ptr5 = vec5.as_ptr().cast::<u8>();
                        let len5 = vec5.len();
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import7(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import7(
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr4.cast_mut(),
                            len4,
                            ptr5.cast_mut(),
                            len5,
                            ptr6,
                        );
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result12 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = *ptr6
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l10 = *ptr6
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len11 = l10;
                                    let bytes11 = _rt::Vec::from_raw_parts(
                                        l9.cast(),
                                        len11,
                                        len11,
                                    );
                                    _rt::string_lift(bytes11)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result12
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// moves or renames an object, to the same or a different container
                /// returns an error if the destination container does not exist.
                /// overwrites destination object if it already existed.
                #[allow(async_fn_in_trait)]
                pub fn move_object(
                    src: &ObjectId,
                    dest: &ObjectId,
                ) -> Result<(), Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let super::super::super::wasi::blobstore::types::ObjectId {
                            container: container0,
                            object: object0,
                        } = src;
                        let vec1 = container0;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let vec2 = object0;
                        let ptr2 = vec2.as_ptr().cast::<u8>();
                        let len2 = vec2.len();
                        let super::super::super::wasi::blobstore::types::ObjectId {
                            container: container3,
                            object: object3,
                        } = dest;
                        let vec4 = container3;
                        let ptr4 = vec4.as_ptr().cast::<u8>();
                        let len4 = vec4.len();
                        let vec5 = object3;
                        let ptr5 = vec5.as_ptr().cast::<u8>();
                        let len5 = vec5.len();
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import7(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import7(
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr4.cast_mut(),
                            len4,
                            ptr5.cast_mut(),
                            len5,
                            ptr6,
                        );
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result12 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = *ptr6
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l10 = *ptr6
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len11 = l10;
                                    let bytes11 = _rt::Vec::from_raw_parts(
                                        l9.cast(),
                                        len11,
                                        len11,
                                    );
                                    _rt::string_lift(bytes11)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result12
                    }
                }
            }
        }
        pub mod io {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod error {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                /// A resource which represents some error information.
                ///
                /// The only method provided by this resource is `to-debug-string`,
                /// which provides some human-readable information about the error.
                ///
                /// In the `wasi:io` package, this resource is returned through the
                /// `wasi:io/streams/stream-error` type.
                ///
                /// To provide more specific error information, other interfaces may
                /// offer functions to "downcast" this error into more specific types. For example,
                /// errors returned from streams derived from filesystem types can be described using
                /// the filesystem's own error-code type. This is done using the function
                /// `wasi:filesystem/types/filesystem-error-code`, which takes a `borrow<error>`
                /// parameter and returns an `option<wasi:filesystem/types/error-code>`.
                ///
                /// The set of functions which can "downcast" an `error` into a more
                /// concrete type is open.
                #[repr(transparent)]
                pub struct Error {
                    handle: _rt::Resource<Error>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Error {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Error",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl Error {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for Error {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                impl Error {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Returns a string that is suitable to assist humans in debugging
                    /// this error.
                    ///
                    /// WARNING: The returned string should not be consumed mechanically!
                    /// It may change across platforms, hosts, or other implementation
                    /// details. Parsing this string is a major platform-compatibility
                    /// hazard.
                    #[allow(async_fn_in_trait)]
                    pub fn to_debug_string(&self) -> _rt::String {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 2 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 2
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = *ptr0.add(0).cast::<*mut u8>();
                            let l3 = *ptr0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len4 = l3;
                            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                            let result5 = _rt::string_lift(bytes4);
                            result5
                        }
                    }
                }
            }
            /// A poll API intended to let users wait for I/O events on multiple handles
            /// at once.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod poll {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                /// `pollable` represents a single I/O event which may be ready, or not.
                #[repr(transparent)]
                pub struct Pollable {
                    handle: _rt::Resource<Pollable>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Pollable {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Pollable",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl Pollable {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for Pollable {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                impl Pollable {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Return the readiness of a pollable. This function never blocks.
                    ///
                    /// Returns `true` when the pollable is ready, and `false` otherwise.
                    #[allow(async_fn_in_trait)]
                    pub fn ready(&self) -> bool {
                        unsafe {
                            unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            let ret = wit_import0((self).handle() as i32);
                            _rt::bool_lift(ret as u8)
                        }
                    }
                }
                impl Pollable {
                    #[allow(unused_unsafe, clippy::all)]
                    /// `block` returns immediately if the pollable is ready, and otherwise
                    /// blocks until ready.
                    ///
                    /// This function is equivalent to calling `poll.poll` on a list
                    /// containing only this pollable.
                    #[allow(async_fn_in_trait)]
                    pub fn block(&self) -> () {
                        unsafe {
                            unsafe extern "C" fn wit_import0(_: i32) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import0((self).handle() as i32);
                        }
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Poll for completion on a set of pollables.
                ///
                /// This function takes a list of pollables, which identify I/O sources of
                /// interest, and waits until one or more of the events is ready for I/O.
                ///
                /// The result `list<u32>` contains one or more indices of handles in the
                /// argument list that is ready for I/O.
                ///
                /// This function traps if either:
                /// - the list is empty, or:
                /// - the list contains more elements than can be indexed with a `u32` value.
                ///
                /// A timeout can be implemented by adding a pollable from the
                /// wasi-clocks API to the list.
                ///
                /// This function does not return a `result`; polling in itself does not
                /// do any I/O so it doesn't fail. If any of the I/O sources identified by
                /// the pollables has an error, it is indicated by marking the source as
                /// being ready for I/O.
                #[allow(async_fn_in_trait)]
                pub fn poll(in_: &[&Pollable]) -> _rt::Vec<u32> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = in_;
                        let len0 = vec0.len();
                        let layout0 = _rt::alloc::Layout::from_size_align(
                                vec0.len() * 4,
                                4,
                            )
                            .unwrap();
                        let (result0, _cleanup0) = wit_bindgen::rt::Cleanup::new(
                            layout0,
                        );
                        for (i, e) in vec0.into_iter().enumerate() {
                            let base = result0.add(i * 4);
                            {
                                *base.add(0).cast::<i32>() = (e).handle() as i32;
                            }
                        }
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(result0, len0, ptr1);
                        let l3 = *ptr1.add(0).cast::<*mut u8>();
                        let l4 = *ptr1
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len5 = l4;
                        let result6 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                        result6
                    }
                }
            }
            /// WASI I/O is an I/O abstraction API which is currently focused on providing
            /// stream types.
            ///
            /// In the future, the component model is expected to add built-in stream types;
            /// when it does, they are expected to subsume this API.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod streams {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type Error = super::super::super::wasi::io::error::Error;
                pub type Pollable = super::super::super::wasi::io::poll::Pollable;
                /// An error for input-stream and output-stream operations.
                pub enum StreamError {
                    /// The last operation (a write or flush) failed before completion.
                    ///
                    /// More information is available in the `error` payload.
                    ///
                    /// After this, the stream will be closed. All future operations return
                    /// `stream-error::closed`.
                    LastOperationFailed(Error),
                    /// The stream is closed: no more input will be accepted by the
                    /// stream. A closed output-stream will return this error on all
                    /// future operations.
                    Closed,
                }
                impl ::core::fmt::Debug for StreamError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            StreamError::LastOperationFailed(e) => {
                                f.debug_tuple("StreamError::LastOperationFailed")
                                    .field(e)
                                    .finish()
                            }
                            StreamError::Closed => {
                                f.debug_tuple("StreamError::Closed").finish()
                            }
                        }
                    }
                }
                impl ::core::fmt::Display for StreamError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for StreamError {}
                /// An input bytestream.
                ///
                /// `input-stream`s are *non-blocking* to the extent practical on underlying
                /// platforms. I/O operations always return promptly; if fewer bytes are
                /// promptly available than requested, they return the number of bytes promptly
                /// available, which could even be zero. To wait for data to be available,
                /// use the `subscribe` function to obtain a `pollable` which can be polled
                /// for using `wasi:io/poll`.
                #[repr(transparent)]
                pub struct InputStream {
                    handle: _rt::Resource<InputStream>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for InputStream {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "InputStream",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl InputStream {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for InputStream {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                /// An output bytestream.
                ///
                /// `output-stream`s are *non-blocking* to the extent practical on
                /// underlying platforms. Except where specified otherwise, I/O operations also
                /// always return promptly, after the number of bytes that can be written
                /// promptly, which could even be zero. To wait for the stream to be ready to
                /// accept data, the `subscribe` function to obtain a `pollable` which can be
                /// polled for using `wasi:io/poll`.
                ///
                /// Dropping an `output-stream` while there's still an active write in
                /// progress may result in the data being lost. Before dropping the stream,
                /// be sure to fully flush your writes.
                #[repr(transparent)]
                pub struct OutputStream {
                    handle: _rt::Resource<OutputStream>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for OutputStream {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "OutputStream",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl OutputStream {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for OutputStream {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                impl InputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Perform a non-blocking read from the stream.
                    ///
                    /// When the source of a `read` is binary data, the bytes from the source
                    /// are returned verbatim. When the source of a `read` is known to the
                    /// implementation to be text, bytes containing the UTF-8 encoding of the
                    /// text are returned.
                    ///
                    /// This function returns a list of bytes containing the read data,
                    /// when successful. The returned list will contain up to `len` bytes;
                    /// it may return fewer than requested, but not more. The list is
                    /// empty when no bytes are available for reading at this time. The
                    /// pollable given by `subscribe` will be ready when more bytes are
                    /// available.
                    ///
                    /// This function fails with a `stream-error` when the operation
                    /// encounters an error, giving `last-operation-failed`, or when the
                    /// stream is closed, giving `closed`.
                    ///
                    /// When the caller gives a `len` of 0, it represents a request to
                    /// read 0 bytes. If the stream is still open, this call should
                    /// succeed and return an empty list, or otherwise fail with `closed`.
                    ///
                    /// The `len` parameter is a `u64`, which could represent a list of u8 which
                    /// is not possible to allocate in wasm32, or not desirable to allocate as
                    /// as a return value by the callee. The callee may return a list of bytes
                    /// less than `len` in size while more bytes are available for reading.
                    #[allow(async_fn_in_trait)]
                    pub fn read(&self, len: u64) -> Result<_rt::Vec<u8>, StreamError> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result9 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l6 = i32::from(
                                            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v8 = match l6 {
                                            0 => {
                                                let e8 = {
                                                    let l7 = *ptr0
                                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l7 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e8)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v8
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result9
                        }
                    }
                }
                impl InputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Read bytes from a stream, after blocking until at least one byte can
                    /// be read. Except for blocking, behavior is identical to `read`.
                    #[allow(async_fn_in_trait)]
                    pub fn blocking_read(
                        &self,
                        len: u64,
                    ) -> Result<_rt::Vec<u8>, StreamError> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result9 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l6 = i32::from(
                                            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v8 = match l6 {
                                            0 => {
                                                let e8 = {
                                                    let l7 = *ptr0
                                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l7 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e8)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v8
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result9
                        }
                    }
                }
                impl InputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Skip bytes from a stream. Returns number of bytes skipped.
                    ///
                    /// Behaves identical to `read`, except instead of returning a list
                    /// of bytes, returns the number of bytes consumed from the stream.
                    #[allow(async_fn_in_trait)]
                    pub fn skip(&self, len: u64) -> Result<u64, StreamError> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 16],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result7 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0.add(8).cast::<i64>();
                                        l3 as u64
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                        let v6 = match l4 {
                                            0 => {
                                                let e6 = {
                                                    let l5 = *ptr0.add(12).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e6)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v6
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl InputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Skip bytes from a stream, after blocking until at least one byte
                    /// can be skipped. Except for blocking behavior, identical to `skip`.
                    #[allow(async_fn_in_trait)]
                    pub fn blocking_skip(&self, len: u64) -> Result<u64, StreamError> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 16],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result7 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0.add(8).cast::<i64>();
                                        l3 as u64
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                        let v6 = match l4 {
                                            0 => {
                                                let e6 = {
                                                    let l5 = *ptr0.add(12).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e6)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v6
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl InputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Create a `pollable` which will resolve once either the specified stream
                    /// has bytes available to read or the other end of the stream has been
                    /// closed.
                    /// The created `pollable` is a child resource of the `input-stream`.
                    /// Implementations may trap if the `input-stream` is dropped before
                    /// all derived `pollable`s created with this function are dropped.
                    #[allow(async_fn_in_trait)]
                    pub fn subscribe(&self) -> Pollable {
                        unsafe {
                            unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            let ret = wit_import0((self).handle() as i32);
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Check readiness for writing. This function never blocks.
                    ///
                    /// Returns the number of bytes permitted for the next call to `write`,
                    /// or an error. Calling `write` with more bytes than this function has
                    /// permitted will trap.
                    ///
                    /// When this function returns 0 bytes, the `subscribe` pollable will
                    /// become ready when this function will report at least 1 byte, or an
                    /// error.
                    #[allow(async_fn_in_trait)]
                    pub fn check_write(&self) -> Result<u64, StreamError> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 16],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result7 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0.add(8).cast::<i64>();
                                        l3 as u64
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                        let v6 = match l4 {
                                            0 => {
                                                let e6 = {
                                                    let l5 = *ptr0.add(12).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e6)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v6
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Perform a write. This function never blocks.
                    ///
                    /// When the destination of a `write` is binary data, the bytes from
                    /// `contents` are written verbatim. When the destination of a `write` is
                    /// known to the implementation to be text, the bytes of `contents` are
                    /// transcoded from UTF-8 into the encoding of the destination and then
                    /// written.
                    ///
                    /// Precondition: check-write gave permit of Ok(n) and contents has a
                    /// length of less than or equal to n. Otherwise, this function will trap.
                    ///
                    /// returns Err(closed) without writing if the stream has closed since
                    /// the last call to check-write provided a permit.
                    #[allow(async_fn_in_trait)]
                    pub fn write(&self, contents: &[u8]) -> Result<(), StreamError> {
                        unsafe {
                            #[repr(align(4))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 12],
                            );
                            let vec0 = contents;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result7 = match l3 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(*ptr1.add(4).cast::<u8>());
                                        let v6 = match l4 {
                                            0 => {
                                                let e6 = {
                                                    let l5 = *ptr1.add(8).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e6)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v6
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Perform a write of up to 4096 bytes, and then flush the stream. Block
                    /// until all of these operations are complete, or an error occurs.
                    ///
                    /// Returns success when all of the contents written are successfully
                    /// flushed to output. If an error occurs at any point before all
                    /// contents are successfully flushed, that error is returned as soon as
                    /// possible. If writing and flushing the complete contents causes the
                    /// stream to become closed, this call should return success, and
                    /// subsequent calls to check-write or other interfaces should return
                    /// stream-error::closed.
                    #[allow(async_fn_in_trait)]
                    pub fn blocking_write_and_flush(
                        &self,
                        contents: &[u8],
                    ) -> Result<(), StreamError> {
                        unsafe {
                            #[repr(align(4))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 12],
                            );
                            let vec0 = contents;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result7 = match l3 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(*ptr1.add(4).cast::<u8>());
                                        let v6 = match l4 {
                                            0 => {
                                                let e6 = {
                                                    let l5 = *ptr1.add(8).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e6)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v6
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Request to flush buffered output. This function never blocks.
                    ///
                    /// This tells the output-stream that the caller intends any buffered
                    /// output to be flushed. the output which is expected to be flushed
                    /// is all that has been passed to `write` prior to this call.
                    ///
                    /// Upon calling this function, the `output-stream` will not accept any
                    /// writes (`check-write` will return `ok(0)`) until the flush has
                    /// completed. The `subscribe` pollable will become ready when the
                    /// flush has completed and the stream can accept more writes.
                    #[allow(async_fn_in_trait)]
                    pub fn flush(&self) -> Result<(), StreamError> {
                        unsafe {
                            #[repr(align(4))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 12],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result6 = match l2 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                        let v5 = match l3 {
                                            0 => {
                                                let e5 = {
                                                    let l4 = *ptr0.add(8).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l4 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e5)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v5
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result6
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Request to flush buffered output, and block until flush completes
                    /// and stream is ready for writing again.
                    #[allow(async_fn_in_trait)]
                    pub fn blocking_flush(&self) -> Result<(), StreamError> {
                        unsafe {
                            #[repr(align(4))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 12],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result6 = match l2 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                        let v5 = match l3 {
                                            0 => {
                                                let e5 = {
                                                    let l4 = *ptr0.add(8).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l4 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e5)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v5
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result6
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Create a `pollable` which will resolve once the output-stream
                    /// is ready for more writing, or an error has occurred. When this
                    /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
                    /// error.
                    ///
                    /// If the stream is closed, this pollable is always ready immediately.
                    ///
                    /// The created `pollable` is a child resource of the `output-stream`.
                    /// Implementations may trap if the `output-stream` is dropped before
                    /// all derived `pollable`s created with this function are dropped.
                    #[allow(async_fn_in_trait)]
                    pub fn subscribe(&self) -> Pollable {
                        unsafe {
                            unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            let ret = wit_import0((self).handle() as i32);
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Write zeroes to a stream.
                    ///
                    /// This should be used precisely like `write` with the exact same
                    /// preconditions (must use check-write first), but instead of
                    /// passing a list of bytes, you simply pass the number of zero-bytes
                    /// that should be written.
                    #[allow(async_fn_in_trait)]
                    pub fn write_zeroes(&self, len: u64) -> Result<(), StreamError> {
                        unsafe {
                            #[repr(align(4))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 12],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result6 = match l2 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                        let v5 = match l3 {
                                            0 => {
                                                let e5 = {
                                                    let l4 = *ptr0.add(8).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l4 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e5)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v5
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result6
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Perform a write of up to 4096 zeroes, and then flush the stream.
                    /// Block until all of these operations are complete, or an error
                    /// occurs.
                    ///
                    /// Functionality is equivelant to `blocking-write-and-flush` with
                    /// contents given as a list of len containing only zeroes.
                    #[allow(async_fn_in_trait)]
                    pub fn blocking_write_zeroes_and_flush(
                        &self,
                        len: u64,
                    ) -> Result<(), StreamError> {
                        unsafe {
                            #[repr(align(4))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 12],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result6 = match l2 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                        let v5 = match l3 {
                                            0 => {
                                                let e5 = {
                                                    let l4 = *ptr0.add(8).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l4 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e5)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v5
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result6
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Read from one stream and write to another.
                    ///
                    /// The behavior of splice is equivalent to:
                    /// 1. calling `check-write` on the `output-stream`
                    /// 2. calling `read` on the `input-stream` with the smaller of the
                    /// `check-write` permitted length and the `len` provided to `splice`
                    /// 3. calling `write` on the `output-stream` with that read data.
                    ///
                    /// Any error reported by the call to `check-write`, `read`, or
                    /// `write` ends the splice and reports that error.
                    ///
                    /// This function returns the number of bytes transferred; it may be less
                    /// than `len`.
                    #[allow(async_fn_in_trait)]
                    pub fn splice(
                        &self,
                        src: &InputStream,
                        len: u64,
                    ) -> Result<u64, StreamError> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 16],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1(
                                (self).handle() as i32,
                                (src).handle() as i32,
                                _rt::as_i64(&len),
                                ptr0,
                            );
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result7 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0.add(8).cast::<i64>();
                                        l3 as u64
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                        let v6 = match l4 {
                                            0 => {
                                                let e6 = {
                                                    let l5 = *ptr0.add(12).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e6)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v6
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
                impl OutputStream {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Read from one stream and write to another, with blocking.
                    ///
                    /// This is similar to `splice`, except that it blocks until the
                    /// `output-stream` is ready for writing, and the `input-stream`
                    /// is ready for reading, before performing the `splice`.
                    #[allow(async_fn_in_trait)]
                    pub fn blocking_splice(
                        &self,
                        src: &InputStream,
                        len: u64,
                    ) -> Result<u64, StreamError> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 16],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: i32,
                                _: i64,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1(
                                (self).handle() as i32,
                                (src).handle() as i32,
                                _rt::as_i64(&len),
                                ptr0,
                            );
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result7 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0.add(8).cast::<i64>();
                                        l3 as u64
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                        let v6 = match l4 {
                                            0 => {
                                                let e6 = {
                                                    let l5 = *ptr0.add(12).cast::<i32>();
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                };
                                                StreamError::LastOperationFailed(e6)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                StreamError::Closed
                                            }
                                        };
                                        v6
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result7
                        }
                    }
                }
            }
        }
    }
    mod _rt {
        #![allow(dead_code, clippy::all)]
        use core::fmt;
        use core::marker;
        use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
        /// A type which represents a component model resource, either imported or
        /// exported into this component.
        ///
        /// This is a low-level wrapper which handles the lifetime of the resource
        /// (namely this has a destructor). The `T` provided defines the component model
        /// intrinsics that this wrapper uses.
        ///
        /// One of the chief purposes of this type is to provide `Deref` implementations
        /// to access the underlying data when it is owned.
        ///
        /// This type is primarily used in generated code for exported and imported
        /// resources.
        #[repr(transparent)]
        pub struct Resource<T: WasmResource> {
            handle: AtomicU32,
            _marker: marker::PhantomData<T>,
        }
        /// A trait which all wasm resources implement, namely providing the ability to
        /// drop a resource.
        ///
        /// This generally is implemented by generated code, not user-facing code.
        #[allow(clippy::missing_safety_doc)]
        pub unsafe trait WasmResource {
            /// Invokes the `[resource-drop]...` intrinsic.
            unsafe fn drop(handle: u32);
        }
        impl<T: WasmResource> Resource<T> {
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
                if true {
                    if !(handle != 0 && handle != u32::MAX) {
                        ::core::panicking::panic(
                            "assertion failed: handle != 0 && handle != u32::MAX",
                        )
                    }
                }
                Self {
                    handle: AtomicU32::new(handle),
                    _marker: marker::PhantomData,
                }
            }
            /// Takes ownership of the handle owned by `resource`.
            ///
            /// Note that this ideally would be `into_handle` taking `Resource<T>` by
            /// ownership. The code generator does not enable that in all situations,
            /// unfortunately, so this is provided instead.
            ///
            /// Also note that `take_handle` is in theory only ever called on values
            /// owned by a generated function. For example a generated function might
            /// take `Resource<T>` as an argument but then call `take_handle` on a
            /// reference to that argument. In that sense the dynamic nature of
            /// `take_handle` should only be exposed internally to generated code, not
            /// to user code.
            #[doc(hidden)]
            pub fn take_handle(resource: &Resource<T>) -> u32 {
                resource.handle.swap(u32::MAX, Relaxed)
            }
            #[doc(hidden)]
            pub fn handle(resource: &Resource<T>) -> u32 {
                resource.handle.load(Relaxed)
            }
        }
        impl<T: WasmResource> fmt::Debug for Resource<T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("Resource").field("handle", &self.handle).finish()
            }
        }
        impl<T: WasmResource> Drop for Resource<T> {
            fn drop(&mut self) {
                unsafe {
                    match self.handle.load(Relaxed) {
                        u32::MAX => {}
                        other => T::drop(other),
                    }
                }
            }
        }
        pub use alloc_crate::string::String;
        pub use alloc_crate::vec::Vec;
        pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
            if true {
                String::from_utf8(bytes).unwrap()
            } else {
                unsafe { String::from_utf8_unchecked(bytes) }
            }
        }
        pub unsafe fn bool_lift(val: u8) -> bool {
            if true {
                match val {
                    0 => false,
                    1 => true,
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!("invalid bool discriminant"),
                        );
                    }
                }
            } else {
                val != 0
            }
        }
        pub use alloc_crate::alloc;
        pub fn as_i64<T: AsI64>(t: T) -> i64 {
            t.as_i64()
        }
        pub trait AsI64 {
            fn as_i64(self) -> i64;
        }
        impl<'a, T: Copy + AsI64> AsI64 for &'a T {
            fn as_i64(self) -> i64 {
                (*self).as_i64()
            }
        }
        impl AsI64 for i64 {
            #[inline]
            fn as_i64(self) -> i64 {
                self as i64
            }
        }
        impl AsI64 for u64 {
            #[inline]
            fn as_i64(self) -> i64 {
                self as i64
            }
        }
        pub unsafe fn invalid_enum_discriminant<T>() -> T {
            if true {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid enum discriminant"),
                    );
                }
            } else {
                unsafe { core::hint::unreachable_unchecked() }
            }
        }
        pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
            if size == 0 {
                return;
            }
            unsafe {
                let layout = alloc::Layout::from_size_align_unchecked(size, align);
                alloc::dealloc(ptr, layout);
            }
        }
        extern crate alloc as alloc_crate;
    }
    #[inline(never)]
    #[doc(hidden)]
    pub fn __link_custom_section_describing_imports() {
        wit_bindgen::rt::maybe_link_cabi_realloc();
    }
    const _: &[u8] = b"interface types {\n    /// one single row item\n    record row {\n        field-name: string,\n        value: data-type,\n    }\n    \n    /// common data types\n    variant data-type {\n        int32(s32),\n        int64(s64),\n        uint32(u32),\n        uint64(u64),\n        float(f64),\n        double(f64),\n        str(string),\n        boolean(bool),\n        date(string),\n        time(string),\n        timestamp(string),\n        binary(list<u8>),\n        null\n    }\n\n    /// allows parameterized queries\n    /// e.g., prepare(\"SELECT * FROM users WHERE name = ? AND age = ?\", vec![\"John Doe\", \"32\"])\n    resource statement {\n        prepare: static func(query: string, params: list<string>) -> result<statement, error>;\n    }\n    /// An error resource type.\n    /// Currently, this provides only one function to return a string representation\n    /// of the error. In the future, this will be extended to provide more information.\n    resource error {\n\t\ttrace: func() -> string;\n  \t}\n    \n    /// A connection to a sql store.\n    resource connection {\n        open: static func(name: string) -> result<connection, error>;\n    }\n}";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import monotonic-clock;\n    @since(version = 0.2.0)\n    import wall-clock;\n    @unstable(feature = clocks-timezone)\n    import timezone;\n}\n";
    const _: &[u8] = b"package wasi:messaging@0.2.0-draft;\n\n/// The `imports` world defines the interfaces that the component will import from the host.\n/// It includes the `producer` interface for sending messages.\nworld imports {\n  import producer;\n}\n\n/// The `imports-request-reply` world extends `imports` by including the `request-reply` interface.\n/// This allows the component to perform request/reply messaging patterns.\nworld imports-request-reply {\n  include imports;\n  import request-reply;\n}\n\n/// The `messaging-request-reply` world combines `imports-request-reply` with the `incoming-handler`\n/// export. This setup allows the host to interact with the component for both sending messages and\n/// handling incoming messages with request/reply capabilities.\nworld messaging-request-reply {\n  include imports-request-reply;\n  export incoming-handler;\n}\n\n/// The `messaging-core` world includes the basic `imports` and exports the `incoming-handler`,\n/// enabling the component to handle incoming messages without request/reply capabilities.\nworld messaging-core {\n  include imports;\n  export incoming-handler;\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// A poll API intended to let users wait for I/O events on multiple handles\n/// at once.\n@since(version = 0.2.0)\ninterface poll {\n    /// `pollable` represents a single I/O event which may be ready, or not.\n    @since(version = 0.2.0)\n    resource pollable {\n\n        /// Return the readiness of a pollable. This function never blocks.\n        ///\n        /// Returns `true` when the pollable is ready, and `false` otherwise.\n        @since(version = 0.2.0)\n        ready: func() -> bool;\n\n        /// `block` returns immediately if the pollable is ready, and otherwise\n        /// blocks until ready.\n        ///\n        /// This function is equivalent to calling `poll.poll` on a list\n        /// containing only this pollable.\n        @since(version = 0.2.0)\n        block: func();\n    }\n\n    /// Poll for completion on a set of pollables.\n    ///\n    /// This function takes a list of pollables, which identify I/O sources of\n    /// interest, and waits until one or more of the events is ready for I/O.\n    ///\n    /// The result `list<u32>` contains one or more indices of handles in the\n    /// argument list that is ready for I/O.\n    ///\n    /// This function traps if either:\n    /// - the list is empty, or:\n    /// - the list contains more elements than can be indexed with a `u32` value.\n    ///\n    /// A timeout can be implemented by adding a pollable from the\n    /// wasi-clocks API to the list.\n    ///\n    /// This function does not return a `result`; polling in itself does not\n    /// do any I/O so it doesn\'t fail. If any of the I/O sources identified by\n    /// the pollables has an error, it is indicated by marking the source as\n    /// being ready for I/O.\n    @since(version = 0.2.0)\n    poll: func(in: list<borrow<pollable>>) -> list<u32>;\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\ninterface error {\n    /// A resource which represents some error information.\n    ///\n    /// The only method provided by this resource is `to-debug-string`,\n    /// which provides some human-readable information about the error.\n    ///\n    /// In the `wasi:io` package, this resource is returned through the\n    /// `wasi:io/streams/stream-error` type.\n    ///\n    /// To provide more specific error information, other interfaces may\n    /// offer functions to \"downcast\" this error into more specific types. For example,\n    /// errors returned from streams derived from filesystem types can be described using\n    /// the filesystem\'s own error-code type. This is done using the function\n    /// `wasi:filesystem/types/filesystem-error-code`, which takes a `borrow<error>`\n    /// parameter and returns an `option<wasi:filesystem/types/error-code>`.\n    ///\n    /// The set of functions which can \"downcast\" an `error` into a more\n    /// concrete type is open.\n    @since(version = 0.2.0)\n    resource error {\n        /// Returns a string that is suitable to assist humans in debugging\n        /// this error.\n        ///\n        /// WARNING: The returned string should not be consumed mechanically!\n        /// It may change across platforms, hosts, or other implementation\n        /// details. Parsing this string is a major platform-compatibility\n        /// hazard.\n        @since(version = 0.2.0)\n        to-debug-string: func() -> string;\n    }\n}\n";
    const _: &[u8] = b"// a Container is a collection of objects\ninterface container {\n  use wasi:io/streams@0.2.6.{\n    input-stream,\n    output-stream,\n  };\n\n  use types.{\n    container-metadata,\n    error,\n    incoming-value,\n    object-metadata,\n    object-name,\n    outgoing-value,\n  };\n\n  // this defines the `container` resource\n  resource container {\n    // returns container name\n    name: func() -> result<string, error>;\n\n    // returns container metadata\n    info: func() -> result<container-metadata, error>;\n\n    // retrieves an object or portion of an object, as a resource.\n    // Start and end offsets are inclusive.\n    // Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime\n    // of the data-blob resource, even if the object they came from is later deleted.\n    get-data: func(name: object-name, start: u64, end: u64) -> result<incoming-value, error>;\n\n    // creates or replaces an object with the data blob.\n    write-data: func(name: object-name, data: borrow<outgoing-value>) -> result<_, error>;\n\n    // returns list of objects in the container. Order is undefined.\n    list-objects: func() -> result<stream-object-names, error>;\n\n    // deletes object.\n    // does not return error if object did not exist.\n    delete-object: func(name: object-name) -> result<_, error>;\n\n    // deletes multiple objects in the container\n    delete-objects: func(names: list<object-name>) -> result<_, error>;\n\n    // returns true if the object exists in this container\n    has-object: func(name: object-name) -> result<bool, error>;\n\n    // returns metadata for the object\n    object-info: func(name: object-name) -> result<object-metadata, error>;\n\n    // removes all objects within the container, leaving the container empty.\n    clear: func() -> result<_, error>;\n  }\n\n  // this defines the `stream-object-names` resource which is a representation of stream<object-name>\n  resource stream-object-names {\n    // reads the next number of objects from the stream\n    //\n    // This function returns the list of objects read, and a boolean indicating if the end of the stream was reached.\n    read-stream-object-names: func(len: u64) -> result<tuple<list<object-name>, bool>, error>;\n\n    // skip the next number of objects in the stream\n    //\n    // This function returns the number of objects skipped, and a boolean indicating if the end of the stream was reached.\n    skip-stream-object-names: func(num: u64) -> result<tuple<u64, bool>, error>;\n  }\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import streams;\n\n    @since(version = 0.2.0)\n    import poll;\n}\n";
    const _: &[u8] = b"package wasmgrid:service;\n\nworld blobstore {\n\tinclude wasi:blobstore/imports@0.2.0-draft;\n}\n\nworld keyvalue {\n\tinclude wasi:keyvalue/watch-service@0.2.0-draft2;\n}\n\nworld messaging {\n\tinclude wasi:messaging/messaging-request-reply@0.2.0-draft;\n}\n\nworld otel {\n\tinclude wasi:otel/imports@0.2.0-draft;\n}\n\nworld sql {\n\tinclude wasi:sql/imports@0.2.0-draft;\n}\n\nworld vault {\n\tinclude wasi:vault/imports@0.1.0-draft;\n}";
    const _: &[u8] = b"// Types used by blobstore\ninterface types {\n  use wasi:io/streams@0.2.6.{input-stream, output-stream};\n\n  // name of a container, a collection of objects.\n  // The container name may be any valid UTF-8 string.\n  type container-name = string;\n\n  // name of an object within a container\n  // The object name may be any valid UTF-8 string.\n  type object-name = string;\n\n  // TODO: define timestamp to include seconds since\n  // Unix epoch and nanoseconds\n  // https://github.com/WebAssembly/wasi-blob-store/issues/7\n  type timestamp = u64;\n\n  // size of an object, in bytes\n  type object-size = u64;\n\n  type error = string;\n\n  // information about a container\n  record container-metadata {\n    // the container\'s name\n    name: container-name,\n    // date and time container was created\n    created-at: timestamp,\n  }\n\n  // information about an object\n  record object-metadata {\n    // the object\'s name\n    name: object-name,\n    // the object\'s parent container\n    container: container-name,\n    // date and time the object was created\n    created-at: timestamp,\n    // size of the object, in bytes\n    size: object-size,\n  }\n\n  // identifier for an object that includes its container name\n  record object-id {\n    container: container-name,\n    object: object-name\n  }\n\n  /// A data is the data stored in a data blob. The value can be of any type\n  /// that can be represented in a byte array. It provides a way to write the value\n  /// to the output-stream defined in the `wasi-io` interface.\n  // Soon: switch to `resource value { ... }`\n  resource outgoing-value {\n    new-outgoing-value: static func() -> outgoing-value;\n\n    /// Returns a stream for writing the value contents.\n    ///\n    /// The returned `output-stream` is a child resource: it must be dropped\n    /// before the parent `outgoing-value` resource is dropped (or finished),\n    /// otherwise the `outgoing-value` drop or `finish` will trap.\n    ///\n    /// Returns success on the first call: the `output-stream` resource for\n    /// this `outgoing-value` may be retrieved at most once. Subsequent calls\n    /// will return error.\n    outgoing-value-write-body: func() -> result<output-stream, error>;\n\n    /// Finalize an outgoing value. This must be\n    /// called to signal that the outgoing value is complete. If the `outgoing-value`\n    /// is dropped without calling `outgoing-value.finalize`, the implementation\n    /// should treat the value as corrupted.\n    finish: static func(this: outgoing-value) -> result<_, error>;\n  }\n\n  /// A incoming-value is a wrapper around a value. It provides a way to read the value\n  /// from the input-stream defined in the `wasi-io` interface.\n  ///\n  /// The incoming-value provides two ways to consume the value:\n  /// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the\n  ///    value as a list of bytes.\n  /// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the\n  ///    value as an input-stream.\n  // Soon: switch to `resource incoming-value { ... }`\n  resource incoming-value {\n      incoming-value-consume-sync: static func(this: incoming-value) -> result<incoming-value-sync-body, error>;\n      incoming-value-consume-async: static func(this: incoming-value) -> result<incoming-value-async-body, error>;\n      size: func() -> u64;\n  }\n\n  type incoming-value-async-body = input-stream;\n  type incoming-value-sync-body = list<u8>;\n}\n";
    const _: &[u8] = b"package wasi:otel@0.2.0-draft;\n\nworld imports {\n    import tracing;\n    import metrics;\n    import %resource;\n}\n";
    const _: &[u8] = b"interface tracing {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, error};\n\n    /// Returns the current span context of the host.\n    context: func() -> span-context;\n\n    /// Called by the guest to export spans.\n    %export: func(span: list<span-data>) -> result<_, error>;\n\n    /// The data associated with a span.\n    record span-data {\n        /// Span context.\n        span-context: span-context,\n        /// Span parent id.\n        parent-span-id: string,\n        /// Span kind.\n        span-kind: span-kind,\n        // Span name.\n        name: string,\n        /// Span start time.\n        start-time: datetime,\n        /// Span end time.\n        end-time: datetime,\n        /// Span attributes.\n        attributes: list<key-value>,\n        /// Span events.\n        events: list<event>,\n        /// Span Links.\n        links: list<link>,\n        /// Span status.\n        status: status,\n        /// Instrumentation scope that produced this span.\n        instrumentation-scope: instrumentation-scope,\n        /// Number of attributes dropped by the span due to limits being reached.\n        dropped-attributes: u32,\n        /// Number of events dropped by the span due to limits being reached.\n        dropped-events: u32,\n        /// Number of links dropped by the span due to limits being reached.\n        dropped-links: u32,\n    }\n\n    /// Identifying trace information about a span that can be serialized and propagated.\n    record span-context {\n        /// The `trace-id` for this `span-context`.\n        trace-id: trace-id,\n        /// The `span-id` for this `span-context`.\n        span-id: span-id,\n        /// The `trace-flags` for this `span-context`.\n        trace-flags: trace-flags,\n        /// Whether this `span-context` was propagated from a remote parent.\n        is-remote: bool,\n        /// The `trace-state` for this `span-context`.\n        trace-state: trace-state,\n    }\n\n    /// The trace that this `span-context` belongs to.\n    ///\n    /// 16 bytes encoded as a hexadecimal string.\n    type trace-id = string;\n\n    /// The id of this `span-context`.\n    ///\n    /// 8 bytes encoded as a hexadecimal string.\n    type span-id = string;\n\n    /// Flags that can be set on a `span-context`.\n    flags trace-flags {\n        /// Whether the `span` should be sampled or not.\n        sampled,\n    }\n\n    /// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.\n    ///\n    /// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.\n    type trace-state = list<tuple<string, string>>;\n\n    /// Describes the relationship between the Span, its parents, and its children in a trace.\n    enum span-kind {\n        /// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.\n        client,\n        /// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.\n        server,\n        /// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.\n        producer,\n        /// Indicates that the span describes a child of an asynchronous consumer request.\n        consumer,\n        /// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.\n        internal\n    }\n\n    /// An event describing a specific moment in time on a span and associated attributes.\n    record event {\n        /// Event name.\n        name: string,\n        /// Event time.\n        time: datetime,\n        /// Event attributes.\n        attributes: list<key-value>,\n    }\n\n    /// Describes a relationship to another `span`.\n    record link {\n        /// Denotes which `span` to link to.\n        span-context: span-context,\n        /// Attributes describing the link.\n        attributes: list<key-value>,\n    }\n\n    /// The `status` of a `span`.\n    variant status {\n        /// The default status.\n        unset,\n        /// The operation has been validated by an Application developer or Operator to have completed successfully.\n        ok,\n        /// The operation contains an error with a description.\n        error(string),\n    }\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Wall Clock is a clock API intended to let users query the current\n/// time. The name \"wall\" makes an analogy to a \"clock on the wall\", which\n/// is not necessarily monotonic as it may be reset.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A wall clock is a clock which measures the date and time according to\n/// some external reference.\n///\n/// External references may be reset, so this clock is not necessarily\n/// monotonic, making it unsuitable for measuring elapsed time.\n///\n/// It is intended for reporting the current date and time for humans.\n@since(version = 0.2.0)\ninterface wall-clock {\n    /// A time and date in seconds plus nanoseconds.\n    @since(version = 0.2.0)\n    record datetime {\n        seconds: u64,\n        nanoseconds: u32,\n    }\n\n    /// Read the current value of the clock.\n    ///\n    /// This clock is not monotonic, therefore calling this function repeatedly\n    /// will not necessarily produce a sequence of non-decreasing values.\n    ///\n    /// The returned timestamps represent the number of seconds since\n    /// 1970-01-01T00:00:00Z, also known as [POSIX\'s Seconds Since the Epoch],\n    /// also known as [Unix Time].\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    ///\n    /// [POSIX\'s Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16\n    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time\n    @since(version = 0.2.0)\n    now: func() -> datetime;\n\n    /// Query the resolution of the clock.\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    @since(version = 0.2.0)\n    resolution: func() -> datetime;\n}\n";
    const _: &[u8] = b"/// The request-reply interface allows a guest to send a message and await a response. This\n/// interface is considered optional as not all message services support the concept of\n/// request/reply. However, request/reply is a very common pattern in messaging and as such, we have\n/// included it as a core interface.\ninterface request-reply {\n    use types.{client, message, error, topic};\n\n    /// Options for a request/reply operation. This is a resource to allow for future expansion of\n    /// options.\n    resource request-options {\n        /// Creates a new request options resource with no options set.\n        constructor();\n\n        /// The maximum amount of time to wait for a response. If the timeout value is not set, then\n        /// the request/reply operation will block until a message is received in response.\n        set-timeout-ms: func(timeout-ms: u32);\n\n        /// The maximum number of replies to expect before returning.\n        set-expected-replies: func(expected-replies: u32);\n    }\n\n    /// Performs a blocking request/reply operation with an optional set of request options. \n    /// \n    /// The behavior of this function is largely dependent on the options given to the function.\n    /// If no options are provided, then the request/reply operation will block until a single \n    /// message is received in response. If a timeout is provided, then the request/reply operation\n    /// will block for the specified amount of time before returning an error if no messages were\n    /// received (or the list of messages that were received). If both a timeout and an expected\n    /// number of replies are provided, the function should return when either condition is met\n    /// (whichever comes first)\xe2\x80\x94e.g., (1) if no replies were received within the timeout return an\n    /// error, (2) if the maximum expected number of replies were received before timeout, return\n    /// the list of messages, or (3) if the timeout is reached before the expected number of replies,\n    /// return the list of messages received up to that point.\n    request: func(c: borrow<client>, topic: topic, message: borrow<message>, options: option<request-options>) -> result<list<message>, error>;\n\n    /// Replies to the given message with the given response message. The details of which topic\n    /// the message is sent to is up to the implementation. This allows for reply-to details to be\n    /// handled in the best way possible for the underlying messaging system.\n    /// \n    /// Please note that this reply functionality is different than something like HTTP because there\n    /// are several use cases in which a reply might not be required for every message (so this would\n    /// be a noop). There are also cases when you might want to reply and then continue processing.\n    /// Additionally, you might want to reply to a message several times (such as providing an\n    /// update). So this function is allowed to be called multiple times, unlike something like HTTP\n    /// where the reply is sent and the connection is closed.\n    reply: func(reply-to: borrow<message>, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"interface metrics {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, %resource, error};\n\n    /// Gathers and returns all metric data related to the [MetricReader] from the\n    /// SDK and stores it in the provided [ResourceMetrics] reference.\n    ///\n    /// An error is returned if this is called after shutdown.\n    %export: func(rm: resource-metrics) -> result<_, error>;\n\n    /// A collection of scope metrics and the associated resource that created them.\n    record resource-metrics {\n        /// The entity that collected the metrics.\n        %resource: %resource,\n\n        /// The collection of metrics with unique [InstrumentationScope]s.\n        scope-metrics: list<scope-metrics>,\n    }\n\n    record scope-metrics {\n        /// The instrumentation scope that the meter was created with.\n        scope: instrumentation-scope,\n\n        /// The list of aggregations created by the meter.\n        metrics: list<metric>,\n    }\n\n    /// A collection of one or more aggregated time series from an [Instrument].\n    ///\n    /// [Instrument]: crate::metrics::Instrument\n    record metric {\n        /// The name of the instrument that created this data.\n        name: string,\n\n        /// The description of the instrument, which can be used in documentation.\n        description: string,\n\n        /// The unit in which the instrument reports.\n        unit: string,\n\n        /// The aggregated data from an instrument.\n        data: aggregated-metrics,\n    }\n\n    /// Aggregated metrics data from an instrument\n    variant aggregated-metrics {\n        /// All metric data with `f64` value type\n        %f64(metric-data),\n\n        /// All metric data with `u64` value type\n        %u64(metric-data),\n\n        /// All metric data with `i64` value type\n        %s64(metric-data),\n    }\n\n    /// Metric data for all types\n    variant metric-data {\n        /// Metric data for Gauge\n        gauge(gauge),\n\n        /// Metric data for Sum\n        sum(sum),\n\n        /// Metric data for Histogram\n        histogram(histogram),\n\n        /// Metric data for ExponentialHistogram\n        exponential-histogram(exponential-histogram),\n    }\n\n    /// A measurement of the current value of an instrument.\n    record gauge {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<gauge-data-point>,\n\n        /// The time when the time series was started.\n        start-time: option<datetime>,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record gauge-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the sum of all measurements of values from an instrument.\n    record sum {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<sum-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n\n        /// Whether this aggregation only increases or decreases.\n        is-monotonic: bool,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record sum-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the histogram of all measurements of values from an instrument.\n    record histogram {\n        /// Individual aggregated measurements with unique attributes.\n        data-points: list<histogram-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single histogram data point in a time series.\n    record histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The upper bounds of the buckets of the histogram.\n        ///\n        /// Because the last boundary is +infinity this one is implied.\n        bounds: list<f64>,\n\n        /// The count of each of the buckets.\n        bucket-counts: list<u64>,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// The histogram of all measurements of values from an instrument.\n    record exponential-histogram {\n        /// The individual aggregated measurements with unique attributes.\n        data-points: list<exponential-histogram-data-point>,\n\n        /// When the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single exponential histogram data point in a time series.\n    record exponential-histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// Describes the resolution of the histogram.\n        ///\n        /// Boundaries are located at powers of the base, where:\n        ///\n        ///   base = 2 ^ (2 ^ -scale)\n        scale: s8,\n\n        /// The number of values whose absolute value is less than or equal to\n        /// `zero_threshold`.\n        ///\n        /// When `zero_threshold` is `0`, this is the number of values that cannot be\n        /// expressed using the standard exponential formula as well as values that have\n        /// been rounded to zero.\n        zero-count: u64,\n\n        /// The range of positive value bucket counts.\n        positive-bucket: exponential-bucket,\n\n        /// The range of negative value bucket counts.\n        negative-bucket: exponential-bucket,\n\n        /// The width of the zero region.\n        ///\n        /// Where the zero region is defined as the closed interval\n        /// [-zero_threshold, zero_threshold].\n        zero-threshold: f64,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// A set of bucket counts, encoded in a contiguous array of counts.\n    record exponential-bucket {\n        /// The bucket index of the first entry in the `counts` vec.\n        offset: s32,\n\n        /// A vec where `counts[i]` carries the count of the bucket at index `offset + i`.\n        ///\n        /// `counts[i]` is the count of values greater than base^(offset+i) and less than\n        /// or equal to base^(offset+i+1).\n        counts: list<u64>,\n    }\n\n    /// Defines the window that an aggregation was calculated over.\n    enum temporality {\n        /// A measurement interval that continues to expand forward in time from a\n        /// starting point.\n        ///\n        /// New measurements are added to all previous measurements since a start time.\n        cumulative,\n\n        /// A measurement interval that resets each cycle.\n        ///\n        /// Measurements from one cycle are recorded independently, measurements from\n        /// other cycles do not affect them.\n        delta,\n\n        /// Configures Synchronous Counter and Histogram instruments to use\n        /// Delta aggregation temporality, which allows them to shed memory\n        /// following a cardinality explosion, thus use less memory.\n        low-memory,\n    }\n\n    /// A measurement sampled from a time series providing a typical example.\n    record exemplar {\n        /// The attributes recorded with the measurement but filtered out of the\n        /// time series\' aggregated data.\n        filtered-attributes: list<key-value>,\n\n        /// The time when the measurement was recorded.\n        time: datetime,\n\n        /// The measured value.\n        value: data-value,\n\n        /// The ID of the span that was active during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        span-id: string,\n\n        /// The ID of the trace the active span belonged to during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        trace-id: string,\n    }\n\n    variant data-value {\n        /// All metric data with `f64` value type\n        %f64(f64),\n\n        /// All metric data with `u64` value type\n        %u64(u64),\n\n        /// All metric data with `s64` value type\n        %s64(s64),\n    }\n\n\n    /// The identifier of a group of instruments that all perform the same function.\n    enum instrument-kind {\n        /// Identifies a group of instruments that record increasing values synchronously\n        /// with the code path they are measuring.\n        counter,\n\n        /// A group of instruments that record increasing and decreasing values\n        /// synchronously with the code path they are measuring.\n        up-down-counter,\n\n        /// A group of instruments that record a distribution of values synchronously with\n        /// the code path they are measuring.\n        histogram,\n\n        /// A group of instruments that record increasing values in an asynchronous\n        /// callback.\n        observable-counter,\n\n        /// A group of instruments that record increasing and decreasing values in an\n        /// asynchronous callback.\n        observable-up-down-counter,\n\n        /// a group of instruments that record current value synchronously with\n        /// the code path they are measuring.\n        gauge,\n\n        /// a group of instruments that record current values in an asynchronous callback.\n        observable-gauge,\n    }\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// WASI I/O is an I/O abstraction API which is currently focused on providing\n/// stream types.\n///\n/// In the future, the component model is expected to add built-in stream types;\n/// when it does, they are expected to subsume this API.\n@since(version = 0.2.0)\ninterface streams {\n    @since(version = 0.2.0)\n    use error.{error};\n    @since(version = 0.2.0)\n    use poll.{pollable};\n\n    /// An error for input-stream and output-stream operations.\n    @since(version = 0.2.0)\n    variant stream-error {\n        /// The last operation (a write or flush) failed before completion.\n        ///\n        /// More information is available in the `error` payload.\n        ///\n        /// After this, the stream will be closed. All future operations return\n        /// `stream-error::closed`.\n        last-operation-failed(error),\n        /// The stream is closed: no more input will be accepted by the\n        /// stream. A closed output-stream will return this error on all\n        /// future operations.\n        closed\n    }\n\n    /// An input bytestream.\n    ///\n    /// `input-stream`s are *non-blocking* to the extent practical on underlying\n    /// platforms. I/O operations always return promptly; if fewer bytes are\n    /// promptly available than requested, they return the number of bytes promptly\n    /// available, which could even be zero. To wait for data to be available,\n    /// use the `subscribe` function to obtain a `pollable` which can be polled\n    /// for using `wasi:io/poll`.\n    @since(version = 0.2.0)\n    resource input-stream {\n        /// Perform a non-blocking read from the stream.\n        ///\n        /// When the source of a `read` is binary data, the bytes from the source\n        /// are returned verbatim. When the source of a `read` is known to the\n        /// implementation to be text, bytes containing the UTF-8 encoding of the\n        /// text are returned.\n        ///\n        /// This function returns a list of bytes containing the read data,\n        /// when successful. The returned list will contain up to `len` bytes;\n        /// it may return fewer than requested, but not more. The list is\n        /// empty when no bytes are available for reading at this time. The\n        /// pollable given by `subscribe` will be ready when more bytes are\n        /// available.\n        ///\n        /// This function fails with a `stream-error` when the operation\n        /// encounters an error, giving `last-operation-failed`, or when the\n        /// stream is closed, giving `closed`.\n        ///\n        /// When the caller gives a `len` of 0, it represents a request to\n        /// read 0 bytes. If the stream is still open, this call should\n        /// succeed and return an empty list, or otherwise fail with `closed`.\n        ///\n        /// The `len` parameter is a `u64`, which could represent a list of u8 which\n        /// is not possible to allocate in wasm32, or not desirable to allocate as\n        /// as a return value by the callee. The callee may return a list of bytes\n        /// less than `len` in size while more bytes are available for reading.\n        @since(version = 0.2.0)\n        read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Read bytes from a stream, after blocking until at least one byte can\n        /// be read. Except for blocking, behavior is identical to `read`.\n        @since(version = 0.2.0)\n        blocking-read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Skip bytes from a stream. Returns number of bytes skipped.\n        ///\n        /// Behaves identical to `read`, except instead of returning a list\n        /// of bytes, returns the number of bytes consumed from the stream.\n        @since(version = 0.2.0)\n        skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Skip bytes from a stream, after blocking until at least one byte\n        /// can be skipped. Except for blocking behavior, identical to `skip`.\n        @since(version = 0.2.0)\n        blocking-skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Create a `pollable` which will resolve once either the specified stream\n        /// has bytes available to read or the other end of the stream has been\n        /// closed.\n        /// The created `pollable` is a child resource of the `input-stream`.\n        /// Implementations may trap if the `input-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n    }\n\n\n    /// An output bytestream.\n    ///\n    /// `output-stream`s are *non-blocking* to the extent practical on\n    /// underlying platforms. Except where specified otherwise, I/O operations also\n    /// always return promptly, after the number of bytes that can be written\n    /// promptly, which could even be zero. To wait for the stream to be ready to\n    /// accept data, the `subscribe` function to obtain a `pollable` which can be\n    /// polled for using `wasi:io/poll`.\n    ///\n    /// Dropping an `output-stream` while there\'s still an active write in\n    /// progress may result in the data being lost. Before dropping the stream,\n    /// be sure to fully flush your writes.\n    @since(version = 0.2.0)\n    resource output-stream {\n        /// Check readiness for writing. This function never blocks.\n        ///\n        /// Returns the number of bytes permitted for the next call to `write`,\n        /// or an error. Calling `write` with more bytes than this function has\n        /// permitted will trap.\n        ///\n        /// When this function returns 0 bytes, the `subscribe` pollable will\n        /// become ready when this function will report at least 1 byte, or an\n        /// error.\n        @since(version = 0.2.0)\n        check-write: func() -> result<u64, stream-error>;\n\n        /// Perform a write. This function never blocks.\n        ///\n        /// When the destination of a `write` is binary data, the bytes from\n        /// `contents` are written verbatim. When the destination of a `write` is\n        /// known to the implementation to be text, the bytes of `contents` are\n        /// transcoded from UTF-8 into the encoding of the destination and then\n        /// written.\n        ///\n        /// Precondition: check-write gave permit of Ok(n) and contents has a\n        /// length of less than or equal to n. Otherwise, this function will trap.\n        ///\n        /// returns Err(closed) without writing if the stream has closed since\n        /// the last call to check-write provided a permit.\n        @since(version = 0.2.0)\n        write: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 bytes, and then flush the stream. Block\n        /// until all of these operations are complete, or an error occurs.\n        ///\n        /// Returns success when all of the contents written are successfully\n        /// flushed to output. If an error occurs at any point before all\n        /// contents are successfully flushed, that error is returned as soon as\n        /// possible. If writing and flushing the complete contents causes the\n        /// stream to become closed, this call should return success, and\n        /// subsequent calls to check-write or other interfaces should return\n        /// stream-error::closed.\n        @since(version = 0.2.0)\n        blocking-write-and-flush: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Request to flush buffered output. This function never blocks.\n        ///\n        /// This tells the output-stream that the caller intends any buffered\n        /// output to be flushed. the output which is expected to be flushed\n        /// is all that has been passed to `write` prior to this call.\n        ///\n        /// Upon calling this function, the `output-stream` will not accept any\n        /// writes (`check-write` will return `ok(0)`) until the flush has\n        /// completed. The `subscribe` pollable will become ready when the\n        /// flush has completed and the stream can accept more writes.\n        @since(version = 0.2.0)\n        flush: func() -> result<_, stream-error>;\n\n        /// Request to flush buffered output, and block until flush completes\n        /// and stream is ready for writing again.\n        @since(version = 0.2.0)\n        blocking-flush: func() -> result<_, stream-error>;\n\n        /// Create a `pollable` which will resolve once the output-stream\n        /// is ready for more writing, or an error has occurred. When this\n        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an\n        /// error.\n        ///\n        /// If the stream is closed, this pollable is always ready immediately.\n        ///\n        /// The created `pollable` is a child resource of the `output-stream`.\n        /// Implementations may trap if the `output-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n\n        /// Write zeroes to a stream.\n        ///\n        /// This should be used precisely like `write` with the exact same\n        /// preconditions (must use check-write first), but instead of\n        /// passing a list of bytes, you simply pass the number of zero-bytes\n        /// that should be written.\n        @since(version = 0.2.0)\n        write-zeroes: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 zeroes, and then flush the stream.\n        /// Block until all of these operations are complete, or an error\n        /// occurs.\n        ///\n        /// Functionality is equivelant to `blocking-write-and-flush` with\n        /// contents given as a list of len containing only zeroes.\n        @since(version = 0.2.0)\n        blocking-write-zeroes-and-flush: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Read from one stream and write to another.\n        ///\n        /// The behavior of splice is equivalent to:\n        /// 1. calling `check-write` on the `output-stream`\n        /// 2. calling `read` on the `input-stream` with the smaller of the\n        /// `check-write` permitted length and the `len` provided to `splice`\n        /// 3. calling `write` on the `output-stream` with that read data.\n        ///\n        /// Any error reported by the call to `check-write`, `read`, or\n        /// `write` ends the splice and reports that error.\n        ///\n        /// This function returns the number of bytes transferred; it may be less\n        /// than `len`.\n        @since(version = 0.2.0)\n        splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Read from one stream and write to another, with blocking.\n        ///\n        /// This is similar to `splice`, except that it blocks until the\n        /// `output-stream` is ready for writing, and the `input-stream`\n        /// is ready for reading, before performing the `splice`.\n        @since(version = 0.2.0)\n        blocking-splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n    }\n}\n";
    const _: &[u8] = b"/// The producer interface is used to send messages to a channel/topic.\ninterface producer {\n    use types.{client, message, error, topic};\n\n    /// Sends the message using the given client.\n    send: async func(c: client, topic: topic, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"interface readwrite {\n    use types.{statement, row, error, connection};\n    \n    /// query is optimized for querying data, and \n    /// implementors can make use of that fact to optimize \n    /// the performance of query execution (e.g., using\n    /// indexes).\n    query: func(c: borrow<connection>, q: borrow<statement>) -> result<list<row>, error>;\n    \n    /// exec is for modifying data in the database.\n    exec: func(c: borrow<connection>, q: borrow<statement>) -> result<u32, error>;\n}";
    const _: &[u8] = b"interface %resource {\n    use types.{key, value, key-value, %resource as telemetry-resource};\n\n    /// Returns the telemetry resource used by the host.\n    %resource: func() -> telemetry-resource;\n}\n";
    const _: &[u8] = b"interface vault {\n    /// An error type that encapsulates the different errors that can occur fetching secrets\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// Open the specified locker.\n    /// \n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(locker-id: string) -> result<locker, error>;\n\n    /// A locker contains collection of related secrets.\n    resource locker {\n        /// Get the specified secret.\n        ///\n        /// Returns `none` if the specified secret does not exist.\n        get: func(secret-id: string) -> result<option<list<u8>>, error>;\n\n        /// Store a secret in the vault. If the `id` already exists, the\n        /// secret will be overwritten.\n        set: func(secret-id: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the specified secret.\n        /// \n        /// Will do nothing if the secret does not exist.\n        delete: func(secret-id: string) -> result<_, error>;\n\n        /// Check if the specified secret exists.\n        exists: func(secret-id: string) -> result<bool, error>;\n\n        /// List all `secret-id`s in the locker.\n        list-ids: func() -> result<list<string>, error>;\n    }\n}";
    const _: &[u8] = b"/// A keyvalue interface that provides eventually consistent key-value operations.\n/// \n/// Each of these operations acts on a single key-value pair.\n/// \n/// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is\n/// the common denominator for all data types defined by different key-value stores to handle data,\n/// ensuring compatibility between different key-value stores. Note: the clients will be expecting\n/// serialization/deserialization overhead to be handled by the key-value store. The value could be\n/// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.\n/// \n/// Data consistency in a key value store refers to the guarantee that once a write operation\n/// completes, all subsequent read operations will return the value that was written.\n/// \n/// Any implementation of this interface must have enough consistency to guarantee \"reading your\n/// writes.\" In particular, this means that the client should never get a value that is older than\n/// the one it wrote, but it MAY get a newer value if one was written around the same time. These\n/// guarantees only apply to the same client (which will likely be provided by the host or an\n/// external capability of some kind). In this context a \"client\" is referring to the caller or\n/// guest that is consuming this interface. Once a write request is committed by a specific client,\n/// all subsequent read requests by the same client will reflect that write or any subsequent\n/// writes. Another client running in a different context may or may not immediately see the result\n/// due to the replication lag. As an example of all of this, if a value at a given key is A, and\n/// the client writes B, then immediately reads, it should get B. If something else writes C in\n/// quick succession, then the client may get C. However, a client running in a separate context may\n/// still see A or B\ninterface store {\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// A response to a `list-keys` operation.\n    record key-response {\n        /// The list of keys returned by the query.\n        keys: list<string>,\n        /// The continuation token to use to fetch the next page of keys. If this is `null`, then\n        /// there are no more keys to fetch.\n        cursor: option<string>\n    }\n\n    /// Get the bucket with the specified identifier.\n    ///\n    /// `identifier` must refer to a bucket provided by the host.\n    ///\n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(identifier: string) -> result<bucket, error>;\n\n    /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the\n    /// bucket, and the bucket itself acts as a collection of all these entries.\n    ///\n    /// It is worth noting that the exact terminology for bucket in key-value stores can very\n    /// depending on the specific implementation. For example:\n    ///\n    /// 1. Amazon DynamoDB calls a collection of key-value pairs a table\n    /// 2. Redis has hashes, sets, and sorted sets as different types of collections\n    /// 3. Cassandra calls a collection of key-value pairs a column family\n    /// 4. MongoDB calls a collection of key-value pairs a collection\n    /// 5. Riak calls a collection of key-value pairs a bucket\n    /// 6. Memcached calls a collection of key-value pairs a slab\n    /// 7. Azure Cosmos DB calls a collection of key-value pairs a container\n    ///\n    /// In this interface, we use the term `bucket` to refer to a collection of key-value pairs\n    resource bucket {\n        /// Get the value associated with the specified `key`\n        ///\n        /// The value is returned as an option. If the key-value pair exists in the\n        /// store, it returns `Ok(value)`. If the key does not exist in the\n        /// store, it returns `Ok(none)`. \n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        get: func(key: string) -> result<option<list<u8>>, error>;\n\n        /// Set the value associated with the key in the store. If the key already\n        /// exists in the store, it overwrites the value.\n        ///\n        /// If the key does not exist in the store, it creates a new key-value pair.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        set: func(key: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the key-value pair associated with the key in the store.\n        /// \n        /// If the key does not exist in the store, it does nothing.\n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        delete: func(key: string) -> result<_, error>;\n\n        /// Check if the key exists in the store.\n        /// \n        /// If the key exists in the store, it returns `Ok(true)`. If the key does\n        /// not exist in the store, it returns `Ok(false)`.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        exists: func(key: string) -> result<bool, error>;\n\n        /// Get all the keys in the store with an optional cursor (for use in pagination). It\n        /// returns a list of keys. Please note that for most KeyValue implementations, this is a\n        /// can be a very expensive operation and so it should be used judiciously. Implementations\n        /// can return any number of keys in a single response, but they should never attempt to\n        /// send more data than is reasonable (i.e. on a small edge device, this may only be a few\n        /// KB, while on a large machine this could be several MB). Any response should also return\n        /// a cursor that can be used to fetch the next page of keys. See the `key-response` record\n        /// for more information.\n        /// \n        /// Note that the keys are not guaranteed to be returned in any particular order.\n        /// \n        /// If the store is empty, it returns an empty list.\n        /// \n        /// MAY show an out-of-date list of keys if there are concurrent writes to the store.\n        /// \n        /// If any error occurs, it returns an `Err(error)`.\n        list-keys: func(cursor: option<string>) -> result<key-response, error>;\n    }\n}\n";
    const _: &[u8] = b"package wasi:blobstore@0.2.0-draft;\n\nworld imports {\n\timport blobstore;\n}\n";
    const _: &[u8] = b"package wasi:keyvalue@0.2.0-draft2;\n\n/// The `wasi:keyvalue/imports` world provides common APIs for interacting with key-value stores.\n/// Components targeting this world will be able to do:\n/// \n/// 1. CRUD (create, read, update, delete) operations on key-value stores.\n/// 2. Atomic `increment` and CAS (compare-and-swap) operations.\n/// 3. Batch operations that can reduce the number of round trips to the network.\nworld imports {\n\t/// The `store` capability allows the component to perform eventually consistent operations on\n\t/// the key-value store.\n\timport store;\n\n\t/// The `atomic` capability allows the component to perform atomic / `increment` and CAS\n\t/// (compare-and-swap) operations.\n\timport atomics;\n\n\t/// The `batch` capability allows the component to perform eventually consistent batch\n\t/// operations that can reduce the number of round trips to the network.\n\timport batch;\n}\n\nworld watch-service {\n\tinclude imports;\n\texport watcher;\n}";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@unstable(feature = clocks-timezone)\ninterface timezone {\n    @unstable(feature = clocks-timezone)\n    use wall-clock.{datetime};\n\n    /// Return information needed to display the given `datetime`. This includes\n    /// the UTC offset, the time zone name, and a flag indicating whether\n    /// daylight saving time is active.\n    ///\n    /// If the timezone cannot be determined for the given `datetime`, return a\n    /// `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight\n    /// saving time.\n    @unstable(feature = clocks-timezone)\n    display: func(when: datetime) -> timezone-display;\n\n    /// The same as `display`, but only return the UTC offset.\n    @unstable(feature = clocks-timezone)\n    utc-offset: func(when: datetime) -> s32;\n\n    /// Information useful for displaying the timezone of a specific `datetime`.\n    ///\n    /// This information may vary within a single `timezone` to reflect daylight\n    /// saving time adjustments.\n    @unstable(feature = clocks-timezone)\n    record timezone-display {\n        /// The number of seconds difference between UTC time and the local\n        /// time of the timezone.\n        ///\n        /// The returned value will always be less than 86400 which is the\n        /// number of seconds in a day (24*60*60).\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return 0.\n        utc-offset: s32,\n\n        /// The abbreviated name of the timezone to display to a user. The name\n        /// `UTC` indicates Coordinated Universal Time. Otherwise, this should\n        /// reference local standards for the name of the time zone.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should be the string `UTC`.\n        ///\n        /// In time zones that do not have an applicable name, a formatted\n        /// representation of the UTC offset may be returned, such as `-04:00`.\n        name: string,\n\n        /// Whether daylight saving time is active.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return false.\n        in-daylight-saving-time: bool,\n    }\n}\n";
    const _: &[u8] = b"interface incoming-handler {\n    use types.{message, error, topic};\n\n    /// Whenever this guest receives a message in one of the subscribed topics, the message is\n    /// sent to this handler. The guest is responsible for matching on the topic and handling the\n    /// message accordingly. Implementors (such as hosts) calling this interface should make their\n    /// own decisions on how to handle errors returned from this function.\n    handle: async func(message: message) -> result<_, error>;\n\n\n    /// Server configuration.\n    ///\n    /// This can be extended to include other configuration options in the\n    /// future.\n    record configuration {\n        /// Subscription topics\n        topics: list<topic>,\n    }\n\n    /// Configure is called by the runtime to get the server\'s runtime\n    /// configuration.\n    configure: async func() -> result<configuration, error>;\n\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Monotonic Clock is a clock API intended to let users measure elapsed\n/// time.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A monotonic clock is a clock which has an unspecified initial value, and\n/// successive reads of the clock will produce non-decreasing values.\n@since(version = 0.2.0)\ninterface monotonic-clock {\n    @since(version = 0.2.0)\n    use wasi:io/poll@0.2.6.{pollable};\n\n    /// An instant in time, in nanoseconds. An instant is relative to an\n    /// unspecified initial value, and can only be compared to instances from\n    /// the same monotonic-clock.\n    @since(version = 0.2.0)\n    type instant = u64;\n\n    /// A duration of time, in nanoseconds.\n    @since(version = 0.2.0)\n    type duration = u64;\n\n    /// Read the current value of the clock.\n    ///\n    /// The clock is monotonic, therefore calling this function repeatedly will\n    /// produce a sequence of non-decreasing values.\n    @since(version = 0.2.0)\n    now: func() -> instant;\n\n    /// Query the resolution of the clock. Returns the duration of time\n    /// corresponding to a clock tick.\n    @since(version = 0.2.0)\n    resolution: func() -> duration;\n\n    /// Create a `pollable` which will resolve once the specified instant\n    /// has occurred.\n    @since(version = 0.2.0)\n    subscribe-instant: func(\n        when: instant,\n    ) -> pollable;\n\n    /// Create a `pollable` that will resolve after the specified duration has\n    /// elapsed from the time this function is invoked.\n    @since(version = 0.2.0)\n    subscribe-duration: func(\n        when: duration,\n    ) -> pollable;\n}\n";
    const _: &[u8] = b"interface types {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n\n    /// A key-value pair describing an attribute.\n    record key-value {\n        /// The attribute name.\n        key: key,\n        /// The attribute value.\n        value: value,\n    }\n\n    /// The key part of attribute `key-value` pairs.\n    type key = string;\n\n    /// The value part of attribute `key-value` pairs.\n    variant value {\n        /// A string value.\n        %string(string),\n        /// A boolean value.\n        %bool(bool),\n        /// A double precision floating point value.\n        %f64(f64),\n        /// A signed 64 bit integer value.\n        %s64(s64),\n        /// A homogeneous array of string values.\n        string-array(list<string>),\n        /// A homogeneous array of boolean values.\n        bool-array(list<bool>),\n        /// A homogeneous array of double precision floating point values.\n        f64-array(list<f64>),\n        /// A homogeneous array of 64 bit integer values.\n        s64-array(list<s64>),\n    }\n\n    /// The host resource describing the entity producing telemetry.\n    record %resource {\n        /// Specifies the resource attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n    }\n\n    /// Describes the instrumentation scope that produced a span.\n    record instrumentation-scope {\n        /// Name of the instrumentation scope.\n        name: string,\n\n        /// The library version.\n        version: option<string>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n\n        /// Specifies the instrumentation scope attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n    }\n\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// Shutdown has already been invoked.\n        already-shutdown,\n\n        /// Operation timed out before completing.\n        timeout(u64),\n\n        /// Operation failed due to an internal error.\n        internal-failure(string)\n    }\n}\n";
    const _: &[u8] = b"package wasi:sql@0.2.0-draft;\n\nworld imports {\n\timport readwrite;\n}";
    const _: &[u8] = b"interface types {\n    /// A type alias for list<tuple<string, string>> to represent metadata attached to a message\n    type metadata = list<tuple<string, string>>;\n\n    /// A type alias for string to represent a message topic\n    type topic = string;\n\n    /// A connection to a message-exchange service (e.g., buffer, broker, etc.).\n    resource client {\n        connect: static func(name: string) -> result<client, error>;\n        disconnect: func() -> result<_, error>;\n    }\n\n    /// Errors that can occur when using the messaging interface.\n    variant error {\n        /// The request or operation timed out.\n        timeout,\n        /// An error occurred with the connection. Includes a message for additional context\n        connection(string),\n        /// A permission error occurred. Includes a message for additional context\n        permission-denied(string),\n        /// A catch all for other types of errors\n        other(string),\n    }\n\n    /// A message with a binary payload and additional information\n    resource message {\n        constructor(data: list<u8>);\n        // new: static func(data: stream<u8>) -> message;\n\n        /// The topic/subject/channel this message was received on, if any\n        topic: func() -> option<topic>;\n        /// An optional content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        content-type: func() -> option<string>;\n        /// Set the content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        set-content-type: func(content-type: string);\n        /// An opaque blob of data\n        data: func() -> list<u8>;\n        /// Set the opaque blob of data for this message, discarding the old value\n        set-data: func(data: list<u8>);\n        /// Optional metadata (also called headers or attributes in some systems) attached to the\n        /// message. This metadata is simply decoration and should not be interpreted by a host\n        /// to ensure portability across different implementors (e.g., Kafka -> NATS, etc.).\n        metadata: func() -> option<metadata>;\n        /// Add a new key-value pair to the metadata, overwriting any existing value for the same key\n        add-metadata: func(key: string, value: string);\n        /// Set the metadata\n        set-metadata: func(meta: metadata);\n        /// Remove a key-value pair from the metadata\n        remove-metadata: func(key: string);\n    }\n}\n";
    const _: &[u8] = b"package wasi:vault@0.1.0-draft;\n\nworld imports {\n  import vault;\n}\n";
    const _: &[u8] = b"// wasi-cloud Blobstore service definition\ninterface blobstore {\n  use container.{container};\n  use types.{error, container-name, object-id};\n\n  // creates a new empty container\n  create-container: func(name: container-name) -> result<container, error>;\n\n  // retrieves a container by name\n  get-container: func(name: container-name) -> result<container, error>;\n\n  // deletes a container and all objects within it\n  delete-container: func(name: container-name) -> result<_, error>;\n\n  // returns true if the container exists\n  container-exists: func(name: container-name) -> result<bool, error>;\n\n  // copies (duplicates) an object, to the same or a different container.\n  // returns an error if the target container does not exist.\n  // overwrites destination object if it already existed.\n  copy-object: func(src: object-id, dest: object-id) -> result<_, error>;\n\n  // moves or renames an object, to the same or a different container\n  // returns an error if the destination container does not exist.\n  // overwrites destination object if it already existed.\n  move-object: func(src:object-id, dest: object-id) -> result<_, error>;\n}";
    const _: &[u8] = b"/// A keyvalue interface that provides atomic operations.\n/// \n/// Atomic operations are single, indivisible operations. When a fault causes an atomic operation to\n/// fail, it will appear to the invoker of the atomic operation that the action either completed\n/// successfully or did nothing at all.\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface atomics {\n  \tuse store.{bucket, error};\n\n\t/// The error returned by a CAS operation\n\tvariant cas-error {\n\t\t/// A store error occurred when performing the operation\n\t\tstore-error(error),\n\t\t/// The CAS operation failed because the value was too old. This returns a new CAS handle\n\t\t/// for easy retries. Implementors MUST return a CAS handle that has been updated to the\n\t\t/// latest version or transaction.\n\t\tcas-failed(cas),\n\t}\n\n\t/// A handle to a CAS (compare-and-swap) operation.\n\tresource cas {\n\t\t/// Construct a new CAS operation. Implementors can map the underlying functionality\n\t\t/// (transactions, versions, etc) as desired.\n\t\tnew: static func(bucket: borrow<bucket>, key: string) -> result<cas, error>;\n\t\t/// Get the current value of the key (if it exists). This allows for avoiding reads if all\n\t\t/// that is needed to ensure the atomicity of the operation\n\t\tcurrent: func() -> result<option<list<u8>>, error>;\n\t}\n\n  \t/// Atomically increment the value associated with the key in the store by the given delta. It\n\t/// returns the new value.\n\t///\n\t/// If the key does not exist in the store, it creates a new key-value pair with the value set\n\t/// to the given delta. \n\t///\n\t/// If any other error occurs, it returns an `Err(error)`.\n\tincrement: func(bucket: borrow<bucket>, key: string, delta: s64) -> result<s64, error>;\n\n\t/// Perform the swap on a CAS operation. This consumes the CAS handle and returns an error if\n\t/// the CAS operation failed.\n\tswap: func(cas: cas, value: list<u8>) -> result<_, cas-error>;\n}";
    const _: &[u8] = b"/// A keyvalue interface that provides watch operations.\n/// \n/// This interface is used to provide event-driven mechanisms to handle\n/// keyvalue changes.\ninterface watcher {\n\t/// A keyvalue interface that provides handle-watch operations.\n\tuse store.{bucket};\n\n\t/// Handle the `set` event for the given bucket and key. It includes a reference to the `bucket`\n\t/// that can be used to interact with the store.\n\ton-set: func(bucket: bucket, key: string, value: list<u8>);\n\n\t/// Handle the `delete` event for the given bucket and key. It includes a reference to the\n\t/// `bucket` that can be used to interact with the store.\n\ton-delete: func(bucket: bucket, key: string);\n}";
    const _: &[u8] = b"/// A keyvalue interface that provides batch operations.\n/// \n/// A batch operation is an operation that operates on multiple keys at once.\n/// \n/// Batch operations are useful for reducing network round-trip time. For example, if you want to\n/// get the values associated with 100 keys, you can either do 100 get operations or you can do 1\n/// batch get operation. The batch operation is faster because it only needs to make 1 network call\n/// instead of 100.\n/// \n/// A batch operation does not guarantee atomicity, meaning that if the batch operation fails, some\n/// of the keys may have been modified and some may not. \n/// \n/// This interface does has the same consistency guarantees as the `store` interface, meaning that\n/// you should be able to \"read your writes.\"\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface batch {\n    use store.{bucket, error};\n\n    /// Get the key-value pairs associated with the keys in the store. It returns a list of\n    /// key-value pairs.\n    ///\n    /// If any of the keys do not exist in the store, it returns a `none` value for that pair in the\n    /// list.\n    /// \n    /// MAY show an out-of-date value if there are concurrent writes to the store.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`.\n    get-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<list<option<tuple<string, list<u8>>>>, error>;\n\n    /// Set the values associated with the keys in the store. If the key already exists in the\n    /// store, it overwrites the value. \n    /// \n    /// Note that the key-value pairs are not guaranteed to be set in the order they are provided. \n    ///\n    /// If any of the keys do not exist in the store, it creates a new key-value pair.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already set. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be set while others might\n    /// fail. \n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    set-many: func(bucket: borrow<bucket>, key-values: list<tuple<string, list<u8>>>) -> result<_, error>;\n\n    /// Delete the key-value pairs associated with the keys in the store.\n    /// \n    /// Note that the key-value pairs are not guaranteed to be deleted in the order they are\n    /// provided.\n    /// \n    /// If any of the keys do not exist in the store, it skips the key.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already deleted. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be deleted while others might\n    /// fail.\n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    delete-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<_, error>;\n}\n";
}
/// Bindings for the `wasi:keyvalue` world.
/// See (<https://github.com/WebAssembly/wasi-keyvalue/>)
pub mod keyvalue {
    pub use self::wasi::keyvalue::*;
    #[allow(dead_code, clippy::all)]
    pub mod wasi {
        pub mod keyvalue {
            /// A keyvalue interface that provides eventually consistent key-value operations.
            ///
            /// Each of these operations acts on a single key-value pair.
            ///
            /// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is
            /// the common denominator for all data types defined by different key-value stores to handle data,
            /// ensuring compatibility between different key-value stores. Note: the clients will be expecting
            /// serialization/deserialization overhead to be handled by the key-value store. The value could be
            /// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.
            ///
            /// Data consistency in a key value store refers to the guarantee that once a write operation
            /// completes, all subsequent read operations will return the value that was written.
            ///
            /// Any implementation of this interface must have enough consistency to guarantee "reading your
            /// writes." In particular, this means that the client should never get a value that is older than
            /// the one it wrote, but it MAY get a newer value if one was written around the same time. These
            /// guarantees only apply to the same client (which will likely be provided by the host or an
            /// external capability of some kind). In this context a "client" is referring to the caller or
            /// guest that is consuming this interface. Once a write request is committed by a specific client,
            /// all subsequent read requests by the same client will reflect that write or any subsequent
            /// writes. Another client running in a different context may or may not immediately see the result
            /// due to the replication lag. As an example of all of this, if a value at a given key is A, and
            /// the client writes B, then immediately reads, it should get B. If something else writes C in
            /// quick succession, then the client may get C. However, a client running in a separate context may
            /// still see A or B
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod store {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                /// The set of errors which may be raised by functions in this package
                pub enum Error {
                    /// The host does not recognize the store identifier requested.
                    NoSuchStore,
                    /// The requesting component does not have access to the specified store
                    /// (which may or may not exist).
                    AccessDenied,
                    /// Some implementation-specific error has occurred (e.g. I/O)
                    Other(_rt::String),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Error {
                    #[inline]
                    fn clone(&self) -> Error {
                        match self {
                            Error::NoSuchStore => Error::NoSuchStore,
                            Error::AccessDenied => Error::AccessDenied,
                            Error::Other(__self_0) => {
                                Error::Other(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Error::NoSuchStore => {
                                f.debug_tuple("Error::NoSuchStore").finish()
                            }
                            Error::AccessDenied => {
                                f.debug_tuple("Error::AccessDenied").finish()
                            }
                            Error::Other(e) => {
                                f.debug_tuple("Error::Other").field(e).finish()
                            }
                        }
                    }
                }
                impl ::core::fmt::Display for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for Error {}
                /// A response to a `list-keys` operation.
                pub struct KeyResponse {
                    /// The list of keys returned by the query.
                    pub keys: _rt::Vec<_rt::String>,
                    /// The continuation token to use to fetch the next page of keys. If this is `null`, then
                    /// there are no more keys to fetch.
                    pub cursor: Option<_rt::String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for KeyResponse {
                    #[inline]
                    fn clone(&self) -> KeyResponse {
                        KeyResponse {
                            keys: ::core::clone::Clone::clone(&self.keys),
                            cursor: ::core::clone::Clone::clone(&self.cursor),
                        }
                    }
                }
                impl ::core::fmt::Debug for KeyResponse {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("KeyResponse")
                            .field("keys", &self.keys)
                            .field("cursor", &self.cursor)
                            .finish()
                    }
                }
                /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the
                /// bucket, and the bucket itself acts as a collection of all these entries.
                ///
                /// It is worth noting that the exact terminology for bucket in key-value stores can very
                /// depending on the specific implementation. For example:
                ///
                /// 1. Amazon DynamoDB calls a collection of key-value pairs a table
                /// 2. Redis has hashes, sets, and sorted sets as different types of collections
                /// 3. Cassandra calls a collection of key-value pairs a column family
                /// 4. MongoDB calls a collection of key-value pairs a collection
                /// 5. Riak calls a collection of key-value pairs a bucket
                /// 6. Memcached calls a collection of key-value pairs a slab
                /// 7. Azure Cosmos DB calls a collection of key-value pairs a container
                ///
                /// In this interface, we use the term `bucket` to refer to a collection of key-value pairs
                #[repr(transparent)]
                pub struct Bucket {
                    handle: _rt::Resource<Bucket>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Bucket {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Bucket",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl Bucket {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for Bucket {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Get the bucket with the specified identifier.
                ///
                /// `identifier` must refer to a bucket provided by the host.
                ///
                /// `error::no-such-store` will be raised if the `identifier` is not recognized.
                #[allow(async_fn_in_trait)]
                pub fn open(identifier: &str) -> Result<Bucket, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = identifier;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result10 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>();
                                    Bucket::from_handle(l4 as u32)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v9 = match l5 {
                                        0 => Error::NoSuchStore,
                                        1 => Error::AccessDenied,
                                        n => {
                                            if true {
                                                match (&n, &2) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e9 = {
                                                let l6 = *ptr1
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l7 = *ptr1
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len8 = l7;
                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                    l6.cast(),
                                                    len8,
                                                    len8,
                                                );
                                                _rt::string_lift(bytes8)
                                            };
                                            Error::Other(e9)
                                        }
                                    };
                                    v9
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
                impl Bucket {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Get the value associated with the specified `key`
                    ///
                    /// The value is returned as an option. If the key-value pair exists in the
                    /// store, it returns `Ok(value)`. If the key does not exist in the
                    /// store, it returns `Ok(none)`.
                    ///
                    /// If any other error occurs, it returns an `Err(error)`.
                    #[allow(async_fn_in_trait)]
                    pub fn get(&self, key: &str) -> Result<Option<_rt::Vec<u8>>, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = key;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result13 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        match l4 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l5 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l6 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len7 = l6;
                                                    _rt::Vec::from_raw_parts(l5.cast(), len7, len7)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        }
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l8 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v12 = match l8 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e12 = {
                                                    let l9 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l10 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len11 = l10;
                                                    let bytes11 = _rt::Vec::from_raw_parts(
                                                        l9.cast(),
                                                        len11,
                                                        len11,
                                                    );
                                                    _rt::string_lift(bytes11)
                                                };
                                                Error::Other(e12)
                                            }
                                        };
                                        v12
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result13
                        }
                    }
                }
                impl Bucket {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Set the value associated with the key in the store. If the key already
                    /// exists in the store, it overwrites the value.
                    ///
                    /// If the key does not exist in the store, it creates a new key-value pair.
                    ///
                    /// If any other error occurs, it returns an `Err(error)`.
                    #[allow(async_fn_in_trait)]
                    pub fn set(&self, key: &str, value: &[u8]) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = key;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let vec1 = value;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();
                            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import3(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import3(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1.cast_mut(),
                                len1,
                                ptr2,
                            );
                            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                            let result10 = match l4 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = i32::from(
                                            *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v9 = match l5 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e9 = {
                                                    let l6 = *ptr2
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l7 = *ptr2
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len8 = l7;
                                                    let bytes8 = _rt::Vec::from_raw_parts(
                                                        l6.cast(),
                                                        len8,
                                                        len8,
                                                    );
                                                    _rt::string_lift(bytes8)
                                                };
                                                Error::Other(e9)
                                            }
                                        };
                                        v9
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result10
                        }
                    }
                }
                impl Bucket {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Delete the key-value pair associated with the key in the store.
                    ///
                    /// If the key does not exist in the store, it does nothing.
                    ///
                    /// If any other error occurs, it returns an `Err(error)`.
                    #[allow(async_fn_in_trait)]
                    pub fn delete(&self, key: &str) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = key;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result9 = match l3 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v8 = match l4 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e8 = {
                                                    let l5 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l6 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len7 = l6;
                                                    let bytes7 = _rt::Vec::from_raw_parts(
                                                        l5.cast(),
                                                        len7,
                                                        len7,
                                                    );
                                                    _rt::string_lift(bytes7)
                                                };
                                                Error::Other(e8)
                                            }
                                        };
                                        v8
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result9
                        }
                    }
                }
                impl Bucket {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Check if the key exists in the store.
                    ///
                    /// If the key exists in the store, it returns `Ok(true)`. If the key does
                    /// not exist in the store, it returns `Ok(false)`.
                    ///
                    /// If any other error occurs, it returns an `Err(error)`.
                    #[allow(async_fn_in_trait)]
                    pub fn exists(&self, key: &str) -> Result<bool, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = key;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result10 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        _rt::bool_lift(l4 as u8)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v9 = match l5 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e9 = {
                                                    let l6 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l7 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len8 = l7;
                                                    let bytes8 = _rt::Vec::from_raw_parts(
                                                        l6.cast(),
                                                        len8,
                                                        len8,
                                                    );
                                                    _rt::string_lift(bytes8)
                                                };
                                                Error::Other(e9)
                                            }
                                        };
                                        v9
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result10
                        }
                    }
                }
                impl Bucket {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Get all the keys in the store with an optional cursor (for use in pagination). It
                    /// returns a list of keys. Please note that for most KeyValue implementations, this is a
                    /// can be a very expensive operation and so it should be used judiciously. Implementations
                    /// can return any number of keys in a single response, but they should never attempt to
                    /// send more data than is reasonable (i.e. on a small edge device, this may only be a few
                    /// KB, while on a large machine this could be several MB). Any response should also return
                    /// a cursor that can be used to fetch the next page of keys. See the `key-response` record
                    /// for more information.
                    ///
                    /// Note that the keys are not guaranteed to be returned in any particular order.
                    ///
                    /// If the store is empty, it returns an empty list.
                    ///
                    /// MAY show an out-of-date list of keys if there are concurrent writes to the store.
                    ///
                    /// If any error occurs, it returns an `Err(error)`.
                    #[allow(async_fn_in_trait)]
                    pub fn list_keys(
                        &self,
                        cursor: Option<&str>,
                    ) -> Result<KeyResponse, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 6 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 6
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let (result1_0, result1_1, result1_2) = match cursor {
                                Some(e) => {
                                    let vec0 = e;
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    (1i32, ptr0.cast_mut(), len0)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import3(
                                _: i32,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import3(
                                (self).handle() as i32,
                                result1_0,
                                result1_1,
                                result1_2,
                                ptr2,
                            );
                            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                            let result20 = match l4 {
                                0 => {
                                    let e = {
                                        let l5 = *ptr2
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l6 = *ptr2
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base10 = l5;
                                        let len10 = l6;
                                        let mut result10 = _rt::Vec::with_capacity(len10);
                                        for i in 0..len10 {
                                            let base = base10
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e10 = {
                                                let l7 = *base.add(0).cast::<*mut u8>();
                                                let l8 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len9 = l8;
                                                let bytes9 = _rt::Vec::from_raw_parts(
                                                    l7.cast(),
                                                    len9,
                                                    len9,
                                                );
                                                _rt::string_lift(bytes9)
                                            };
                                            result10.push(e10);
                                        }
                                        _rt::cabi_dealloc(
                                            base10,
                                            len10 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        let l11 = i32::from(
                                            *ptr2
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        KeyResponse {
                                            keys: result10,
                                            cursor: match l11 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l12 = *ptr2
                                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l13 = *ptr2
                                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len14 = l13;
                                                        let bytes14 = _rt::Vec::from_raw_parts(
                                                            l12.cast(),
                                                            len14,
                                                            len14,
                                                        );
                                                        _rt::string_lift(bytes14)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        }
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l15 = i32::from(
                                            *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v19 = match l15 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e19 = {
                                                    let l16 = *ptr2
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l17 = *ptr2
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len18 = l17;
                                                    let bytes18 = _rt::Vec::from_raw_parts(
                                                        l16.cast(),
                                                        len18,
                                                        len18,
                                                    );
                                                    _rt::string_lift(bytes18)
                                                };
                                                Error::Other(e19)
                                            }
                                        };
                                        v19
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result20
                        }
                    }
                }
            }
            /// A keyvalue interface that provides atomic operations.
            ///
            /// Atomic operations are single, indivisible operations. When a fault causes an atomic operation to
            /// fail, it will appear to the invoker of the atomic operation that the action either completed
            /// successfully or did nothing at all.
            ///
            /// Please note that this interface is bare functions that take a reference to a bucket. This is to
            /// get around the current lack of a way to "extend" a resource with additional methods inside of
            /// wit. Future version of the interface will instead extend these methods on the base `bucket`
            /// resource.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod atomics {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type Bucket = super::super::super::wasi::keyvalue::store::Bucket;
                pub type Error = super::super::super::wasi::keyvalue::store::Error;
                /// A handle to a CAS (compare-and-swap) operation.
                #[repr(transparent)]
                pub struct Cas {
                    handle: _rt::Resource<Cas>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Cas {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Cas",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl Cas {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for Cas {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                /// The error returned by a CAS operation
                pub enum CasError {
                    /// A store error occurred when performing the operation
                    StoreError(Error),
                    /// The CAS operation failed because the value was too old. This returns a new CAS handle
                    /// for easy retries. Implementors MUST return a CAS handle that has been updated to the
                    /// latest version or transaction.
                    CasFailed(Cas),
                }
                impl ::core::fmt::Debug for CasError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            CasError::StoreError(e) => {
                                f.debug_tuple("CasError::StoreError").field(e).finish()
                            }
                            CasError::CasFailed(e) => {
                                f.debug_tuple("CasError::CasFailed").field(e).finish()
                            }
                        }
                    }
                }
                impl ::core::fmt::Display for CasError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for CasError {}
                impl Cas {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Construct a new CAS operation. Implementors can map the underlying functionality
                    /// (transactions, versions, etc) as desired.
                    #[allow(async_fn_in_trait)]
                    pub fn new(bucket: &Bucket, key: &str) -> Result<Cas, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = key;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (bucket).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result10 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = *ptr1
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        Cas::from_handle(l4 as u32)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        use super::super::super::wasi::keyvalue::store::Error as V9;
                                        let v9 = match l5 {
                                            0 => V9::NoSuchStore,
                                            1 => V9::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e9 = {
                                                    let l6 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l7 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len8 = l7;
                                                    let bytes8 = _rt::Vec::from_raw_parts(
                                                        l6.cast(),
                                                        len8,
                                                        len8,
                                                    );
                                                    _rt::string_lift(bytes8)
                                                };
                                                V9::Other(e9)
                                            }
                                        };
                                        v9
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result10
                        }
                    }
                }
                impl Cas {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Get the current value of the key (if it exists). This allows for avoiding reads if all
                    /// that is needed to ensure the atomicity of the operation
                    #[allow(async_fn_in_trait)]
                    pub fn current(&self) -> Result<Option<_rt::Vec<u8>>, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result12 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = i32::from(
                                            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        match l3 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l4 = *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l5 = *ptr0
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len6 = l5;
                                                    _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        }
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l7 = i32::from(
                                            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        use super::super::super::wasi::keyvalue::store::Error as V11;
                                        let v11 = match l7 {
                                            0 => V11::NoSuchStore,
                                            1 => V11::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e11 = {
                                                    let l8 = *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l9 = *ptr0
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len10 = l9;
                                                    let bytes10 = _rt::Vec::from_raw_parts(
                                                        l8.cast(),
                                                        len10,
                                                        len10,
                                                    );
                                                    _rt::string_lift(bytes10)
                                                };
                                                V11::Other(e11)
                                            }
                                        };
                                        v11
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result12
                        }
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Atomically increment the value associated with the key in the store by the given delta. It
                /// returns the new value.
                ///
                /// If the key does not exist in the store, it creates a new key-value pair with the value set
                /// to the given delta.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                #[allow(async_fn_in_trait)]
                pub fn increment(
                    bucket: &Bucket,
                    key: &str,
                    delta: i64,
                ) -> Result<i64, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 16 + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16
                                + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(
                            (bucket).handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                            _rt::as_i64(&delta),
                            ptr1,
                        );
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result10 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1.add(8).cast::<i64>();
                                    l4
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr1.add(8).cast::<u8>());
                                    use super::super::super::wasi::keyvalue::store::Error as V9;
                                    let v9 = match l5 {
                                        0 => V9::NoSuchStore,
                                        1 => V9::AccessDenied,
                                        n => {
                                            if true {
                                                match (&n, &2) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e9 = {
                                                let l6 = *ptr1
                                                    .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l7 = *ptr1
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len8 = l7;
                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                    l6.cast(),
                                                    len8,
                                                    len8,
                                                );
                                                _rt::string_lift(bytes8)
                                            };
                                            V9::Other(e9)
                                        }
                                    };
                                    v9
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Perform the swap on a CAS operation. This consumes the CAS handle and returns an error if
                /// the CAS operation failed.
                #[allow(async_fn_in_trait)]
                pub fn swap(cas: Cas, value: &[u8]) -> Result<(), CasError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 5 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 5
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = value;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(
                            (&cas).take_handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                            ptr1,
                        );
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result12 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v11 = match l4 {
                                        0 => {
                                            let e11 = {
                                                let l5 = i32::from(
                                                    *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                use super::super::super::wasi::keyvalue::store::Error as V9;
                                                let v9 = match l5 {
                                                    0 => V9::NoSuchStore,
                                                    1 => V9::AccessDenied,
                                                    n => {
                                                        if true {
                                                            match (&n, &2) {
                                                                (left_val, right_val) => {
                                                                    if !(*left_val == *right_val) {
                                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                                        ::core::panicking::assert_failed(
                                                                            kind,
                                                                            &*left_val,
                                                                            &*right_val,
                                                                            ::core::option::Option::Some(
                                                                                format_args!("invalid enum discriminant"),
                                                                            ),
                                                                        );
                                                                    }
                                                                }
                                                            };
                                                        }
                                                        let e9 = {
                                                            let l6 = *ptr1
                                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l7 = *ptr1
                                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len8 = l7;
                                                            let bytes8 = _rt::Vec::from_raw_parts(
                                                                l6.cast(),
                                                                len8,
                                                                len8,
                                                            );
                                                            _rt::string_lift(bytes8)
                                                        };
                                                        V9::Other(e9)
                                                    }
                                                };
                                                v9
                                            };
                                            CasError::StoreError(e11)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &1) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e11 = {
                                                let l10 = *ptr1
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                Cas::from_handle(l10 as u32)
                                            };
                                            CasError::CasFailed(e11)
                                        }
                                    };
                                    v11
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result12
                    }
                }
            }
            /// A keyvalue interface that provides batch operations.
            ///
            /// A batch operation is an operation that operates on multiple keys at once.
            ///
            /// Batch operations are useful for reducing network round-trip time. For example, if you want to
            /// get the values associated with 100 keys, you can either do 100 get operations or you can do 1
            /// batch get operation. The batch operation is faster because it only needs to make 1 network call
            /// instead of 100.
            ///
            /// A batch operation does not guarantee atomicity, meaning that if the batch operation fails, some
            /// of the keys may have been modified and some may not.
            ///
            /// This interface does has the same consistency guarantees as the `store` interface, meaning that
            /// you should be able to "read your writes."
            ///
            /// Please note that this interface is bare functions that take a reference to a bucket. This is to
            /// get around the current lack of a way to "extend" a resource with additional methods inside of
            /// wit. Future version of the interface will instead extend these methods on the base `bucket`
            /// resource.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod batch {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type Bucket = super::super::super::wasi::keyvalue::store::Bucket;
                pub type Error = super::super::super::wasi::keyvalue::store::Error;
                #[allow(unused_unsafe, clippy::all)]
                /// Get the key-value pairs associated with the keys in the store. It returns a list of
                /// key-value pairs.
                ///
                /// If any of the keys do not exist in the store, it returns a `none` value for that pair in the
                /// list.
                ///
                /// MAY show an out-of-date value if there are concurrent writes to the store.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                #[allow(async_fn_in_trait)]
                pub fn get_many(
                    bucket: &Bucket,
                    keys: &[_rt::String],
                ) -> Result<_rt::Vec<Option<(_rt::String, _rt::Vec<u8>)>>, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec1 = keys;
                        let len1 = vec1.len();
                        let layout1 = _rt::alloc::Layout::from_size_align(
                                vec1.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            )
                            .unwrap();
                        let (result1, _cleanup1) = wit_bindgen::rt::Cleanup::new(
                            layout1,
                        );
                        for (i, e) in vec1.into_iter().enumerate() {
                            let base = result1
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            {
                                let vec0 = e;
                                let ptr0 = vec0.as_ptr().cast::<u8>();
                                let len0 = vec0.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len0;
                                *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                            }
                        }
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import3((bucket).handle() as i32, result1, len1, ptr2);
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result20 = match l4 {
                            0 => {
                                let e = {
                                    let l5 = *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *ptr2
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base14 = l5;
                                    let len14 = l6;
                                    let mut result14 = _rt::Vec::with_capacity(len14);
                                    for i in 0..len14 {
                                        let base = base14
                                            .add(i * (5 * ::core::mem::size_of::<*const u8>()));
                                        let e14 = {
                                            let l7 = i32::from(*base.add(0).cast::<u8>());
                                            match l7 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l8 = *base
                                                            .add(::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l9 = *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len10 = l9;
                                                        let bytes10 = _rt::Vec::from_raw_parts(
                                                            l8.cast(),
                                                            len10,
                                                            len10,
                                                        );
                                                        let l11 = *base
                                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l12 = *base
                                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len13 = l12;
                                                        (
                                                            _rt::string_lift(bytes10),
                                                            _rt::Vec::from_raw_parts(l11.cast(), len13, len13),
                                                        )
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        result14.push(e14);
                                    }
                                    _rt::cabi_dealloc(
                                        base14,
                                        len14 * (5 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    result14
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l15 = i32::from(
                                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    use super::super::super::wasi::keyvalue::store::Error as V19;
                                    let v19 = match l15 {
                                        0 => V19::NoSuchStore,
                                        1 => V19::AccessDenied,
                                        n => {
                                            if true {
                                                match (&n, &2) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e19 = {
                                                let l16 = *ptr2
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l17 = *ptr2
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len18 = l17;
                                                let bytes18 = _rt::Vec::from_raw_parts(
                                                    l16.cast(),
                                                    len18,
                                                    len18,
                                                );
                                                _rt::string_lift(bytes18)
                                            };
                                            V19::Other(e19)
                                        }
                                    };
                                    v19
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result20
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Set the values associated with the keys in the store. If the key already exists in the
                /// store, it overwrites the value.
                ///
                /// Note that the key-value pairs are not guaranteed to be set in the order they are provided.
                ///
                /// If any of the keys do not exist in the store, it creates a new key-value pair.
                ///
                /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not
                /// rollback the key-value pairs that were already set. Thus, this batch operation does not
                /// guarantee atomicity, implying that some key-value pairs could be set while others might
                /// fail.
                ///
                /// Other concurrent operations may also be able to see the partial results.
                #[allow(async_fn_in_trait)]
                pub fn set_many(
                    bucket: &Bucket,
                    key_values: &[(_rt::String, _rt::Vec<u8>)],
                ) -> Result<(), Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec3 = key_values;
                        let len3 = vec3.len();
                        let layout3 = _rt::alloc::Layout::from_size_align(
                                vec3.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            )
                            .unwrap();
                        let (result3, _cleanup3) = wit_bindgen::rt::Cleanup::new(
                            layout3,
                        );
                        for (i, e) in vec3.into_iter().enumerate() {
                            let base = result3
                                .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                            {
                                let (t0_0, t0_1) = e;
                                let vec1 = t0_0;
                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                let len1 = vec1.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len1;
                                *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                                let vec2 = t0_1;
                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                let len2 = vec2.len();
                                *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len2;
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = ptr2.cast_mut();
                            }
                        }
                        let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import5(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import5((bucket).handle() as i32, result3, len3, ptr4);
                        let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                        let result12 = match l6 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(
                                        *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    use super::super::super::wasi::keyvalue::store::Error as V11;
                                    let v11 = match l7 {
                                        0 => V11::NoSuchStore,
                                        1 => V11::AccessDenied,
                                        n => {
                                            if true {
                                                match (&n, &2) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e11 = {
                                                let l8 = *ptr4
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l9 = *ptr4
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len10 = l9;
                                                let bytes10 = _rt::Vec::from_raw_parts(
                                                    l8.cast(),
                                                    len10,
                                                    len10,
                                                );
                                                _rt::string_lift(bytes10)
                                            };
                                            V11::Other(e11)
                                        }
                                    };
                                    v11
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result12
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Delete the key-value pairs associated with the keys in the store.
                ///
                /// Note that the key-value pairs are not guaranteed to be deleted in the order they are
                /// provided.
                ///
                /// If any of the keys do not exist in the store, it skips the key.
                ///
                /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not
                /// rollback the key-value pairs that were already deleted. Thus, this batch operation does not
                /// guarantee atomicity, implying that some key-value pairs could be deleted while others might
                /// fail.
                ///
                /// Other concurrent operations may also be able to see the partial results.
                #[allow(async_fn_in_trait)]
                pub fn delete_many(
                    bucket: &Bucket,
                    keys: &[_rt::String],
                ) -> Result<(), Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec1 = keys;
                        let len1 = vec1.len();
                        let layout1 = _rt::alloc::Layout::from_size_align(
                                vec1.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            )
                            .unwrap();
                        let (result1, _cleanup1) = wit_bindgen::rt::Cleanup::new(
                            layout1,
                        );
                        for (i, e) in vec1.into_iter().enumerate() {
                            let base = result1
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            {
                                let vec0 = e;
                                let ptr0 = vec0.as_ptr().cast::<u8>();
                                let len0 = vec0.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len0;
                                *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                            }
                        }
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import3((bucket).handle() as i32, result1, len1, ptr2);
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result10 = match l4 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(
                                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    use super::super::super::wasi::keyvalue::store::Error as V9;
                                    let v9 = match l5 {
                                        0 => V9::NoSuchStore,
                                        1 => V9::AccessDenied,
                                        n => {
                                            if true {
                                                match (&n, &2) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e9 = {
                                                let l6 = *ptr2
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l7 = *ptr2
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len8 = l7;
                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                    l6.cast(),
                                                    len8,
                                                    len8,
                                                );
                                                _rt::string_lift(bytes8)
                                            };
                                            V9::Other(e9)
                                        }
                                    };
                                    v9
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
        }
    }
    #[allow(dead_code, clippy::all)]
    pub mod exports {
        pub mod wasi {
            pub mod keyvalue {
                /// A keyvalue interface that provides watch operations.
                ///
                /// This interface is used to provide event-driven mechanisms to handle
                /// keyvalue changes.
                #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
                pub mod watcher {
                    #[used]
                    #[doc(hidden)]
                    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                    use super::super::super::super::_rt;
                    pub type Bucket = super::super::super::super::wasi::keyvalue::store::Bucket;
                    #[doc(hidden)]
                    #[allow(non_snake_case, unused_unsafe)]
                    pub unsafe fn _export_on_set_cabi<T: Guest>(
                        arg0: i32,
                        arg1: *mut u8,
                        arg2: usize,
                        arg3: *mut u8,
                        arg4: usize,
                    ) {
                        unsafe {
                            {
                                let len0 = arg2;
                                let bytes0 = _rt::Vec::from_raw_parts(
                                    arg1.cast(),
                                    len0,
                                    len0,
                                );
                                let len1 = arg4;
                                T::on_set(
                                    super::super::super::super::wasi::keyvalue::store::Bucket::from_handle(
                                        arg0 as u32,
                                    ),
                                    _rt::string_lift(bytes0),
                                    _rt::Vec::from_raw_parts(arg3.cast(), len1, len1),
                                )
                            };
                        }
                    }
                    #[doc(hidden)]
                    #[allow(non_snake_case, unused_unsafe)]
                    pub unsafe fn _export_on_delete_cabi<T: Guest>(
                        arg0: i32,
                        arg1: *mut u8,
                        arg2: usize,
                    ) {
                        unsafe {
                            {
                                let len0 = arg2;
                                let bytes0 = _rt::Vec::from_raw_parts(
                                    arg1.cast(),
                                    len0,
                                    len0,
                                );
                                T::on_delete(
                                    super::super::super::super::wasi::keyvalue::store::Bucket::from_handle(
                                        arg0 as u32,
                                    ),
                                    _rt::string_lift(bytes0),
                                )
                            };
                        }
                    }
                    pub trait Guest {
                        /// Handle the `set` event for the given bucket and key. It includes a reference to the `bucket`
                        /// that can be used to interact with the store.
                        #[allow(async_fn_in_trait)]
                        fn on_set(
                            bucket: Bucket,
                            key: _rt::String,
                            value: _rt::Vec<u8>,
                        ) -> ();
                        /// Handle the `delete` event for the given bucket and key. It includes a reference to the
                        /// `bucket` that can be used to interact with the store.
                        #[allow(async_fn_in_trait)]
                        fn on_delete(bucket: Bucket, key: _rt::String) -> ();
                    }
                    #[doc(hidden)]
                    pub use __export_wasi_keyvalue_watcher_0_2_0_draft2_cabi;
                }
            }
        }
    }
    mod _rt {
        #![allow(dead_code, clippy::all)]
        pub use alloc_crate::string::String;
        pub use alloc_crate::vec::Vec;
        use core::fmt;
        use core::marker;
        use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
        /// A type which represents a component model resource, either imported or
        /// exported into this component.
        ///
        /// This is a low-level wrapper which handles the lifetime of the resource
        /// (namely this has a destructor). The `T` provided defines the component model
        /// intrinsics that this wrapper uses.
        ///
        /// One of the chief purposes of this type is to provide `Deref` implementations
        /// to access the underlying data when it is owned.
        ///
        /// This type is primarily used in generated code for exported and imported
        /// resources.
        #[repr(transparent)]
        pub struct Resource<T: WasmResource> {
            handle: AtomicU32,
            _marker: marker::PhantomData<T>,
        }
        /// A trait which all wasm resources implement, namely providing the ability to
        /// drop a resource.
        ///
        /// This generally is implemented by generated code, not user-facing code.
        #[allow(clippy::missing_safety_doc)]
        pub unsafe trait WasmResource {
            /// Invokes the `[resource-drop]...` intrinsic.
            unsafe fn drop(handle: u32);
        }
        impl<T: WasmResource> Resource<T> {
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
                if true {
                    if !(handle != 0 && handle != u32::MAX) {
                        ::core::panicking::panic(
                            "assertion failed: handle != 0 && handle != u32::MAX",
                        )
                    }
                }
                Self {
                    handle: AtomicU32::new(handle),
                    _marker: marker::PhantomData,
                }
            }
            /// Takes ownership of the handle owned by `resource`.
            ///
            /// Note that this ideally would be `into_handle` taking `Resource<T>` by
            /// ownership. The code generator does not enable that in all situations,
            /// unfortunately, so this is provided instead.
            ///
            /// Also note that `take_handle` is in theory only ever called on values
            /// owned by a generated function. For example a generated function might
            /// take `Resource<T>` as an argument but then call `take_handle` on a
            /// reference to that argument. In that sense the dynamic nature of
            /// `take_handle` should only be exposed internally to generated code, not
            /// to user code.
            #[doc(hidden)]
            pub fn take_handle(resource: &Resource<T>) -> u32 {
                resource.handle.swap(u32::MAX, Relaxed)
            }
            #[doc(hidden)]
            pub fn handle(resource: &Resource<T>) -> u32 {
                resource.handle.load(Relaxed)
            }
        }
        impl<T: WasmResource> fmt::Debug for Resource<T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("Resource").field("handle", &self.handle).finish()
            }
        }
        impl<T: WasmResource> Drop for Resource<T> {
            fn drop(&mut self) {
                unsafe {
                    match self.handle.load(Relaxed) {
                        u32::MAX => {}
                        other => T::drop(other),
                    }
                }
            }
        }
        pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
            if true {
                String::from_utf8(bytes).unwrap()
            } else {
                unsafe { String::from_utf8_unchecked(bytes) }
            }
        }
        pub unsafe fn invalid_enum_discriminant<T>() -> T {
            if true {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid enum discriminant"),
                    );
                }
            } else {
                unsafe { core::hint::unreachable_unchecked() }
            }
        }
        pub unsafe fn bool_lift(val: u8) -> bool {
            if true {
                match val {
                    0 => false,
                    1 => true,
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!("invalid bool discriminant"),
                        );
                    }
                }
            } else {
                val != 0
            }
        }
        pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
            if size == 0 {
                return;
            }
            unsafe {
                let layout = alloc::Layout::from_size_align_unchecked(size, align);
                alloc::dealloc(ptr, layout);
            }
        }
        pub fn as_i64<T: AsI64>(t: T) -> i64 {
            t.as_i64()
        }
        pub trait AsI64 {
            fn as_i64(self) -> i64;
        }
        impl<'a, T: Copy + AsI64> AsI64 for &'a T {
            fn as_i64(self) -> i64 {
                (*self).as_i64()
            }
        }
        impl AsI64 for i64 {
            #[inline]
            fn as_i64(self) -> i64 {
                self as i64
            }
        }
        impl AsI64 for u64 {
            #[inline]
            fn as_i64(self) -> i64 {
                self as i64
            }
        }
        pub use alloc_crate::alloc;
        extern crate alloc as alloc_crate;
    }
    #[doc(inline)]
    pub use __export_keyvalue_impl as export;
    #[inline(never)]
    #[doc(hidden)]
    pub fn __link_custom_section_describing_imports() {
        wit_bindgen::rt::maybe_link_cabi_realloc();
    }
    const _: &[u8] = b"// wasi-cloud Blobstore service definition\ninterface blobstore {\n  use container.{container};\n  use types.{error, container-name, object-id};\n\n  // creates a new empty container\n  create-container: func(name: container-name) -> result<container, error>;\n\n  // retrieves a container by name\n  get-container: func(name: container-name) -> result<container, error>;\n\n  // deletes a container and all objects within it\n  delete-container: func(name: container-name) -> result<_, error>;\n\n  // returns true if the container exists\n  container-exists: func(name: container-name) -> result<bool, error>;\n\n  // copies (duplicates) an object, to the same or a different container.\n  // returns an error if the target container does not exist.\n  // overwrites destination object if it already existed.\n  copy-object: func(src: object-id, dest: object-id) -> result<_, error>;\n\n  // moves or renames an object, to the same or a different container\n  // returns an error if the destination container does not exist.\n  // overwrites destination object if it already existed.\n  move-object: func(src:object-id, dest: object-id) -> result<_, error>;\n}";
    const _: &[u8] = b"interface vault {\n    /// An error type that encapsulates the different errors that can occur fetching secrets\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// Open the specified locker.\n    /// \n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(locker-id: string) -> result<locker, error>;\n\n    /// A locker contains collection of related secrets.\n    resource locker {\n        /// Get the specified secret.\n        ///\n        /// Returns `none` if the specified secret does not exist.\n        get: func(secret-id: string) -> result<option<list<u8>>, error>;\n\n        /// Store a secret in the vault. If the `id` already exists, the\n        /// secret will be overwritten.\n        set: func(secret-id: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the specified secret.\n        /// \n        /// Will do nothing if the secret does not exist.\n        delete: func(secret-id: string) -> result<_, error>;\n\n        /// Check if the specified secret exists.\n        exists: func(secret-id: string) -> result<bool, error>;\n\n        /// List all `secret-id`s in the locker.\n        list-ids: func() -> result<list<string>, error>;\n    }\n}";
    const _: &[u8] = b"// a Container is a collection of objects\ninterface container {\n  use wasi:io/streams@0.2.6.{\n    input-stream,\n    output-stream,\n  };\n\n  use types.{\n    container-metadata,\n    error,\n    incoming-value,\n    object-metadata,\n    object-name,\n    outgoing-value,\n  };\n\n  // this defines the `container` resource\n  resource container {\n    // returns container name\n    name: func() -> result<string, error>;\n\n    // returns container metadata\n    info: func() -> result<container-metadata, error>;\n\n    // retrieves an object or portion of an object, as a resource.\n    // Start and end offsets are inclusive.\n    // Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime\n    // of the data-blob resource, even if the object they came from is later deleted.\n    get-data: func(name: object-name, start: u64, end: u64) -> result<incoming-value, error>;\n\n    // creates or replaces an object with the data blob.\n    write-data: func(name: object-name, data: borrow<outgoing-value>) -> result<_, error>;\n\n    // returns list of objects in the container. Order is undefined.\n    list-objects: func() -> result<stream-object-names, error>;\n\n    // deletes object.\n    // does not return error if object did not exist.\n    delete-object: func(name: object-name) -> result<_, error>;\n\n    // deletes multiple objects in the container\n    delete-objects: func(names: list<object-name>) -> result<_, error>;\n\n    // returns true if the object exists in this container\n    has-object: func(name: object-name) -> result<bool, error>;\n\n    // returns metadata for the object\n    object-info: func(name: object-name) -> result<object-metadata, error>;\n\n    // removes all objects within the container, leaving the container empty.\n    clear: func() -> result<_, error>;\n  }\n\n  // this defines the `stream-object-names` resource which is a representation of stream<object-name>\n  resource stream-object-names {\n    // reads the next number of objects from the stream\n    //\n    // This function returns the list of objects read, and a boolean indicating if the end of the stream was reached.\n    read-stream-object-names: func(len: u64) -> result<tuple<list<object-name>, bool>, error>;\n\n    // skip the next number of objects in the stream\n    //\n    // This function returns the number of objects skipped, and a boolean indicating if the end of the stream was reached.\n    skip-stream-object-names: func(num: u64) -> result<tuple<u64, bool>, error>;\n  }\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import streams;\n\n    @since(version = 0.2.0)\n    import poll;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides batch operations.\n/// \n/// A batch operation is an operation that operates on multiple keys at once.\n/// \n/// Batch operations are useful for reducing network round-trip time. For example, if you want to\n/// get the values associated with 100 keys, you can either do 100 get operations or you can do 1\n/// batch get operation. The batch operation is faster because it only needs to make 1 network call\n/// instead of 100.\n/// \n/// A batch operation does not guarantee atomicity, meaning that if the batch operation fails, some\n/// of the keys may have been modified and some may not. \n/// \n/// This interface does has the same consistency guarantees as the `store` interface, meaning that\n/// you should be able to \"read your writes.\"\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface batch {\n    use store.{bucket, error};\n\n    /// Get the key-value pairs associated with the keys in the store. It returns a list of\n    /// key-value pairs.\n    ///\n    /// If any of the keys do not exist in the store, it returns a `none` value for that pair in the\n    /// list.\n    /// \n    /// MAY show an out-of-date value if there are concurrent writes to the store.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`.\n    get-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<list<option<tuple<string, list<u8>>>>, error>;\n\n    /// Set the values associated with the keys in the store. If the key already exists in the\n    /// store, it overwrites the value. \n    /// \n    /// Note that the key-value pairs are not guaranteed to be set in the order they are provided. \n    ///\n    /// If any of the keys do not exist in the store, it creates a new key-value pair.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already set. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be set while others might\n    /// fail. \n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    set-many: func(bucket: borrow<bucket>, key-values: list<tuple<string, list<u8>>>) -> result<_, error>;\n\n    /// Delete the key-value pairs associated with the keys in the store.\n    /// \n    /// Note that the key-value pairs are not guaranteed to be deleted in the order they are\n    /// provided.\n    /// \n    /// If any of the keys do not exist in the store, it skips the key.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already deleted. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be deleted while others might\n    /// fail.\n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    delete-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<_, error>;\n}\n";
    const _: &[u8] = b"package wasi:otel@0.2.0-draft;\n\nworld imports {\n    import tracing;\n    import metrics;\n    import %resource;\n}\n";
    const _: &[u8] = b"interface tracing {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, error};\n\n    /// Returns the current span context of the host.\n    context: func() -> span-context;\n\n    /// Called by the guest to export spans.\n    %export: func(span: list<span-data>) -> result<_, error>;\n\n    /// The data associated with a span.\n    record span-data {\n        /// Span context.\n        span-context: span-context,\n        /// Span parent id.\n        parent-span-id: string,\n        /// Span kind.\n        span-kind: span-kind,\n        // Span name.\n        name: string,\n        /// Span start time.\n        start-time: datetime,\n        /// Span end time.\n        end-time: datetime,\n        /// Span attributes.\n        attributes: list<key-value>,\n        /// Span events.\n        events: list<event>,\n        /// Span Links.\n        links: list<link>,\n        /// Span status.\n        status: status,\n        /// Instrumentation scope that produced this span.\n        instrumentation-scope: instrumentation-scope,\n        /// Number of attributes dropped by the span due to limits being reached.\n        dropped-attributes: u32,\n        /// Number of events dropped by the span due to limits being reached.\n        dropped-events: u32,\n        /// Number of links dropped by the span due to limits being reached.\n        dropped-links: u32,\n    }\n\n    /// Identifying trace information about a span that can be serialized and propagated.\n    record span-context {\n        /// The `trace-id` for this `span-context`.\n        trace-id: trace-id,\n        /// The `span-id` for this `span-context`.\n        span-id: span-id,\n        /// The `trace-flags` for this `span-context`.\n        trace-flags: trace-flags,\n        /// Whether this `span-context` was propagated from a remote parent.\n        is-remote: bool,\n        /// The `trace-state` for this `span-context`.\n        trace-state: trace-state,\n    }\n\n    /// The trace that this `span-context` belongs to.\n    ///\n    /// 16 bytes encoded as a hexadecimal string.\n    type trace-id = string;\n\n    /// The id of this `span-context`.\n    ///\n    /// 8 bytes encoded as a hexadecimal string.\n    type span-id = string;\n\n    /// Flags that can be set on a `span-context`.\n    flags trace-flags {\n        /// Whether the `span` should be sampled or not.\n        sampled,\n    }\n\n    /// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.\n    ///\n    /// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.\n    type trace-state = list<tuple<string, string>>;\n\n    /// Describes the relationship between the Span, its parents, and its children in a trace.\n    enum span-kind {\n        /// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.\n        client,\n        /// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.\n        server,\n        /// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.\n        producer,\n        /// Indicates that the span describes a child of an asynchronous consumer request.\n        consumer,\n        /// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.\n        internal\n    }\n\n    /// An event describing a specific moment in time on a span and associated attributes.\n    record event {\n        /// Event name.\n        name: string,\n        /// Event time.\n        time: datetime,\n        /// Event attributes.\n        attributes: list<key-value>,\n    }\n\n    /// Describes a relationship to another `span`.\n    record link {\n        /// Denotes which `span` to link to.\n        span-context: span-context,\n        /// Attributes describing the link.\n        attributes: list<key-value>,\n    }\n\n    /// The `status` of a `span`.\n    variant status {\n        /// The default status.\n        unset,\n        /// The operation has been validated by an Application developer or Operator to have completed successfully.\n        ok,\n        /// The operation contains an error with a description.\n        error(string),\n    }\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@unstable(feature = clocks-timezone)\ninterface timezone {\n    @unstable(feature = clocks-timezone)\n    use wall-clock.{datetime};\n\n    /// Return information needed to display the given `datetime`. This includes\n    /// the UTC offset, the time zone name, and a flag indicating whether\n    /// daylight saving time is active.\n    ///\n    /// If the timezone cannot be determined for the given `datetime`, return a\n    /// `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight\n    /// saving time.\n    @unstable(feature = clocks-timezone)\n    display: func(when: datetime) -> timezone-display;\n\n    /// The same as `display`, but only return the UTC offset.\n    @unstable(feature = clocks-timezone)\n    utc-offset: func(when: datetime) -> s32;\n\n    /// Information useful for displaying the timezone of a specific `datetime`.\n    ///\n    /// This information may vary within a single `timezone` to reflect daylight\n    /// saving time adjustments.\n    @unstable(feature = clocks-timezone)\n    record timezone-display {\n        /// The number of seconds difference between UTC time and the local\n        /// time of the timezone.\n        ///\n        /// The returned value will always be less than 86400 which is the\n        /// number of seconds in a day (24*60*60).\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return 0.\n        utc-offset: s32,\n\n        /// The abbreviated name of the timezone to display to a user. The name\n        /// `UTC` indicates Coordinated Universal Time. Otherwise, this should\n        /// reference local standards for the name of the time zone.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should be the string `UTC`.\n        ///\n        /// In time zones that do not have an applicable name, a formatted\n        /// representation of the UTC offset may be returned, such as `-04:00`.\n        name: string,\n\n        /// Whether daylight saving time is active.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return false.\n        in-daylight-saving-time: bool,\n    }\n}\n";
    const _: &[u8] = b"/// The producer interface is used to send messages to a channel/topic.\ninterface producer {\n    use types.{client, message, error, topic};\n\n    /// Sends the message using the given client.\n    send: async func(c: client, topic: topic, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides eventually consistent key-value operations.\n/// \n/// Each of these operations acts on a single key-value pair.\n/// \n/// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is\n/// the common denominator for all data types defined by different key-value stores to handle data,\n/// ensuring compatibility between different key-value stores. Note: the clients will be expecting\n/// serialization/deserialization overhead to be handled by the key-value store. The value could be\n/// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.\n/// \n/// Data consistency in a key value store refers to the guarantee that once a write operation\n/// completes, all subsequent read operations will return the value that was written.\n/// \n/// Any implementation of this interface must have enough consistency to guarantee \"reading your\n/// writes.\" In particular, this means that the client should never get a value that is older than\n/// the one it wrote, but it MAY get a newer value if one was written around the same time. These\n/// guarantees only apply to the same client (which will likely be provided by the host or an\n/// external capability of some kind). In this context a \"client\" is referring to the caller or\n/// guest that is consuming this interface. Once a write request is committed by a specific client,\n/// all subsequent read requests by the same client will reflect that write or any subsequent\n/// writes. Another client running in a different context may or may not immediately see the result\n/// due to the replication lag. As an example of all of this, if a value at a given key is A, and\n/// the client writes B, then immediately reads, it should get B. If something else writes C in\n/// quick succession, then the client may get C. However, a client running in a separate context may\n/// still see A or B\ninterface store {\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// A response to a `list-keys` operation.\n    record key-response {\n        /// The list of keys returned by the query.\n        keys: list<string>,\n        /// The continuation token to use to fetch the next page of keys. If this is `null`, then\n        /// there are no more keys to fetch.\n        cursor: option<string>\n    }\n\n    /// Get the bucket with the specified identifier.\n    ///\n    /// `identifier` must refer to a bucket provided by the host.\n    ///\n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(identifier: string) -> result<bucket, error>;\n\n    /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the\n    /// bucket, and the bucket itself acts as a collection of all these entries.\n    ///\n    /// It is worth noting that the exact terminology for bucket in key-value stores can very\n    /// depending on the specific implementation. For example:\n    ///\n    /// 1. Amazon DynamoDB calls a collection of key-value pairs a table\n    /// 2. Redis has hashes, sets, and sorted sets as different types of collections\n    /// 3. Cassandra calls a collection of key-value pairs a column family\n    /// 4. MongoDB calls a collection of key-value pairs a collection\n    /// 5. Riak calls a collection of key-value pairs a bucket\n    /// 6. Memcached calls a collection of key-value pairs a slab\n    /// 7. Azure Cosmos DB calls a collection of key-value pairs a container\n    ///\n    /// In this interface, we use the term `bucket` to refer to a collection of key-value pairs\n    resource bucket {\n        /// Get the value associated with the specified `key`\n        ///\n        /// The value is returned as an option. If the key-value pair exists in the\n        /// store, it returns `Ok(value)`. If the key does not exist in the\n        /// store, it returns `Ok(none)`. \n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        get: func(key: string) -> result<option<list<u8>>, error>;\n\n        /// Set the value associated with the key in the store. If the key already\n        /// exists in the store, it overwrites the value.\n        ///\n        /// If the key does not exist in the store, it creates a new key-value pair.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        set: func(key: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the key-value pair associated with the key in the store.\n        /// \n        /// If the key does not exist in the store, it does nothing.\n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        delete: func(key: string) -> result<_, error>;\n\n        /// Check if the key exists in the store.\n        /// \n        /// If the key exists in the store, it returns `Ok(true)`. If the key does\n        /// not exist in the store, it returns `Ok(false)`.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        exists: func(key: string) -> result<bool, error>;\n\n        /// Get all the keys in the store with an optional cursor (for use in pagination). It\n        /// returns a list of keys. Please note that for most KeyValue implementations, this is a\n        /// can be a very expensive operation and so it should be used judiciously. Implementations\n        /// can return any number of keys in a single response, but they should never attempt to\n        /// send more data than is reasonable (i.e. on a small edge device, this may only be a few\n        /// KB, while on a large machine this could be several MB). Any response should also return\n        /// a cursor that can be used to fetch the next page of keys. See the `key-response` record\n        /// for more information.\n        /// \n        /// Note that the keys are not guaranteed to be returned in any particular order.\n        /// \n        /// If the store is empty, it returns an empty list.\n        /// \n        /// MAY show an out-of-date list of keys if there are concurrent writes to the store.\n        /// \n        /// If any error occurs, it returns an `Err(error)`.\n        list-keys: func(cursor: option<string>) -> result<key-response, error>;\n    }\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\ninterface error {\n    /// A resource which represents some error information.\n    ///\n    /// The only method provided by this resource is `to-debug-string`,\n    /// which provides some human-readable information about the error.\n    ///\n    /// In the `wasi:io` package, this resource is returned through the\n    /// `wasi:io/streams/stream-error` type.\n    ///\n    /// To provide more specific error information, other interfaces may\n    /// offer functions to \"downcast\" this error into more specific types. For example,\n    /// errors returned from streams derived from filesystem types can be described using\n    /// the filesystem\'s own error-code type. This is done using the function\n    /// `wasi:filesystem/types/filesystem-error-code`, which takes a `borrow<error>`\n    /// parameter and returns an `option<wasi:filesystem/types/error-code>`.\n    ///\n    /// The set of functions which can \"downcast\" an `error` into a more\n    /// concrete type is open.\n    @since(version = 0.2.0)\n    resource error {\n        /// Returns a string that is suitable to assist humans in debugging\n        /// this error.\n        ///\n        /// WARNING: The returned string should not be consumed mechanically!\n        /// It may change across platforms, hosts, or other implementation\n        /// details. Parsing this string is a major platform-compatibility\n        /// hazard.\n        @since(version = 0.2.0)\n        to-debug-string: func() -> string;\n    }\n}\n";
    const _: &[u8] = b"/// The request-reply interface allows a guest to send a message and await a response. This\n/// interface is considered optional as not all message services support the concept of\n/// request/reply. However, request/reply is a very common pattern in messaging and as such, we have\n/// included it as a core interface.\ninterface request-reply {\n    use types.{client, message, error, topic};\n\n    /// Options for a request/reply operation. This is a resource to allow for future expansion of\n    /// options.\n    resource request-options {\n        /// Creates a new request options resource with no options set.\n        constructor();\n\n        /// The maximum amount of time to wait for a response. If the timeout value is not set, then\n        /// the request/reply operation will block until a message is received in response.\n        set-timeout-ms: func(timeout-ms: u32);\n\n        /// The maximum number of replies to expect before returning.\n        set-expected-replies: func(expected-replies: u32);\n    }\n\n    /// Performs a blocking request/reply operation with an optional set of request options. \n    /// \n    /// The behavior of this function is largely dependent on the options given to the function.\n    /// If no options are provided, then the request/reply operation will block until a single \n    /// message is received in response. If a timeout is provided, then the request/reply operation\n    /// will block for the specified amount of time before returning an error if no messages were\n    /// received (or the list of messages that were received). If both a timeout and an expected\n    /// number of replies are provided, the function should return when either condition is met\n    /// (whichever comes first)\xe2\x80\x94e.g., (1) if no replies were received within the timeout return an\n    /// error, (2) if the maximum expected number of replies were received before timeout, return\n    /// the list of messages, or (3) if the timeout is reached before the expected number of replies,\n    /// return the list of messages received up to that point.\n    request: func(c: borrow<client>, topic: topic, message: borrow<message>, options: option<request-options>) -> result<list<message>, error>;\n\n    /// Replies to the given message with the given response message. The details of which topic\n    /// the message is sent to is up to the implementation. This allows for reply-to details to be\n    /// handled in the best way possible for the underlying messaging system.\n    /// \n    /// Please note that this reply functionality is different than something like HTTP because there\n    /// are several use cases in which a reply might not be required for every message (so this would\n    /// be a noop). There are also cases when you might want to reply and then continue processing.\n    /// Additionally, you might want to reply to a message several times (such as providing an\n    /// update). So this function is allowed to be called multiple times, unlike something like HTTP\n    /// where the reply is sent and the connection is closed.\n    reply: func(reply-to: borrow<message>, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Monotonic Clock is a clock API intended to let users measure elapsed\n/// time.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A monotonic clock is a clock which has an unspecified initial value, and\n/// successive reads of the clock will produce non-decreasing values.\n@since(version = 0.2.0)\ninterface monotonic-clock {\n    @since(version = 0.2.0)\n    use wasi:io/poll@0.2.6.{pollable};\n\n    /// An instant in time, in nanoseconds. An instant is relative to an\n    /// unspecified initial value, and can only be compared to instances from\n    /// the same monotonic-clock.\n    @since(version = 0.2.0)\n    type instant = u64;\n\n    /// A duration of time, in nanoseconds.\n    @since(version = 0.2.0)\n    type duration = u64;\n\n    /// Read the current value of the clock.\n    ///\n    /// The clock is monotonic, therefore calling this function repeatedly will\n    /// produce a sequence of non-decreasing values.\n    @since(version = 0.2.0)\n    now: func() -> instant;\n\n    /// Query the resolution of the clock. Returns the duration of time\n    /// corresponding to a clock tick.\n    @since(version = 0.2.0)\n    resolution: func() -> duration;\n\n    /// Create a `pollable` which will resolve once the specified instant\n    /// has occurred.\n    @since(version = 0.2.0)\n    subscribe-instant: func(\n        when: instant,\n    ) -> pollable;\n\n    /// Create a `pollable` that will resolve after the specified duration has\n    /// elapsed from the time this function is invoked.\n    @since(version = 0.2.0)\n    subscribe-duration: func(\n        when: duration,\n    ) -> pollable;\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// WASI I/O is an I/O abstraction API which is currently focused on providing\n/// stream types.\n///\n/// In the future, the component model is expected to add built-in stream types;\n/// when it does, they are expected to subsume this API.\n@since(version = 0.2.0)\ninterface streams {\n    @since(version = 0.2.0)\n    use error.{error};\n    @since(version = 0.2.0)\n    use poll.{pollable};\n\n    /// An error for input-stream and output-stream operations.\n    @since(version = 0.2.0)\n    variant stream-error {\n        /// The last operation (a write or flush) failed before completion.\n        ///\n        /// More information is available in the `error` payload.\n        ///\n        /// After this, the stream will be closed. All future operations return\n        /// `stream-error::closed`.\n        last-operation-failed(error),\n        /// The stream is closed: no more input will be accepted by the\n        /// stream. A closed output-stream will return this error on all\n        /// future operations.\n        closed\n    }\n\n    /// An input bytestream.\n    ///\n    /// `input-stream`s are *non-blocking* to the extent practical on underlying\n    /// platforms. I/O operations always return promptly; if fewer bytes are\n    /// promptly available than requested, they return the number of bytes promptly\n    /// available, which could even be zero. To wait for data to be available,\n    /// use the `subscribe` function to obtain a `pollable` which can be polled\n    /// for using `wasi:io/poll`.\n    @since(version = 0.2.0)\n    resource input-stream {\n        /// Perform a non-blocking read from the stream.\n        ///\n        /// When the source of a `read` is binary data, the bytes from the source\n        /// are returned verbatim. When the source of a `read` is known to the\n        /// implementation to be text, bytes containing the UTF-8 encoding of the\n        /// text are returned.\n        ///\n        /// This function returns a list of bytes containing the read data,\n        /// when successful. The returned list will contain up to `len` bytes;\n        /// it may return fewer than requested, but not more. The list is\n        /// empty when no bytes are available for reading at this time. The\n        /// pollable given by `subscribe` will be ready when more bytes are\n        /// available.\n        ///\n        /// This function fails with a `stream-error` when the operation\n        /// encounters an error, giving `last-operation-failed`, or when the\n        /// stream is closed, giving `closed`.\n        ///\n        /// When the caller gives a `len` of 0, it represents a request to\n        /// read 0 bytes. If the stream is still open, this call should\n        /// succeed and return an empty list, or otherwise fail with `closed`.\n        ///\n        /// The `len` parameter is a `u64`, which could represent a list of u8 which\n        /// is not possible to allocate in wasm32, or not desirable to allocate as\n        /// as a return value by the callee. The callee may return a list of bytes\n        /// less than `len` in size while more bytes are available for reading.\n        @since(version = 0.2.0)\n        read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Read bytes from a stream, after blocking until at least one byte can\n        /// be read. Except for blocking, behavior is identical to `read`.\n        @since(version = 0.2.0)\n        blocking-read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Skip bytes from a stream. Returns number of bytes skipped.\n        ///\n        /// Behaves identical to `read`, except instead of returning a list\n        /// of bytes, returns the number of bytes consumed from the stream.\n        @since(version = 0.2.0)\n        skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Skip bytes from a stream, after blocking until at least one byte\n        /// can be skipped. Except for blocking behavior, identical to `skip`.\n        @since(version = 0.2.0)\n        blocking-skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Create a `pollable` which will resolve once either the specified stream\n        /// has bytes available to read or the other end of the stream has been\n        /// closed.\n        /// The created `pollable` is a child resource of the `input-stream`.\n        /// Implementations may trap if the `input-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n    }\n\n\n    /// An output bytestream.\n    ///\n    /// `output-stream`s are *non-blocking* to the extent practical on\n    /// underlying platforms. Except where specified otherwise, I/O operations also\n    /// always return promptly, after the number of bytes that can be written\n    /// promptly, which could even be zero. To wait for the stream to be ready to\n    /// accept data, the `subscribe` function to obtain a `pollable` which can be\n    /// polled for using `wasi:io/poll`.\n    ///\n    /// Dropping an `output-stream` while there\'s still an active write in\n    /// progress may result in the data being lost. Before dropping the stream,\n    /// be sure to fully flush your writes.\n    @since(version = 0.2.0)\n    resource output-stream {\n        /// Check readiness for writing. This function never blocks.\n        ///\n        /// Returns the number of bytes permitted for the next call to `write`,\n        /// or an error. Calling `write` with more bytes than this function has\n        /// permitted will trap.\n        ///\n        /// When this function returns 0 bytes, the `subscribe` pollable will\n        /// become ready when this function will report at least 1 byte, or an\n        /// error.\n        @since(version = 0.2.0)\n        check-write: func() -> result<u64, stream-error>;\n\n        /// Perform a write. This function never blocks.\n        ///\n        /// When the destination of a `write` is binary data, the bytes from\n        /// `contents` are written verbatim. When the destination of a `write` is\n        /// known to the implementation to be text, the bytes of `contents` are\n        /// transcoded from UTF-8 into the encoding of the destination and then\n        /// written.\n        ///\n        /// Precondition: check-write gave permit of Ok(n) and contents has a\n        /// length of less than or equal to n. Otherwise, this function will trap.\n        ///\n        /// returns Err(closed) without writing if the stream has closed since\n        /// the last call to check-write provided a permit.\n        @since(version = 0.2.0)\n        write: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 bytes, and then flush the stream. Block\n        /// until all of these operations are complete, or an error occurs.\n        ///\n        /// Returns success when all of the contents written are successfully\n        /// flushed to output. If an error occurs at any point before all\n        /// contents are successfully flushed, that error is returned as soon as\n        /// possible. If writing and flushing the complete contents causes the\n        /// stream to become closed, this call should return success, and\n        /// subsequent calls to check-write or other interfaces should return\n        /// stream-error::closed.\n        @since(version = 0.2.0)\n        blocking-write-and-flush: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Request to flush buffered output. This function never blocks.\n        ///\n        /// This tells the output-stream that the caller intends any buffered\n        /// output to be flushed. the output which is expected to be flushed\n        /// is all that has been passed to `write` prior to this call.\n        ///\n        /// Upon calling this function, the `output-stream` will not accept any\n        /// writes (`check-write` will return `ok(0)`) until the flush has\n        /// completed. The `subscribe` pollable will become ready when the\n        /// flush has completed and the stream can accept more writes.\n        @since(version = 0.2.0)\n        flush: func() -> result<_, stream-error>;\n\n        /// Request to flush buffered output, and block until flush completes\n        /// and stream is ready for writing again.\n        @since(version = 0.2.0)\n        blocking-flush: func() -> result<_, stream-error>;\n\n        /// Create a `pollable` which will resolve once the output-stream\n        /// is ready for more writing, or an error has occurred. When this\n        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an\n        /// error.\n        ///\n        /// If the stream is closed, this pollable is always ready immediately.\n        ///\n        /// The created `pollable` is a child resource of the `output-stream`.\n        /// Implementations may trap if the `output-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n\n        /// Write zeroes to a stream.\n        ///\n        /// This should be used precisely like `write` with the exact same\n        /// preconditions (must use check-write first), but instead of\n        /// passing a list of bytes, you simply pass the number of zero-bytes\n        /// that should be written.\n        @since(version = 0.2.0)\n        write-zeroes: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 zeroes, and then flush the stream.\n        /// Block until all of these operations are complete, or an error\n        /// occurs.\n        ///\n        /// Functionality is equivelant to `blocking-write-and-flush` with\n        /// contents given as a list of len containing only zeroes.\n        @since(version = 0.2.0)\n        blocking-write-zeroes-and-flush: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Read from one stream and write to another.\n        ///\n        /// The behavior of splice is equivalent to:\n        /// 1. calling `check-write` on the `output-stream`\n        /// 2. calling `read` on the `input-stream` with the smaller of the\n        /// `check-write` permitted length and the `len` provided to `splice`\n        /// 3. calling `write` on the `output-stream` with that read data.\n        ///\n        /// Any error reported by the call to `check-write`, `read`, or\n        /// `write` ends the splice and reports that error.\n        ///\n        /// This function returns the number of bytes transferred; it may be less\n        /// than `len`.\n        @since(version = 0.2.0)\n        splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Read from one stream and write to another, with blocking.\n        ///\n        /// This is similar to `splice`, except that it blocks until the\n        /// `output-stream` is ready for writing, and the `input-stream`\n        /// is ready for reading, before performing the `splice`.\n        @since(version = 0.2.0)\n        blocking-splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n    }\n}\n";
    const _: &[u8] = b"interface types {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n\n    /// A key-value pair describing an attribute.\n    record key-value {\n        /// The attribute name.\n        key: key,\n        /// The attribute value.\n        value: value,\n    }\n\n    /// The key part of attribute `key-value` pairs.\n    type key = string;\n\n    /// The value part of attribute `key-value` pairs.\n    variant value {\n        /// A string value.\n        %string(string),\n        /// A boolean value.\n        %bool(bool),\n        /// A double precision floating point value.\n        %f64(f64),\n        /// A signed 64 bit integer value.\n        %s64(s64),\n        /// A homogeneous array of string values.\n        string-array(list<string>),\n        /// A homogeneous array of boolean values.\n        bool-array(list<bool>),\n        /// A homogeneous array of double precision floating point values.\n        f64-array(list<f64>),\n        /// A homogeneous array of 64 bit integer values.\n        s64-array(list<s64>),\n    }\n\n    /// The host resource describing the entity producing telemetry.\n    record %resource {\n        /// Specifies the resource attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n    }\n\n    /// Describes the instrumentation scope that produced a span.\n    record instrumentation-scope {\n        /// Name of the instrumentation scope.\n        name: string,\n\n        /// The library version.\n        version: option<string>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n\n        /// Specifies the instrumentation scope attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n    }\n\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// Shutdown has already been invoked.\n        already-shutdown,\n\n        /// Operation timed out before completing.\n        timeout(u64),\n\n        /// Operation failed due to an internal error.\n        internal-failure(string)\n    }\n}\n";
    const _: &[u8] = b"package wasi:vault@0.1.0-draft;\n\nworld imports {\n  import vault;\n}\n";
    const _: &[u8] = b"package wasi:keyvalue@0.2.0-draft2;\n\n/// The `wasi:keyvalue/imports` world provides common APIs for interacting with key-value stores.\n/// Components targeting this world will be able to do:\n/// \n/// 1. CRUD (create, read, update, delete) operations on key-value stores.\n/// 2. Atomic `increment` and CAS (compare-and-swap) operations.\n/// 3. Batch operations that can reduce the number of round trips to the network.\nworld imports {\n\t/// The `store` capability allows the component to perform eventually consistent operations on\n\t/// the key-value store.\n\timport store;\n\n\t/// The `atomic` capability allows the component to perform atomic / `increment` and CAS\n\t/// (compare-and-swap) operations.\n\timport atomics;\n\n\t/// The `batch` capability allows the component to perform eventually consistent batch\n\t/// operations that can reduce the number of round trips to the network.\n\timport batch;\n}\n\nworld watch-service {\n\tinclude imports;\n\texport watcher;\n}";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// A poll API intended to let users wait for I/O events on multiple handles\n/// at once.\n@since(version = 0.2.0)\ninterface poll {\n    /// `pollable` represents a single I/O event which may be ready, or not.\n    @since(version = 0.2.0)\n    resource pollable {\n\n        /// Return the readiness of a pollable. This function never blocks.\n        ///\n        /// Returns `true` when the pollable is ready, and `false` otherwise.\n        @since(version = 0.2.0)\n        ready: func() -> bool;\n\n        /// `block` returns immediately if the pollable is ready, and otherwise\n        /// blocks until ready.\n        ///\n        /// This function is equivalent to calling `poll.poll` on a list\n        /// containing only this pollable.\n        @since(version = 0.2.0)\n        block: func();\n    }\n\n    /// Poll for completion on a set of pollables.\n    ///\n    /// This function takes a list of pollables, which identify I/O sources of\n    /// interest, and waits until one or more of the events is ready for I/O.\n    ///\n    /// The result `list<u32>` contains one or more indices of handles in the\n    /// argument list that is ready for I/O.\n    ///\n    /// This function traps if either:\n    /// - the list is empty, or:\n    /// - the list contains more elements than can be indexed with a `u32` value.\n    ///\n    /// A timeout can be implemented by adding a pollable from the\n    /// wasi-clocks API to the list.\n    ///\n    /// This function does not return a `result`; polling in itself does not\n    /// do any I/O so it doesn\'t fail. If any of the I/O sources identified by\n    /// the pollables has an error, it is indicated by marking the source as\n    /// being ready for I/O.\n    @since(version = 0.2.0)\n    poll: func(in: list<borrow<pollable>>) -> list<u32>;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides atomic operations.\n/// \n/// Atomic operations are single, indivisible operations. When a fault causes an atomic operation to\n/// fail, it will appear to the invoker of the atomic operation that the action either completed\n/// successfully or did nothing at all.\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface atomics {\n  \tuse store.{bucket, error};\n\n\t/// The error returned by a CAS operation\n\tvariant cas-error {\n\t\t/// A store error occurred when performing the operation\n\t\tstore-error(error),\n\t\t/// The CAS operation failed because the value was too old. This returns a new CAS handle\n\t\t/// for easy retries. Implementors MUST return a CAS handle that has been updated to the\n\t\t/// latest version or transaction.\n\t\tcas-failed(cas),\n\t}\n\n\t/// A handle to a CAS (compare-and-swap) operation.\n\tresource cas {\n\t\t/// Construct a new CAS operation. Implementors can map the underlying functionality\n\t\t/// (transactions, versions, etc) as desired.\n\t\tnew: static func(bucket: borrow<bucket>, key: string) -> result<cas, error>;\n\t\t/// Get the current value of the key (if it exists). This allows for avoiding reads if all\n\t\t/// that is needed to ensure the atomicity of the operation\n\t\tcurrent: func() -> result<option<list<u8>>, error>;\n\t}\n\n  \t/// Atomically increment the value associated with the key in the store by the given delta. It\n\t/// returns the new value.\n\t///\n\t/// If the key does not exist in the store, it creates a new key-value pair with the value set\n\t/// to the given delta. \n\t///\n\t/// If any other error occurs, it returns an `Err(error)`.\n\tincrement: func(bucket: borrow<bucket>, key: string, delta: s64) -> result<s64, error>;\n\n\t/// Perform the swap on a CAS operation. This consumes the CAS handle and returns an error if\n\t/// the CAS operation failed.\n\tswap: func(cas: cas, value: list<u8>) -> result<_, cas-error>;\n}";
    const _: &[u8] = b"package wasi:blobstore@0.2.0-draft;\n\nworld imports {\n\timport blobstore;\n}\n";
    const _: &[u8] = b"interface %resource {\n    use types.{key, value, key-value, %resource as telemetry-resource};\n\n    /// Returns the telemetry resource used by the host.\n    %resource: func() -> telemetry-resource;\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Wall Clock is a clock API intended to let users query the current\n/// time. The name \"wall\" makes an analogy to a \"clock on the wall\", which\n/// is not necessarily monotonic as it may be reset.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A wall clock is a clock which measures the date and time according to\n/// some external reference.\n///\n/// External references may be reset, so this clock is not necessarily\n/// monotonic, making it unsuitable for measuring elapsed time.\n///\n/// It is intended for reporting the current date and time for humans.\n@since(version = 0.2.0)\ninterface wall-clock {\n    /// A time and date in seconds plus nanoseconds.\n    @since(version = 0.2.0)\n    record datetime {\n        seconds: u64,\n        nanoseconds: u32,\n    }\n\n    /// Read the current value of the clock.\n    ///\n    /// This clock is not monotonic, therefore calling this function repeatedly\n    /// will not necessarily produce a sequence of non-decreasing values.\n    ///\n    /// The returned timestamps represent the number of seconds since\n    /// 1970-01-01T00:00:00Z, also known as [POSIX\'s Seconds Since the Epoch],\n    /// also known as [Unix Time].\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    ///\n    /// [POSIX\'s Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16\n    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time\n    @since(version = 0.2.0)\n    now: func() -> datetime;\n\n    /// Query the resolution of the clock.\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    @since(version = 0.2.0)\n    resolution: func() -> datetime;\n}\n";
    const _: &[u8] = b"interface readwrite {\n    use types.{statement, row, error, connection};\n    \n    /// query is optimized for querying data, and \n    /// implementors can make use of that fact to optimize \n    /// the performance of query execution (e.g., using\n    /// indexes).\n    query: func(c: borrow<connection>, q: borrow<statement>) -> result<list<row>, error>;\n    \n    /// exec is for modifying data in the database.\n    exec: func(c: borrow<connection>, q: borrow<statement>) -> result<u32, error>;\n}";
    const _: &[u8] = b"/// A keyvalue interface that provides watch operations.\n/// \n/// This interface is used to provide event-driven mechanisms to handle\n/// keyvalue changes.\ninterface watcher {\n\t/// A keyvalue interface that provides handle-watch operations.\n\tuse store.{bucket};\n\n\t/// Handle the `set` event for the given bucket and key. It includes a reference to the `bucket`\n\t/// that can be used to interact with the store.\n\ton-set: func(bucket: bucket, key: string, value: list<u8>);\n\n\t/// Handle the `delete` event for the given bucket and key. It includes a reference to the\n\t/// `bucket` that can be used to interact with the store.\n\ton-delete: func(bucket: bucket, key: string);\n}";
    const _: &[u8] = b"interface types {\n    /// one single row item\n    record row {\n        field-name: string,\n        value: data-type,\n    }\n    \n    /// common data types\n    variant data-type {\n        int32(s32),\n        int64(s64),\n        uint32(u32),\n        uint64(u64),\n        float(f64),\n        double(f64),\n        str(string),\n        boolean(bool),\n        date(string),\n        time(string),\n        timestamp(string),\n        binary(list<u8>),\n        null\n    }\n\n    /// allows parameterized queries\n    /// e.g., prepare(\"SELECT * FROM users WHERE name = ? AND age = ?\", vec![\"John Doe\", \"32\"])\n    resource statement {\n        prepare: static func(query: string, params: list<string>) -> result<statement, error>;\n    }\n    /// An error resource type.\n    /// Currently, this provides only one function to return a string representation\n    /// of the error. In the future, this will be extended to provide more information.\n    resource error {\n\t\ttrace: func() -> string;\n  \t}\n    \n    /// A connection to a sql store.\n    resource connection {\n        open: static func(name: string) -> result<connection, error>;\n    }\n}";
    const _: &[u8] = b"interface incoming-handler {\n    use types.{message, error, topic};\n\n    /// Whenever this guest receives a message in one of the subscribed topics, the message is\n    /// sent to this handler. The guest is responsible for matching on the topic and handling the\n    /// message accordingly. Implementors (such as hosts) calling this interface should make their\n    /// own decisions on how to handle errors returned from this function.\n    handle: async func(message: message) -> result<_, error>;\n\n\n    /// Server configuration.\n    ///\n    /// This can be extended to include other configuration options in the\n    /// future.\n    record configuration {\n        /// Subscription topics\n        topics: list<topic>,\n    }\n\n    /// Configure is called by the runtime to get the server\'s runtime\n    /// configuration.\n    configure: async func() -> result<configuration, error>;\n\n}\n";
    const _: &[u8] = b"package wasi:sql@0.2.0-draft;\n\nworld imports {\n\timport readwrite;\n}";
    const _: &[u8] = b"package wasi:messaging@0.2.0-draft;\n\n/// The `imports` world defines the interfaces that the component will import from the host.\n/// It includes the `producer` interface for sending messages.\nworld imports {\n  import producer;\n}\n\n/// The `imports-request-reply` world extends `imports` by including the `request-reply` interface.\n/// This allows the component to perform request/reply messaging patterns.\nworld imports-request-reply {\n  include imports;\n  import request-reply;\n}\n\n/// The `messaging-request-reply` world combines `imports-request-reply` with the `incoming-handler`\n/// export. This setup allows the host to interact with the component for both sending messages and\n/// handling incoming messages with request/reply capabilities.\nworld messaging-request-reply {\n  include imports-request-reply;\n  export incoming-handler;\n}\n\n/// The `messaging-core` world includes the basic `imports` and exports the `incoming-handler`,\n/// enabling the component to handle incoming messages without request/reply capabilities.\nworld messaging-core {\n  include imports;\n  export incoming-handler;\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import monotonic-clock;\n    @since(version = 0.2.0)\n    import wall-clock;\n    @unstable(feature = clocks-timezone)\n    import timezone;\n}\n";
    const _: &[u8] = b"// Types used by blobstore\ninterface types {\n  use wasi:io/streams@0.2.6.{input-stream, output-stream};\n\n  // name of a container, a collection of objects.\n  // The container name may be any valid UTF-8 string.\n  type container-name = string;\n\n  // name of an object within a container\n  // The object name may be any valid UTF-8 string.\n  type object-name = string;\n\n  // TODO: define timestamp to include seconds since\n  // Unix epoch and nanoseconds\n  // https://github.com/WebAssembly/wasi-blob-store/issues/7\n  type timestamp = u64;\n\n  // size of an object, in bytes\n  type object-size = u64;\n\n  type error = string;\n\n  // information about a container\n  record container-metadata {\n    // the container\'s name\n    name: container-name,\n    // date and time container was created\n    created-at: timestamp,\n  }\n\n  // information about an object\n  record object-metadata {\n    // the object\'s name\n    name: object-name,\n    // the object\'s parent container\n    container: container-name,\n    // date and time the object was created\n    created-at: timestamp,\n    // size of the object, in bytes\n    size: object-size,\n  }\n\n  // identifier for an object that includes its container name\n  record object-id {\n    container: container-name,\n    object: object-name\n  }\n\n  /// A data is the data stored in a data blob. The value can be of any type\n  /// that can be represented in a byte array. It provides a way to write the value\n  /// to the output-stream defined in the `wasi-io` interface.\n  // Soon: switch to `resource value { ... }`\n  resource outgoing-value {\n    new-outgoing-value: static func() -> outgoing-value;\n\n    /// Returns a stream for writing the value contents.\n    ///\n    /// The returned `output-stream` is a child resource: it must be dropped\n    /// before the parent `outgoing-value` resource is dropped (or finished),\n    /// otherwise the `outgoing-value` drop or `finish` will trap.\n    ///\n    /// Returns success on the first call: the `output-stream` resource for\n    /// this `outgoing-value` may be retrieved at most once. Subsequent calls\n    /// will return error.\n    outgoing-value-write-body: func() -> result<output-stream, error>;\n\n    /// Finalize an outgoing value. This must be\n    /// called to signal that the outgoing value is complete. If the `outgoing-value`\n    /// is dropped without calling `outgoing-value.finalize`, the implementation\n    /// should treat the value as corrupted.\n    finish: static func(this: outgoing-value) -> result<_, error>;\n  }\n\n  /// A incoming-value is a wrapper around a value. It provides a way to read the value\n  /// from the input-stream defined in the `wasi-io` interface.\n  ///\n  /// The incoming-value provides two ways to consume the value:\n  /// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the\n  ///    value as a list of bytes.\n  /// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the\n  ///    value as an input-stream.\n  // Soon: switch to `resource incoming-value { ... }`\n  resource incoming-value {\n      incoming-value-consume-sync: static func(this: incoming-value) -> result<incoming-value-sync-body, error>;\n      incoming-value-consume-async: static func(this: incoming-value) -> result<incoming-value-async-body, error>;\n      size: func() -> u64;\n  }\n\n  type incoming-value-async-body = input-stream;\n  type incoming-value-sync-body = list<u8>;\n}\n";
    const _: &[u8] = b"interface metrics {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, %resource, error};\n\n    /// Gathers and returns all metric data related to the [MetricReader] from the\n    /// SDK and stores it in the provided [ResourceMetrics] reference.\n    ///\n    /// An error is returned if this is called after shutdown.\n    %export: func(rm: resource-metrics) -> result<_, error>;\n\n    /// A collection of scope metrics and the associated resource that created them.\n    record resource-metrics {\n        /// The entity that collected the metrics.\n        %resource: %resource,\n\n        /// The collection of metrics with unique [InstrumentationScope]s.\n        scope-metrics: list<scope-metrics>,\n    }\n\n    record scope-metrics {\n        /// The instrumentation scope that the meter was created with.\n        scope: instrumentation-scope,\n\n        /// The list of aggregations created by the meter.\n        metrics: list<metric>,\n    }\n\n    /// A collection of one or more aggregated time series from an [Instrument].\n    ///\n    /// [Instrument]: crate::metrics::Instrument\n    record metric {\n        /// The name of the instrument that created this data.\n        name: string,\n\n        /// The description of the instrument, which can be used in documentation.\n        description: string,\n\n        /// The unit in which the instrument reports.\n        unit: string,\n\n        /// The aggregated data from an instrument.\n        data: aggregated-metrics,\n    }\n\n    /// Aggregated metrics data from an instrument\n    variant aggregated-metrics {\n        /// All metric data with `f64` value type\n        %f64(metric-data),\n\n        /// All metric data with `u64` value type\n        %u64(metric-data),\n\n        /// All metric data with `i64` value type\n        %s64(metric-data),\n    }\n\n    /// Metric data for all types\n    variant metric-data {\n        /// Metric data for Gauge\n        gauge(gauge),\n\n        /// Metric data for Sum\n        sum(sum),\n\n        /// Metric data for Histogram\n        histogram(histogram),\n\n        /// Metric data for ExponentialHistogram\n        exponential-histogram(exponential-histogram),\n    }\n\n    /// A measurement of the current value of an instrument.\n    record gauge {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<gauge-data-point>,\n\n        /// The time when the time series was started.\n        start-time: option<datetime>,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record gauge-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the sum of all measurements of values from an instrument.\n    record sum {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<sum-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n\n        /// Whether this aggregation only increases or decreases.\n        is-monotonic: bool,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record sum-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the histogram of all measurements of values from an instrument.\n    record histogram {\n        /// Individual aggregated measurements with unique attributes.\n        data-points: list<histogram-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single histogram data point in a time series.\n    record histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The upper bounds of the buckets of the histogram.\n        ///\n        /// Because the last boundary is +infinity this one is implied.\n        bounds: list<f64>,\n\n        /// The count of each of the buckets.\n        bucket-counts: list<u64>,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// The histogram of all measurements of values from an instrument.\n    record exponential-histogram {\n        /// The individual aggregated measurements with unique attributes.\n        data-points: list<exponential-histogram-data-point>,\n\n        /// When the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single exponential histogram data point in a time series.\n    record exponential-histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// Describes the resolution of the histogram.\n        ///\n        /// Boundaries are located at powers of the base, where:\n        ///\n        ///   base = 2 ^ (2 ^ -scale)\n        scale: s8,\n\n        /// The number of values whose absolute value is less than or equal to\n        /// `zero_threshold`.\n        ///\n        /// When `zero_threshold` is `0`, this is the number of values that cannot be\n        /// expressed using the standard exponential formula as well as values that have\n        /// been rounded to zero.\n        zero-count: u64,\n\n        /// The range of positive value bucket counts.\n        positive-bucket: exponential-bucket,\n\n        /// The range of negative value bucket counts.\n        negative-bucket: exponential-bucket,\n\n        /// The width of the zero region.\n        ///\n        /// Where the zero region is defined as the closed interval\n        /// [-zero_threshold, zero_threshold].\n        zero-threshold: f64,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// A set of bucket counts, encoded in a contiguous array of counts.\n    record exponential-bucket {\n        /// The bucket index of the first entry in the `counts` vec.\n        offset: s32,\n\n        /// A vec where `counts[i]` carries the count of the bucket at index `offset + i`.\n        ///\n        /// `counts[i]` is the count of values greater than base^(offset+i) and less than\n        /// or equal to base^(offset+i+1).\n        counts: list<u64>,\n    }\n\n    /// Defines the window that an aggregation was calculated over.\n    enum temporality {\n        /// A measurement interval that continues to expand forward in time from a\n        /// starting point.\n        ///\n        /// New measurements are added to all previous measurements since a start time.\n        cumulative,\n\n        /// A measurement interval that resets each cycle.\n        ///\n        /// Measurements from one cycle are recorded independently, measurements from\n        /// other cycles do not affect them.\n        delta,\n\n        /// Configures Synchronous Counter and Histogram instruments to use\n        /// Delta aggregation temporality, which allows them to shed memory\n        /// following a cardinality explosion, thus use less memory.\n        low-memory,\n    }\n\n    /// A measurement sampled from a time series providing a typical example.\n    record exemplar {\n        /// The attributes recorded with the measurement but filtered out of the\n        /// time series\' aggregated data.\n        filtered-attributes: list<key-value>,\n\n        /// The time when the measurement was recorded.\n        time: datetime,\n\n        /// The measured value.\n        value: data-value,\n\n        /// The ID of the span that was active during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        span-id: string,\n\n        /// The ID of the trace the active span belonged to during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        trace-id: string,\n    }\n\n    variant data-value {\n        /// All metric data with `f64` value type\n        %f64(f64),\n\n        /// All metric data with `u64` value type\n        %u64(u64),\n\n        /// All metric data with `s64` value type\n        %s64(s64),\n    }\n\n\n    /// The identifier of a group of instruments that all perform the same function.\n    enum instrument-kind {\n        /// Identifies a group of instruments that record increasing values synchronously\n        /// with the code path they are measuring.\n        counter,\n\n        /// A group of instruments that record increasing and decreasing values\n        /// synchronously with the code path they are measuring.\n        up-down-counter,\n\n        /// A group of instruments that record a distribution of values synchronously with\n        /// the code path they are measuring.\n        histogram,\n\n        /// A group of instruments that record increasing values in an asynchronous\n        /// callback.\n        observable-counter,\n\n        /// A group of instruments that record increasing and decreasing values in an\n        /// asynchronous callback.\n        observable-up-down-counter,\n\n        /// a group of instruments that record current value synchronously with\n        /// the code path they are measuring.\n        gauge,\n\n        /// a group of instruments that record current values in an asynchronous callback.\n        observable-gauge,\n    }\n}\n";
    const _: &[u8] = b"interface types {\n    /// A type alias for list<tuple<string, string>> to represent metadata attached to a message\n    type metadata = list<tuple<string, string>>;\n\n    /// A type alias for string to represent a message topic\n    type topic = string;\n\n    /// A connection to a message-exchange service (e.g., buffer, broker, etc.).\n    resource client {\n        connect: static func(name: string) -> result<client, error>;\n        disconnect: func() -> result<_, error>;\n    }\n\n    /// Errors that can occur when using the messaging interface.\n    variant error {\n        /// The request or operation timed out.\n        timeout,\n        /// An error occurred with the connection. Includes a message for additional context\n        connection(string),\n        /// A permission error occurred. Includes a message for additional context\n        permission-denied(string),\n        /// A catch all for other types of errors\n        other(string),\n    }\n\n    /// A message with a binary payload and additional information\n    resource message {\n        constructor(data: list<u8>);\n        // new: static func(data: stream<u8>) -> message;\n\n        /// The topic/subject/channel this message was received on, if any\n        topic: func() -> option<topic>;\n        /// An optional content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        content-type: func() -> option<string>;\n        /// Set the content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        set-content-type: func(content-type: string);\n        /// An opaque blob of data\n        data: func() -> list<u8>;\n        /// Set the opaque blob of data for this message, discarding the old value\n        set-data: func(data: list<u8>);\n        /// Optional metadata (also called headers or attributes in some systems) attached to the\n        /// message. This metadata is simply decoration and should not be interpreted by a host\n        /// to ensure portability across different implementors (e.g., Kafka -> NATS, etc.).\n        metadata: func() -> option<metadata>;\n        /// Add a new key-value pair to the metadata, overwriting any existing value for the same key\n        add-metadata: func(key: string, value: string);\n        /// Set the metadata\n        set-metadata: func(meta: metadata);\n        /// Remove a key-value pair from the metadata\n        remove-metadata: func(key: string);\n    }\n}\n";
    const _: &[u8] = b"package wasmgrid:service;\n\nworld blobstore {\n\tinclude wasi:blobstore/imports@0.2.0-draft;\n}\n\nworld keyvalue {\n\tinclude wasi:keyvalue/watch-service@0.2.0-draft2;\n}\n\nworld messaging {\n\tinclude wasi:messaging/messaging-request-reply@0.2.0-draft;\n}\n\nworld otel {\n\tinclude wasi:otel/imports@0.2.0-draft;\n}\n\nworld sql {\n\tinclude wasi:sql/imports@0.2.0-draft;\n}\n\nworld vault {\n\tinclude wasi:vault/imports@0.1.0-draft;\n}";
}
/// Bindings for the `wasi:messaging` world.
/// See (<https://github.com/WebAssembly/wasi-messaging/>)
pub mod messaging {
    #![allow(clippy::future_not_send)]
    #![allow(clippy::collection_is_never_read)]
    pub use self::exports::wasi::messaging::*;
    pub use self::wasi::messaging::*;
    #[allow(dead_code, clippy::all)]
    pub mod wasi {
        pub mod messaging {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                /// A type alias for list<tuple<string, string>> to represent metadata attached to a message
                pub type Metadata = _rt::Vec<(_rt::String, _rt::String)>;
                /// A type alias for string to represent a message topic
                pub type Topic = _rt::String;
                /// A connection to a message-exchange service (e.g., buffer, broker, etc.).
                #[repr(transparent)]
                pub struct Client {
                    handle: _rt::Resource<Client>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Client {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Client",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl Client {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for Client {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                /// Errors that can occur when using the messaging interface.
                pub enum Error {
                    /// The request or operation timed out.
                    Timeout,
                    /// An error occurred with the connection. Includes a message for additional context
                    Connection(_rt::String),
                    /// A permission error occurred. Includes a message for additional context
                    PermissionDenied(_rt::String),
                    /// A catch all for other types of errors
                    Other(_rt::String),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Error {
                    #[inline]
                    fn clone(&self) -> Error {
                        match self {
                            Error::Timeout => Error::Timeout,
                            Error::Connection(__self_0) => {
                                Error::Connection(::core::clone::Clone::clone(__self_0))
                            }
                            Error::PermissionDenied(__self_0) => {
                                Error::PermissionDenied(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Error::Other(__self_0) => {
                                Error::Other(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Error::Timeout => f.debug_tuple("Error::Timeout").finish(),
                            Error::Connection(e) => {
                                f.debug_tuple("Error::Connection").field(e).finish()
                            }
                            Error::PermissionDenied(e) => {
                                f.debug_tuple("Error::PermissionDenied").field(e).finish()
                            }
                            Error::Other(e) => {
                                f.debug_tuple("Error::Other").field(e).finish()
                            }
                        }
                    }
                }
                impl ::core::fmt::Display for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for Error {}
                /// A message with a binary payload and additional information
                #[repr(transparent)]
                pub struct Message {
                    handle: _rt::Resource<Message>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Message {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Message",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl Message {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for Message {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                impl Client {
                    #[allow(unused_unsafe, clippy::all)]
                    #[allow(async_fn_in_trait)]
                    pub fn connect(name: &str) -> Result<Client, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = name;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(ptr0.cast_mut(), len0, ptr1);
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result16 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = *ptr1
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        Client::from_handle(l4 as u32)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v15 = match l5 {
                                            0 => Error::Timeout,
                                            1 => {
                                                let e15 = {
                                                    let l6 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l7 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len8 = l7;
                                                    let bytes8 = _rt::Vec::from_raw_parts(
                                                        l6.cast(),
                                                        len8,
                                                        len8,
                                                    );
                                                    _rt::string_lift(bytes8)
                                                };
                                                Error::Connection(e15)
                                            }
                                            2 => {
                                                let e15 = {
                                                    let l9 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l10 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len11 = l10;
                                                    let bytes11 = _rt::Vec::from_raw_parts(
                                                        l9.cast(),
                                                        len11,
                                                        len11,
                                                    );
                                                    _rt::string_lift(bytes11)
                                                };
                                                Error::PermissionDenied(e15)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &3) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e15 = {
                                                    let l12 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l13 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len14 = l13;
                                                    let bytes14 = _rt::Vec::from_raw_parts(
                                                        l12.cast(),
                                                        len14,
                                                        len14,
                                                    );
                                                    _rt::string_lift(bytes14)
                                                };
                                                Error::Other(e15)
                                            }
                                        };
                                        v15
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result16
                        }
                    }
                }
                impl Client {
                    #[allow(unused_unsafe, clippy::all)]
                    #[allow(async_fn_in_trait)]
                    pub fn disconnect(&self) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result14 = match l2 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l3 = i32::from(
                                            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v13 = match l3 {
                                            0 => Error::Timeout,
                                            1 => {
                                                let e13 = {
                                                    let l4 = *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l5 = *ptr0
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len6 = l5;
                                                    let bytes6 = _rt::Vec::from_raw_parts(
                                                        l4.cast(),
                                                        len6,
                                                        len6,
                                                    );
                                                    _rt::string_lift(bytes6)
                                                };
                                                Error::Connection(e13)
                                            }
                                            2 => {
                                                let e13 = {
                                                    let l7 = *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l8 = *ptr0
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len9 = l8;
                                                    let bytes9 = _rt::Vec::from_raw_parts(
                                                        l7.cast(),
                                                        len9,
                                                        len9,
                                                    );
                                                    _rt::string_lift(bytes9)
                                                };
                                                Error::PermissionDenied(e13)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &3) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e13 = {
                                                    let l10 = *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l11 = *ptr0
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len12 = l11;
                                                    let bytes12 = _rt::Vec::from_raw_parts(
                                                        l10.cast(),
                                                        len12,
                                                        len12,
                                                    );
                                                    _rt::string_lift(bytes12)
                                                };
                                                Error::Other(e13)
                                            }
                                        };
                                        v13
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result14
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    #[allow(async_fn_in_trait)]
                    pub fn new(data: &[u8]) -> Self {
                        unsafe {
                            let vec0 = data;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            unsafe extern "C" fn wit_import1(
                                _: *mut u8,
                                _: usize,
                            ) -> i32 {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            let ret = wit_import1(ptr0.cast_mut(), len0);
                            Message::from_handle(ret as u32)
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// new: static func(data: stream<u8>) -> message;
                    /// The topic/subject/channel this message was received on, if any
                    #[allow(async_fn_in_trait)]
                    pub fn topic(&self) -> Option<Topic> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result6 = match l2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        let bytes5 = _rt::Vec::from_raw_parts(
                                            l3.cast(),
                                            len5,
                                            len5,
                                        );
                                        _rt::string_lift(bytes5)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result6
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// An optional content-type describing the format of the data in the message. This is
                    /// sometimes described as the "format" type
                    #[allow(async_fn_in_trait)]
                    pub fn content_type(&self) -> Option<_rt::String> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result6 = match l2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        let bytes5 = _rt::Vec::from_raw_parts(
                                            l3.cast(),
                                            len5,
                                            len5,
                                        );
                                        _rt::string_lift(bytes5)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result6
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Set the content-type describing the format of the data in the message. This is
                    /// sometimes described as the "format" type
                    #[allow(async_fn_in_trait)]
                    pub fn set_content_type(&self, content_type: &str) -> () {
                        unsafe {
                            let vec0 = content_type;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// An opaque blob of data
                    #[allow(async_fn_in_trait)]
                    pub fn data(&self) -> _rt::Vec<u8> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 2 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 2
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = *ptr0.add(0).cast::<*mut u8>();
                            let l3 = *ptr0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len4 = l3;
                            let result5 = _rt::Vec::from_raw_parts(
                                l2.cast(),
                                len4,
                                len4,
                            );
                            result5
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Set the opaque blob of data for this message, discarding the old value
                    #[allow(async_fn_in_trait)]
                    pub fn set_data(&self, data: &[u8]) -> () {
                        unsafe {
                            let vec0 = data;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Optional metadata (also called headers or attributes in some systems) attached to the
                    /// message. This metadata is simply decoration and should not be interpreted by a host
                    /// to ensure portability across different implementors (e.g., Kafka -> NATS, etc.).
                    #[allow(async_fn_in_trait)]
                    pub fn metadata(&self) -> Option<Metadata> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 3 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 3
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result12 = match l2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base11 = l3;
                                        let len11 = l4;
                                        let mut result11 = _rt::Vec::with_capacity(len11);
                                        for i in 0..len11 {
                                            let base = base11
                                                .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                            let e11 = {
                                                let l5 = *base.add(0).cast::<*mut u8>();
                                                let l6 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len7 = l6;
                                                let bytes7 = _rt::Vec::from_raw_parts(
                                                    l5.cast(),
                                                    len7,
                                                    len7,
                                                );
                                                let l8 = *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l9 = *base
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len10 = l9;
                                                let bytes10 = _rt::Vec::from_raw_parts(
                                                    l8.cast(),
                                                    len10,
                                                    len10,
                                                );
                                                (_rt::string_lift(bytes7), _rt::string_lift(bytes10))
                                            };
                                            result11.push(e11);
                                        }
                                        _rt::cabi_dealloc(
                                            base11,
                                            len11 * (4 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result11
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result12
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Add a new key-value pair to the metadata, overwriting any existing value for the same key
                    #[allow(async_fn_in_trait)]
                    pub fn add_metadata(&self, key: &str, value: &str) -> () {
                        unsafe {
                            let vec0 = key;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let vec1 = value;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1.cast_mut(),
                                len1,
                            );
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Set the metadata
                    #[allow(async_fn_in_trait)]
                    pub fn set_metadata(
                        &self,
                        meta: &[(_rt::String, _rt::String)],
                    ) -> () {
                        unsafe {
                            let vec3 = meta;
                            let len3 = vec3.len();
                            let layout3 = _rt::alloc::Layout::from_size_align(
                                    vec3.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                                .unwrap();
                            let (result3, _cleanup3) = wit_bindgen::rt::Cleanup::new(
                                layout3,
                            );
                            for (i, e) in vec3.into_iter().enumerate() {
                                let base = result3
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t0_0, t0_1) = e;
                                    let vec1 = t0_0;
                                    let ptr1 = vec1.as_ptr().cast::<u8>();
                                    let len1 = vec1.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len1;
                                    *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                                    let vec2 = t0_1;
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr2.cast_mut();
                                }
                            }
                            unsafe extern "C" fn wit_import4(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import4((self).handle() as i32, result3, len3);
                        }
                    }
                }
                impl Message {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Remove a key-value pair from the metadata
                    #[allow(async_fn_in_trait)]
                    pub fn remove_metadata(&self, key: &str) -> () {
                        unsafe {
                            let vec0 = key;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            unsafe extern "C" fn wit_import1(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                        }
                    }
                }
            }
            /// The request-reply interface allows a guest to send a message and await a response. This
            /// interface is considered optional as not all message services support the concept of
            /// request/reply. However, request/reply is a very common pattern in messaging and as such, we have
            /// included it as a core interface.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod request_reply {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type Client = super::super::super::wasi::messaging::types::Client;
                pub type Message = super::super::super::wasi::messaging::types::Message;
                pub type Error = super::super::super::wasi::messaging::types::Error;
                pub type Topic = super::super::super::wasi::messaging::types::Topic;
                /// Options for a request/reply operation. This is a resource to allow for future expansion of
                /// options.
                #[repr(transparent)]
                pub struct RequestOptions {
                    handle: _rt::Resource<RequestOptions>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for RequestOptions {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RequestOptions",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl RequestOptions {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for RequestOptions {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                impl RequestOptions {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Creates a new request options resource with no options set.
                    #[allow(async_fn_in_trait)]
                    pub fn new() -> Self {
                        unsafe {
                            unsafe extern "C" fn wit_import0() -> i32 {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            let ret = wit_import0();
                            RequestOptions::from_handle(ret as u32)
                        }
                    }
                }
                impl RequestOptions {
                    #[allow(unused_unsafe, clippy::all)]
                    /// The maximum amount of time to wait for a response. If the timeout value is not set, then
                    /// the request/reply operation will block until a message is received in response.
                    #[allow(async_fn_in_trait)]
                    pub fn set_timeout_ms(&self, timeout_ms: u32) -> () {
                        unsafe {
                            unsafe extern "C" fn wit_import0(_: i32, _: i32) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import0(
                                (self).handle() as i32,
                                _rt::as_i32(&timeout_ms),
                            );
                        }
                    }
                }
                impl RequestOptions {
                    #[allow(unused_unsafe, clippy::all)]
                    /// The maximum number of replies to expect before returning.
                    #[allow(async_fn_in_trait)]
                    pub fn set_expected_replies(&self, expected_replies: u32) -> () {
                        unsafe {
                            unsafe extern "C" fn wit_import0(_: i32, _: i32) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import0(
                                (self).handle() as i32,
                                _rt::as_i32(&expected_replies),
                            );
                        }
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Performs a blocking request/reply operation with an optional set of request options.
                ///
                /// The behavior of this function is largely dependent on the options given to the function.
                /// If no options are provided, then the request/reply operation will block until a single
                /// message is received in response. If a timeout is provided, then the request/reply operation
                /// will block for the specified amount of time before returning an error if no messages were
                /// received (or the list of messages that were received). If both a timeout and an expected
                /// number of replies are provided, the function should return when either condition is met
                /// (whichever comes first)e.g., (1) if no replies were received within the timeout return an
                /// error, (2) if the maximum expected number of replies were received before timeout, return
                /// the list of messages, or (3) if the timeout is reached before the expected number of replies,
                /// return the list of messages received up to that point.
                #[allow(async_fn_in_trait)]
                pub fn request(
                    c: &Client,
                    topic: &str,
                    message: &Message,
                    options: Option<RequestOptions>,
                ) -> Result<_rt::Vec<Message>, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = topic;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let (result1_0, result1_1) = match &options {
                            Some(e) => (1i32, (e).take_handle() as i32),
                            None => (0i32, 0i32),
                        };
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import3(
                            (c).handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                            (message).handle() as i32,
                            result1_0,
                            result1_1,
                            ptr2,
                        );
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result20 = match l4 {
                            0 => {
                                let e = {
                                    let l5 = *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *ptr2
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base8 = l5;
                                    let len8 = l6;
                                    let mut result8 = _rt::Vec::with_capacity(len8);
                                    for i in 0..len8 {
                                        let base = base8.add(i * 4);
                                        let e8 = {
                                            let l7 = *base.add(0).cast::<i32>();
                                            super::super::super::wasi::messaging::types::Message::from_handle(
                                                l7 as u32,
                                            )
                                        };
                                        result8.push(e8);
                                    }
                                    _rt::cabi_dealloc(base8, len8 * 4, 4);
                                    result8
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(
                                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    use super::super::super::wasi::messaging::types::Error as V19;
                                    let v19 = match l9 {
                                        0 => V19::Timeout,
                                        1 => {
                                            let e19 = {
                                                let l10 = *ptr2
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l11 = *ptr2
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len12 = l11;
                                                let bytes12 = _rt::Vec::from_raw_parts(
                                                    l10.cast(),
                                                    len12,
                                                    len12,
                                                );
                                                _rt::string_lift(bytes12)
                                            };
                                            V19::Connection(e19)
                                        }
                                        2 => {
                                            let e19 = {
                                                let l13 = *ptr2
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l14 = *ptr2
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len15 = l14;
                                                let bytes15 = _rt::Vec::from_raw_parts(
                                                    l13.cast(),
                                                    len15,
                                                    len15,
                                                );
                                                _rt::string_lift(bytes15)
                                            };
                                            V19::PermissionDenied(e19)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &3) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e19 = {
                                                let l16 = *ptr2
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l17 = *ptr2
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len18 = l17;
                                                let bytes18 = _rt::Vec::from_raw_parts(
                                                    l16.cast(),
                                                    len18,
                                                    len18,
                                                );
                                                _rt::string_lift(bytes18)
                                            };
                                            V19::Other(e19)
                                        }
                                    };
                                    v19
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result20
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Replies to the given message with the given response message. The details of which topic
                /// the message is sent to is up to the implementation. This allows for reply-to details to be
                /// handled in the best way possible for the underlying messaging system.
                ///
                /// Please note that this reply functionality is different than something like HTTP because there
                /// are several use cases in which a reply might not be required for every message (so this would
                /// be a noop). There are also cases when you might want to reply and then continue processing.
                /// Additionally, you might want to reply to a message several times (such as providing an
                /// update). So this function is allowed to be called multiple times, unlike something like HTTP
                /// where the reply is sent and the connection is closed.
                #[allow(async_fn_in_trait)]
                pub fn reply(reply_to: &Message, message: Message) -> Result<(), Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(
                            (reply_to).handle() as i32,
                            (&message).take_handle() as i32,
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result14 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    use super::super::super::wasi::messaging::types::Error as V13;
                                    let v13 = match l3 {
                                        0 => V13::Timeout,
                                        1 => {
                                            let e13 = {
                                                let l4 = *ptr0
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l5 = *ptr0
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len6 = l5;
                                                let bytes6 = _rt::Vec::from_raw_parts(
                                                    l4.cast(),
                                                    len6,
                                                    len6,
                                                );
                                                _rt::string_lift(bytes6)
                                            };
                                            V13::Connection(e13)
                                        }
                                        2 => {
                                            let e13 = {
                                                let l7 = *ptr0
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l8 = *ptr0
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len9 = l8;
                                                let bytes9 = _rt::Vec::from_raw_parts(
                                                    l7.cast(),
                                                    len9,
                                                    len9,
                                                );
                                                _rt::string_lift(bytes9)
                                            };
                                            V13::PermissionDenied(e13)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &3) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e13 = {
                                                let l10 = *ptr0
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l11 = *ptr0
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len12 = l11;
                                                let bytes12 = _rt::Vec::from_raw_parts(
                                                    l10.cast(),
                                                    len12,
                                                    len12,
                                                );
                                                _rt::string_lift(bytes12)
                                            };
                                            V13::Other(e13)
                                        }
                                    };
                                    v13
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result14
                    }
                }
            }
            /// The producer interface is used to send messages to a channel/topic.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod producer {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type Client = super::super::super::wasi::messaging::types::Client;
                pub type Message = super::super::super::wasi::messaging::types::Message;
                pub type Error = super::super::super::wasi::messaging::types::Error;
                pub type Topic = super::super::super::wasi::messaging::types::Topic;
                #[allow(unused_unsafe, clippy::all)]
                /// Sends the message using the given client.
                #[allow(async_fn_in_trait)]
                pub async fn send(
                    c: Client,
                    topic: Topic,
                    message: Message,
                ) -> Result<(), Error> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (Client, Topic, Message);
                            type Results = Result<(), Error>;
                            type ParamsLower = (i32, *mut u8, usize, i32);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: *mut u8,
                                    _: usize,
                                    _: i32,
                                    _: *mut u8,
                                ) -> i32 {
                                    ::core::panicking::panic(
                                        "internal error: entered unreachable code",
                                    )
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _params.3, _results)
                                        as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let _ = super::super::super::wasi::messaging::types::Client::from_handle(
                                        _params.0 as u32,
                                    );
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                    let _ = super::super::super::wasi::messaging::types::Message::from_handle(
                                        _params.3 as u32,
                                    );
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    let vec0 = (_lower1.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    (
                                        (_lower0).take_handle() as i32,
                                        ptr0.cast_mut(),
                                        len0,
                                        (_lower2).take_handle() as i32,
                                    )
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(
                                                    *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                                );
                                                use super::super::super::wasi::messaging::types::Error as V11;
                                                let v11 = match l1 {
                                                    0 => V11::Timeout,
                                                    1 => {
                                                        let e11 = {
                                                            let l2 = *_ptr
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l3 = *_ptr
                                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len4 = l3;
                                                            let bytes4 = _rt::Vec::from_raw_parts(
                                                                l2.cast(),
                                                                len4,
                                                                len4,
                                                            );
                                                            _rt::string_lift(bytes4)
                                                        };
                                                        V11::Connection(e11)
                                                    }
                                                    2 => {
                                                        let e11 = {
                                                            let l5 = *_ptr
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l6 = *_ptr
                                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len7 = l6;
                                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                                l5.cast(),
                                                                len7,
                                                                len7,
                                                            );
                                                            _rt::string_lift(bytes7)
                                                        };
                                                        V11::PermissionDenied(e11)
                                                    }
                                                    n => {
                                                        if true {
                                                            match (&n, &3) {
                                                                (left_val, right_val) => {
                                                                    if !(*left_val == *right_val) {
                                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                                        ::core::panicking::assert_failed(
                                                                            kind,
                                                                            &*left_val,
                                                                            &*right_val,
                                                                            ::core::option::Option::Some(
                                                                                format_args!("invalid enum discriminant"),
                                                                            ),
                                                                        );
                                                                    }
                                                                }
                                                            };
                                                        }
                                                        let e11 = {
                                                            let l8 = *_ptr
                                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l9 = *_ptr
                                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len10 = l9;
                                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                                l8.cast(),
                                                                len10,
                                                                len10,
                                                            );
                                                            _rt::string_lift(bytes10)
                                                        };
                                                        V11::Other(e11)
                                                    }
                                                };
                                                v11
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((c, topic, message)).await
                    }
                }
            }
        }
    }
    #[allow(dead_code, clippy::all)]
    pub mod exports {
        pub mod wasi {
            pub mod messaging {
                #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
                pub mod incoming_handler {
                    #[used]
                    #[doc(hidden)]
                    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                    use super::super::super::super::_rt;
                    pub type Message = super::super::super::super::wasi::messaging::types::Message;
                    pub type Error = super::super::super::super::wasi::messaging::types::Error;
                    pub type Topic = super::super::super::super::wasi::messaging::types::Topic;
                    /// Server configuration.
                    ///
                    /// This can be extended to include other configuration options in the
                    /// future.
                    pub struct Configuration {
                        /// Subscription topics
                        pub topics: _rt::Vec<Topic>,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for Configuration {
                        #[inline]
                        fn clone(&self) -> Configuration {
                            Configuration {
                                topics: ::core::clone::Clone::clone(&self.topics),
                            }
                        }
                    }
                    impl ::core::fmt::Debug for Configuration {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter<'_>,
                        ) -> ::core::fmt::Result {
                            f.debug_struct("Configuration")
                                .field("topics", &self.topics)
                                .finish()
                        }
                    }
                    #[doc(hidden)]
                    #[allow(non_snake_case, unused_unsafe)]
                    pub unsafe fn _export_async_handle_cabi<T: Guest>(arg0: i32) -> i32 {
                        unsafe {
                            wit_bindgen::rt::async_support::start_task(async move {
                                let _task_cancel = wit_bindgen::rt::async_support::TaskCancelOnDrop::new();
                                let result0 = &{
                                    T::handle(
                                            super::super::super::super::wasi::messaging::types::Message::from_handle(
                                                arg0 as u32,
                                            ),
                                        )
                                        .await
                                };
                                let (result6_0, result6_1, result6_2, result6_3) = match result0 {
                                    Ok(_) => (0i32, 0i32, ::core::ptr::null_mut(), 0usize),
                                    Err(e) => {
                                        use super::super::super::super::wasi::messaging::types::Error as V4;
                                        let (result5_0, result5_1, result5_2) = match e {
                                            V4::Timeout => (0i32, ::core::ptr::null_mut(), 0usize),
                                            V4::Connection(e) => {
                                                let vec1 = e;
                                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                                let len1 = vec1.len();
                                                (1i32, ptr1.cast_mut(), len1)
                                            }
                                            V4::PermissionDenied(e) => {
                                                let vec2 = e;
                                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                                let len2 = vec2.len();
                                                (2i32, ptr2.cast_mut(), len2)
                                            }
                                            V4::Other(e) => {
                                                let vec3 = e;
                                                let ptr3 = vec3.as_ptr().cast::<u8>();
                                                let len3 = vec3.len();
                                                (3i32, ptr3.cast_mut(), len3)
                                            }
                                        };
                                        (1i32, result5_0, result5_1, result5_2)
                                    }
                                };
                                unsafe extern "C" fn wit_import7(
                                    _: i32,
                                    _: i32,
                                    _: *mut u8,
                                    _: usize,
                                ) {
                                    ::core::panicking::panic(
                                        "internal error: entered unreachable code",
                                    )
                                }
                                _task_cancel.forget();
                                wit_import7(result6_0, result6_1, result6_2, result6_3);
                            })
                        }
                    }
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    pub unsafe fn __callback_async_handle(
                        event0: u32,
                        event1: u32,
                        event2: u32,
                    ) -> u32 {
                        unsafe {
                            wit_bindgen::rt::async_support::callback(
                                event0,
                                event1,
                                event2,
                            )
                        }
                    }
                    #[doc(hidden)]
                    #[allow(non_snake_case, unused_unsafe)]
                    pub unsafe fn _export_async_configure_cabi<T: Guest>() -> i32 {
                        unsafe {
                            wit_bindgen::rt::async_support::start_task(async move {
                                let _task_cancel = wit_bindgen::rt::async_support::TaskCancelOnDrop::new();
                                let mut cleanup_list = _rt::Vec::new();
                                let result0 = &{ T::configure().await };
                                let (result9_0, result9_1, result9_2, result9_3) = match result0 {
                                    Ok(e) => {
                                        let Configuration { topics: topics1 } = e;
                                        let vec3 = topics1;
                                        let len3 = vec3.len();
                                        let layout3 = _rt::alloc::Layout::from_size_align(
                                                vec3.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            )
                                            .unwrap();
                                        let (result3, _cleanup3) = wit_bindgen::rt::Cleanup::new(
                                            layout3,
                                        );
                                        cleanup_list.extend(_cleanup3);
                                        for (i, e) in vec3.into_iter().enumerate() {
                                            let base = result3
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            {
                                                let vec2 = e;
                                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                                let len2 = vec2.len();
                                                *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len2;
                                                *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                                            }
                                        }
                                        (0i32, result3, len3 as *mut u8, 0usize)
                                    }
                                    Err(e) => {
                                        use super::super::super::super::wasi::messaging::types::Error as V7;
                                        let (result8_0, result8_1, result8_2) = match e {
                                            V7::Timeout => (0i32, ::core::ptr::null_mut(), 0usize),
                                            V7::Connection(e) => {
                                                let vec4 = e;
                                                let ptr4 = vec4.as_ptr().cast::<u8>();
                                                let len4 = vec4.len();
                                                (1i32, ptr4.cast_mut(), len4)
                                            }
                                            V7::PermissionDenied(e) => {
                                                let vec5 = e;
                                                let ptr5 = vec5.as_ptr().cast::<u8>();
                                                let len5 = vec5.len();
                                                (2i32, ptr5.cast_mut(), len5)
                                            }
                                            V7::Other(e) => {
                                                let vec6 = e;
                                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                                let len6 = vec6.len();
                                                (3i32, ptr6.cast_mut(), len6)
                                            }
                                        };
                                        (1i32, result8_0 as *mut u8, result8_1, result8_2)
                                    }
                                };
                                unsafe extern "C" fn wit_import10(
                                    _: i32,
                                    _: *mut u8,
                                    _: *mut u8,
                                    _: usize,
                                ) {
                                    ::core::panicking::panic(
                                        "internal error: entered unreachable code",
                                    )
                                }
                                _task_cancel.forget();
                                wit_import10(result9_0, result9_1, result9_2, result9_3);
                            })
                        }
                    }
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    pub unsafe fn __callback_async_configure(
                        event0: u32,
                        event1: u32,
                        event2: u32,
                    ) -> u32 {
                        unsafe {
                            wit_bindgen::rt::async_support::callback(
                                event0,
                                event1,
                                event2,
                            )
                        }
                    }
                    pub trait Guest {
                        /// Whenever this guest receives a message in one of the subscribed topics, the message is
                        /// sent to this handler. The guest is responsible for matching on the topic and handling the
                        /// message accordingly. Implementors (such as hosts) calling this interface should make their
                        /// own decisions on how to handle errors returned from this function.
                        #[allow(async_fn_in_trait)]
                        async fn handle(message: Message) -> Result<(), Error>;
                        /// Configure is called by the runtime to get the server's runtime
                        /// configuration.
                        #[allow(async_fn_in_trait)]
                        async fn configure() -> Result<Configuration, Error>;
                    }
                    #[doc(hidden)]
                    pub use __export_wasi_messaging_incoming_handler_0_2_0_draft_cabi;
                }
            }
        }
    }
    mod _rt {
        #![allow(dead_code, clippy::all)]
        pub use alloc_crate::vec::Vec;
        pub use alloc_crate::string::String;
        use core::fmt;
        use core::marker;
        use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
        /// A type which represents a component model resource, either imported or
        /// exported into this component.
        ///
        /// This is a low-level wrapper which handles the lifetime of the resource
        /// (namely this has a destructor). The `T` provided defines the component model
        /// intrinsics that this wrapper uses.
        ///
        /// One of the chief purposes of this type is to provide `Deref` implementations
        /// to access the underlying data when it is owned.
        ///
        /// This type is primarily used in generated code for exported and imported
        /// resources.
        #[repr(transparent)]
        pub struct Resource<T: WasmResource> {
            handle: AtomicU32,
            _marker: marker::PhantomData<T>,
        }
        /// A trait which all wasm resources implement, namely providing the ability to
        /// drop a resource.
        ///
        /// This generally is implemented by generated code, not user-facing code.
        #[allow(clippy::missing_safety_doc)]
        pub unsafe trait WasmResource {
            /// Invokes the `[resource-drop]...` intrinsic.
            unsafe fn drop(handle: u32);
        }
        impl<T: WasmResource> Resource<T> {
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
                if true {
                    if !(handle != 0 && handle != u32::MAX) {
                        ::core::panicking::panic(
                            "assertion failed: handle != 0 && handle != u32::MAX",
                        )
                    }
                }
                Self {
                    handle: AtomicU32::new(handle),
                    _marker: marker::PhantomData,
                }
            }
            /// Takes ownership of the handle owned by `resource`.
            ///
            /// Note that this ideally would be `into_handle` taking `Resource<T>` by
            /// ownership. The code generator does not enable that in all situations,
            /// unfortunately, so this is provided instead.
            ///
            /// Also note that `take_handle` is in theory only ever called on values
            /// owned by a generated function. For example a generated function might
            /// take `Resource<T>` as an argument but then call `take_handle` on a
            /// reference to that argument. In that sense the dynamic nature of
            /// `take_handle` should only be exposed internally to generated code, not
            /// to user code.
            #[doc(hidden)]
            pub fn take_handle(resource: &Resource<T>) -> u32 {
                resource.handle.swap(u32::MAX, Relaxed)
            }
            #[doc(hidden)]
            pub fn handle(resource: &Resource<T>) -> u32 {
                resource.handle.load(Relaxed)
            }
        }
        impl<T: WasmResource> fmt::Debug for Resource<T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("Resource").field("handle", &self.handle).finish()
            }
        }
        impl<T: WasmResource> Drop for Resource<T> {
            fn drop(&mut self) {
                unsafe {
                    match self.handle.load(Relaxed) {
                        u32::MAX => {}
                        other => T::drop(other),
                    }
                }
            }
        }
        pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
            if true {
                String::from_utf8(bytes).unwrap()
            } else {
                unsafe { String::from_utf8_unchecked(bytes) }
            }
        }
        pub unsafe fn invalid_enum_discriminant<T>() -> T {
            if true {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid enum discriminant"),
                    );
                }
            } else {
                unsafe { core::hint::unreachable_unchecked() }
            }
        }
        pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
            if size == 0 {
                return;
            }
            unsafe {
                let layout = alloc::Layout::from_size_align_unchecked(size, align);
                alloc::dealloc(ptr, layout);
            }
        }
        pub use alloc_crate::alloc;
        pub fn as_i32<T: AsI32>(t: T) -> i32 {
            t.as_i32()
        }
        pub trait AsI32 {
            fn as_i32(self) -> i32;
        }
        impl<'a, T: Copy + AsI32> AsI32 for &'a T {
            fn as_i32(self) -> i32 {
                (*self).as_i32()
            }
        }
        impl AsI32 for i32 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for u32 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for i16 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for u16 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for i8 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for u8 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for char {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for usize {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        extern crate alloc as alloc_crate;
    }
    #[doc(inline)]
    pub use __export_messaging_impl as export;
    #[inline(never)]
    #[doc(hidden)]
    pub fn __link_custom_section_describing_imports() {
        wit_bindgen::rt::maybe_link_cabi_realloc();
    }
    const _: &[u8] = b"// wasi-cloud Blobstore service definition\ninterface blobstore {\n  use container.{container};\n  use types.{error, container-name, object-id};\n\n  // creates a new empty container\n  create-container: func(name: container-name) -> result<container, error>;\n\n  // retrieves a container by name\n  get-container: func(name: container-name) -> result<container, error>;\n\n  // deletes a container and all objects within it\n  delete-container: func(name: container-name) -> result<_, error>;\n\n  // returns true if the container exists\n  container-exists: func(name: container-name) -> result<bool, error>;\n\n  // copies (duplicates) an object, to the same or a different container.\n  // returns an error if the target container does not exist.\n  // overwrites destination object if it already existed.\n  copy-object: func(src: object-id, dest: object-id) -> result<_, error>;\n\n  // moves or renames an object, to the same or a different container\n  // returns an error if the destination container does not exist.\n  // overwrites destination object if it already existed.\n  move-object: func(src:object-id, dest: object-id) -> result<_, error>;\n}";
    const _: &[u8] = b"package wasi:otel@0.2.0-draft;\n\nworld imports {\n    import tracing;\n    import metrics;\n    import %resource;\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import monotonic-clock;\n    @since(version = 0.2.0)\n    import wall-clock;\n    @unstable(feature = clocks-timezone)\n    import timezone;\n}\n";
    const _: &[u8] = b"interface readwrite {\n    use types.{statement, row, error, connection};\n    \n    /// query is optimized for querying data, and \n    /// implementors can make use of that fact to optimize \n    /// the performance of query execution (e.g., using\n    /// indexes).\n    query: func(c: borrow<connection>, q: borrow<statement>) -> result<list<row>, error>;\n    \n    /// exec is for modifying data in the database.\n    exec: func(c: borrow<connection>, q: borrow<statement>) -> result<u32, error>;\n}";
    const _: &[u8] = b"/// The producer interface is used to send messages to a channel/topic.\ninterface producer {\n    use types.{client, message, error, topic};\n\n    /// Sends the message using the given client.\n    send: async func(c: client, topic: topic, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"interface types {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n\n    /// A key-value pair describing an attribute.\n    record key-value {\n        /// The attribute name.\n        key: key,\n        /// The attribute value.\n        value: value,\n    }\n\n    /// The key part of attribute `key-value` pairs.\n    type key = string;\n\n    /// The value part of attribute `key-value` pairs.\n    variant value {\n        /// A string value.\n        %string(string),\n        /// A boolean value.\n        %bool(bool),\n        /// A double precision floating point value.\n        %f64(f64),\n        /// A signed 64 bit integer value.\n        %s64(s64),\n        /// A homogeneous array of string values.\n        string-array(list<string>),\n        /// A homogeneous array of boolean values.\n        bool-array(list<bool>),\n        /// A homogeneous array of double precision floating point values.\n        f64-array(list<f64>),\n        /// A homogeneous array of 64 bit integer values.\n        s64-array(list<s64>),\n    }\n\n    /// The host resource describing the entity producing telemetry.\n    record %resource {\n        /// Specifies the resource attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n    }\n\n    /// Describes the instrumentation scope that produced a span.\n    record instrumentation-scope {\n        /// Name of the instrumentation scope.\n        name: string,\n\n        /// The library version.\n        version: option<string>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n\n        /// Specifies the instrumentation scope attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n    }\n\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// Shutdown has already been invoked.\n        already-shutdown,\n\n        /// Operation timed out before completing.\n        timeout(u64),\n\n        /// Operation failed due to an internal error.\n        internal-failure(string)\n    }\n}\n";
    const _: &[u8] = b"package wasi:messaging@0.2.0-draft;\n\n/// The `imports` world defines the interfaces that the component will import from the host.\n/// It includes the `producer` interface for sending messages.\nworld imports {\n  import producer;\n}\n\n/// The `imports-request-reply` world extends `imports` by including the `request-reply` interface.\n/// This allows the component to perform request/reply messaging patterns.\nworld imports-request-reply {\n  include imports;\n  import request-reply;\n}\n\n/// The `messaging-request-reply` world combines `imports-request-reply` with the `incoming-handler`\n/// export. This setup allows the host to interact with the component for both sending messages and\n/// handling incoming messages with request/reply capabilities.\nworld messaging-request-reply {\n  include imports-request-reply;\n  export incoming-handler;\n}\n\n/// The `messaging-core` world includes the basic `imports` and exports the `incoming-handler`,\n/// enabling the component to handle incoming messages without request/reply capabilities.\nworld messaging-core {\n  include imports;\n  export incoming-handler;\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@unstable(feature = clocks-timezone)\ninterface timezone {\n    @unstable(feature = clocks-timezone)\n    use wall-clock.{datetime};\n\n    /// Return information needed to display the given `datetime`. This includes\n    /// the UTC offset, the time zone name, and a flag indicating whether\n    /// daylight saving time is active.\n    ///\n    /// If the timezone cannot be determined for the given `datetime`, return a\n    /// `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight\n    /// saving time.\n    @unstable(feature = clocks-timezone)\n    display: func(when: datetime) -> timezone-display;\n\n    /// The same as `display`, but only return the UTC offset.\n    @unstable(feature = clocks-timezone)\n    utc-offset: func(when: datetime) -> s32;\n\n    /// Information useful for displaying the timezone of a specific `datetime`.\n    ///\n    /// This information may vary within a single `timezone` to reflect daylight\n    /// saving time adjustments.\n    @unstable(feature = clocks-timezone)\n    record timezone-display {\n        /// The number of seconds difference between UTC time and the local\n        /// time of the timezone.\n        ///\n        /// The returned value will always be less than 86400 which is the\n        /// number of seconds in a day (24*60*60).\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return 0.\n        utc-offset: s32,\n\n        /// The abbreviated name of the timezone to display to a user. The name\n        /// `UTC` indicates Coordinated Universal Time. Otherwise, this should\n        /// reference local standards for the name of the time zone.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should be the string `UTC`.\n        ///\n        /// In time zones that do not have an applicable name, a formatted\n        /// representation of the UTC offset may be returned, such as `-04:00`.\n        name: string,\n\n        /// Whether daylight saving time is active.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return false.\n        in-daylight-saving-time: bool,\n    }\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\ninterface error {\n    /// A resource which represents some error information.\n    ///\n    /// The only method provided by this resource is `to-debug-string`,\n    /// which provides some human-readable information about the error.\n    ///\n    /// In the `wasi:io` package, this resource is returned through the\n    /// `wasi:io/streams/stream-error` type.\n    ///\n    /// To provide more specific error information, other interfaces may\n    /// offer functions to \"downcast\" this error into more specific types. For example,\n    /// errors returned from streams derived from filesystem types can be described using\n    /// the filesystem\'s own error-code type. This is done using the function\n    /// `wasi:filesystem/types/filesystem-error-code`, which takes a `borrow<error>`\n    /// parameter and returns an `option<wasi:filesystem/types/error-code>`.\n    ///\n    /// The set of functions which can \"downcast\" an `error` into a more\n    /// concrete type is open.\n    @since(version = 0.2.0)\n    resource error {\n        /// Returns a string that is suitable to assist humans in debugging\n        /// this error.\n        ///\n        /// WARNING: The returned string should not be consumed mechanically!\n        /// It may change across platforms, hosts, or other implementation\n        /// details. Parsing this string is a major platform-compatibility\n        /// hazard.\n        @since(version = 0.2.0)\n        to-debug-string: func() -> string;\n    }\n}\n";
    const _: &[u8] = b"/// The request-reply interface allows a guest to send a message and await a response. This\n/// interface is considered optional as not all message services support the concept of\n/// request/reply. However, request/reply is a very common pattern in messaging and as such, we have\n/// included it as a core interface.\ninterface request-reply {\n    use types.{client, message, error, topic};\n\n    /// Options for a request/reply operation. This is a resource to allow for future expansion of\n    /// options.\n    resource request-options {\n        /// Creates a new request options resource with no options set.\n        constructor();\n\n        /// The maximum amount of time to wait for a response. If the timeout value is not set, then\n        /// the request/reply operation will block until a message is received in response.\n        set-timeout-ms: func(timeout-ms: u32);\n\n        /// The maximum number of replies to expect before returning.\n        set-expected-replies: func(expected-replies: u32);\n    }\n\n    /// Performs a blocking request/reply operation with an optional set of request options. \n    /// \n    /// The behavior of this function is largely dependent on the options given to the function.\n    /// If no options are provided, then the request/reply operation will block until a single \n    /// message is received in response. If a timeout is provided, then the request/reply operation\n    /// will block for the specified amount of time before returning an error if no messages were\n    /// received (or the list of messages that were received). If both a timeout and an expected\n    /// number of replies are provided, the function should return when either condition is met\n    /// (whichever comes first)\xe2\x80\x94e.g., (1) if no replies were received within the timeout return an\n    /// error, (2) if the maximum expected number of replies were received before timeout, return\n    /// the list of messages, or (3) if the timeout is reached before the expected number of replies,\n    /// return the list of messages received up to that point.\n    request: func(c: borrow<client>, topic: topic, message: borrow<message>, options: option<request-options>) -> result<list<message>, error>;\n\n    /// Replies to the given message with the given response message. The details of which topic\n    /// the message is sent to is up to the implementation. This allows for reply-to details to be\n    /// handled in the best way possible for the underlying messaging system.\n    /// \n    /// Please note that this reply functionality is different than something like HTTP because there\n    /// are several use cases in which a reply might not be required for every message (so this would\n    /// be a noop). There are also cases when you might want to reply and then continue processing.\n    /// Additionally, you might want to reply to a message several times (such as providing an\n    /// update). So this function is allowed to be called multiple times, unlike something like HTTP\n    /// where the reply is sent and the connection is closed.\n    reply: func(reply-to: borrow<message>, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides eventually consistent key-value operations.\n/// \n/// Each of these operations acts on a single key-value pair.\n/// \n/// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is\n/// the common denominator for all data types defined by different key-value stores to handle data,\n/// ensuring compatibility between different key-value stores. Note: the clients will be expecting\n/// serialization/deserialization overhead to be handled by the key-value store. The value could be\n/// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.\n/// \n/// Data consistency in a key value store refers to the guarantee that once a write operation\n/// completes, all subsequent read operations will return the value that was written.\n/// \n/// Any implementation of this interface must have enough consistency to guarantee \"reading your\n/// writes.\" In particular, this means that the client should never get a value that is older than\n/// the one it wrote, but it MAY get a newer value if one was written around the same time. These\n/// guarantees only apply to the same client (which will likely be provided by the host or an\n/// external capability of some kind). In this context a \"client\" is referring to the caller or\n/// guest that is consuming this interface. Once a write request is committed by a specific client,\n/// all subsequent read requests by the same client will reflect that write or any subsequent\n/// writes. Another client running in a different context may or may not immediately see the result\n/// due to the replication lag. As an example of all of this, if a value at a given key is A, and\n/// the client writes B, then immediately reads, it should get B. If something else writes C in\n/// quick succession, then the client may get C. However, a client running in a separate context may\n/// still see A or B\ninterface store {\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// A response to a `list-keys` operation.\n    record key-response {\n        /// The list of keys returned by the query.\n        keys: list<string>,\n        /// The continuation token to use to fetch the next page of keys. If this is `null`, then\n        /// there are no more keys to fetch.\n        cursor: option<string>\n    }\n\n    /// Get the bucket with the specified identifier.\n    ///\n    /// `identifier` must refer to a bucket provided by the host.\n    ///\n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(identifier: string) -> result<bucket, error>;\n\n    /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the\n    /// bucket, and the bucket itself acts as a collection of all these entries.\n    ///\n    /// It is worth noting that the exact terminology for bucket in key-value stores can very\n    /// depending on the specific implementation. For example:\n    ///\n    /// 1. Amazon DynamoDB calls a collection of key-value pairs a table\n    /// 2. Redis has hashes, sets, and sorted sets as different types of collections\n    /// 3. Cassandra calls a collection of key-value pairs a column family\n    /// 4. MongoDB calls a collection of key-value pairs a collection\n    /// 5. Riak calls a collection of key-value pairs a bucket\n    /// 6. Memcached calls a collection of key-value pairs a slab\n    /// 7. Azure Cosmos DB calls a collection of key-value pairs a container\n    ///\n    /// In this interface, we use the term `bucket` to refer to a collection of key-value pairs\n    resource bucket {\n        /// Get the value associated with the specified `key`\n        ///\n        /// The value is returned as an option. If the key-value pair exists in the\n        /// store, it returns `Ok(value)`. If the key does not exist in the\n        /// store, it returns `Ok(none)`. \n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        get: func(key: string) -> result<option<list<u8>>, error>;\n\n        /// Set the value associated with the key in the store. If the key already\n        /// exists in the store, it overwrites the value.\n        ///\n        /// If the key does not exist in the store, it creates a new key-value pair.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        set: func(key: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the key-value pair associated with the key in the store.\n        /// \n        /// If the key does not exist in the store, it does nothing.\n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        delete: func(key: string) -> result<_, error>;\n\n        /// Check if the key exists in the store.\n        /// \n        /// If the key exists in the store, it returns `Ok(true)`. If the key does\n        /// not exist in the store, it returns `Ok(false)`.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        exists: func(key: string) -> result<bool, error>;\n\n        /// Get all the keys in the store with an optional cursor (for use in pagination). It\n        /// returns a list of keys. Please note that for most KeyValue implementations, this is a\n        /// can be a very expensive operation and so it should be used judiciously. Implementations\n        /// can return any number of keys in a single response, but they should never attempt to\n        /// send more data than is reasonable (i.e. on a small edge device, this may only be a few\n        /// KB, while on a large machine this could be several MB). Any response should also return\n        /// a cursor that can be used to fetch the next page of keys. See the `key-response` record\n        /// for more information.\n        /// \n        /// Note that the keys are not guaranteed to be returned in any particular order.\n        /// \n        /// If the store is empty, it returns an empty list.\n        /// \n        /// MAY show an out-of-date list of keys if there are concurrent writes to the store.\n        /// \n        /// If any error occurs, it returns an `Err(error)`.\n        list-keys: func(cursor: option<string>) -> result<key-response, error>;\n    }\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Wall Clock is a clock API intended to let users query the current\n/// time. The name \"wall\" makes an analogy to a \"clock on the wall\", which\n/// is not necessarily monotonic as it may be reset.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A wall clock is a clock which measures the date and time according to\n/// some external reference.\n///\n/// External references may be reset, so this clock is not necessarily\n/// monotonic, making it unsuitable for measuring elapsed time.\n///\n/// It is intended for reporting the current date and time for humans.\n@since(version = 0.2.0)\ninterface wall-clock {\n    /// A time and date in seconds plus nanoseconds.\n    @since(version = 0.2.0)\n    record datetime {\n        seconds: u64,\n        nanoseconds: u32,\n    }\n\n    /// Read the current value of the clock.\n    ///\n    /// This clock is not monotonic, therefore calling this function repeatedly\n    /// will not necessarily produce a sequence of non-decreasing values.\n    ///\n    /// The returned timestamps represent the number of seconds since\n    /// 1970-01-01T00:00:00Z, also known as [POSIX\'s Seconds Since the Epoch],\n    /// also known as [Unix Time].\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    ///\n    /// [POSIX\'s Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16\n    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time\n    @since(version = 0.2.0)\n    now: func() -> datetime;\n\n    /// Query the resolution of the clock.\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    @since(version = 0.2.0)\n    resolution: func() -> datetime;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides atomic operations.\n/// \n/// Atomic operations are single, indivisible operations. When a fault causes an atomic operation to\n/// fail, it will appear to the invoker of the atomic operation that the action either completed\n/// successfully or did nothing at all.\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface atomics {\n  \tuse store.{bucket, error};\n\n\t/// The error returned by a CAS operation\n\tvariant cas-error {\n\t\t/// A store error occurred when performing the operation\n\t\tstore-error(error),\n\t\t/// The CAS operation failed because the value was too old. This returns a new CAS handle\n\t\t/// for easy retries. Implementors MUST return a CAS handle that has been updated to the\n\t\t/// latest version or transaction.\n\t\tcas-failed(cas),\n\t}\n\n\t/// A handle to a CAS (compare-and-swap) operation.\n\tresource cas {\n\t\t/// Construct a new CAS operation. Implementors can map the underlying functionality\n\t\t/// (transactions, versions, etc) as desired.\n\t\tnew: static func(bucket: borrow<bucket>, key: string) -> result<cas, error>;\n\t\t/// Get the current value of the key (if it exists). This allows for avoiding reads if all\n\t\t/// that is needed to ensure the atomicity of the operation\n\t\tcurrent: func() -> result<option<list<u8>>, error>;\n\t}\n\n  \t/// Atomically increment the value associated with the key in the store by the given delta. It\n\t/// returns the new value.\n\t///\n\t/// If the key does not exist in the store, it creates a new key-value pair with the value set\n\t/// to the given delta. \n\t///\n\t/// If any other error occurs, it returns an `Err(error)`.\n\tincrement: func(bucket: borrow<bucket>, key: string, delta: s64) -> result<s64, error>;\n\n\t/// Perform the swap on a CAS operation. This consumes the CAS handle and returns an error if\n\t/// the CAS operation failed.\n\tswap: func(cas: cas, value: list<u8>) -> result<_, cas-error>;\n}";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// A poll API intended to let users wait for I/O events on multiple handles\n/// at once.\n@since(version = 0.2.0)\ninterface poll {\n    /// `pollable` represents a single I/O event which may be ready, or not.\n    @since(version = 0.2.0)\n    resource pollable {\n\n        /// Return the readiness of a pollable. This function never blocks.\n        ///\n        /// Returns `true` when the pollable is ready, and `false` otherwise.\n        @since(version = 0.2.0)\n        ready: func() -> bool;\n\n        /// `block` returns immediately if the pollable is ready, and otherwise\n        /// blocks until ready.\n        ///\n        /// This function is equivalent to calling `poll.poll` on a list\n        /// containing only this pollable.\n        @since(version = 0.2.0)\n        block: func();\n    }\n\n    /// Poll for completion on a set of pollables.\n    ///\n    /// This function takes a list of pollables, which identify I/O sources of\n    /// interest, and waits until one or more of the events is ready for I/O.\n    ///\n    /// The result `list<u32>` contains one or more indices of handles in the\n    /// argument list that is ready for I/O.\n    ///\n    /// This function traps if either:\n    /// - the list is empty, or:\n    /// - the list contains more elements than can be indexed with a `u32` value.\n    ///\n    /// A timeout can be implemented by adding a pollable from the\n    /// wasi-clocks API to the list.\n    ///\n    /// This function does not return a `result`; polling in itself does not\n    /// do any I/O so it doesn\'t fail. If any of the I/O sources identified by\n    /// the pollables has an error, it is indicated by marking the source as\n    /// being ready for I/O.\n    @since(version = 0.2.0)\n    poll: func(in: list<borrow<pollable>>) -> list<u32>;\n}\n";
    const _: &[u8] = b"package wasi:sql@0.2.0-draft;\n\nworld imports {\n\timport readwrite;\n}";
    const _: &[u8] = b"interface types {\n    /// one single row item\n    record row {\n        field-name: string,\n        value: data-type,\n    }\n    \n    /// common data types\n    variant data-type {\n        int32(s32),\n        int64(s64),\n        uint32(u32),\n        uint64(u64),\n        float(f64),\n        double(f64),\n        str(string),\n        boolean(bool),\n        date(string),\n        time(string),\n        timestamp(string),\n        binary(list<u8>),\n        null\n    }\n\n    /// allows parameterized queries\n    /// e.g., prepare(\"SELECT * FROM users WHERE name = ? AND age = ?\", vec![\"John Doe\", \"32\"])\n    resource statement {\n        prepare: static func(query: string, params: list<string>) -> result<statement, error>;\n    }\n    /// An error resource type.\n    /// Currently, this provides only one function to return a string representation\n    /// of the error. In the future, this will be extended to provide more information.\n    resource error {\n\t\ttrace: func() -> string;\n  \t}\n    \n    /// A connection to a sql store.\n    resource connection {\n        open: static func(name: string) -> result<connection, error>;\n    }\n}";
    const _: &[u8] = b"package wasi:blobstore@0.2.0-draft;\n\nworld imports {\n\timport blobstore;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides batch operations.\n/// \n/// A batch operation is an operation that operates on multiple keys at once.\n/// \n/// Batch operations are useful for reducing network round-trip time. For example, if you want to\n/// get the values associated with 100 keys, you can either do 100 get operations or you can do 1\n/// batch get operation. The batch operation is faster because it only needs to make 1 network call\n/// instead of 100.\n/// \n/// A batch operation does not guarantee atomicity, meaning that if the batch operation fails, some\n/// of the keys may have been modified and some may not. \n/// \n/// This interface does has the same consistency guarantees as the `store` interface, meaning that\n/// you should be able to \"read your writes.\"\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface batch {\n    use store.{bucket, error};\n\n    /// Get the key-value pairs associated with the keys in the store. It returns a list of\n    /// key-value pairs.\n    ///\n    /// If any of the keys do not exist in the store, it returns a `none` value for that pair in the\n    /// list.\n    /// \n    /// MAY show an out-of-date value if there are concurrent writes to the store.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`.\n    get-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<list<option<tuple<string, list<u8>>>>, error>;\n\n    /// Set the values associated with the keys in the store. If the key already exists in the\n    /// store, it overwrites the value. \n    /// \n    /// Note that the key-value pairs are not guaranteed to be set in the order they are provided. \n    ///\n    /// If any of the keys do not exist in the store, it creates a new key-value pair.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already set. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be set while others might\n    /// fail. \n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    set-many: func(bucket: borrow<bucket>, key-values: list<tuple<string, list<u8>>>) -> result<_, error>;\n\n    /// Delete the key-value pairs associated with the keys in the store.\n    /// \n    /// Note that the key-value pairs are not guaranteed to be deleted in the order they are\n    /// provided.\n    /// \n    /// If any of the keys do not exist in the store, it skips the key.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already deleted. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be deleted while others might\n    /// fail.\n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    delete-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<_, error>;\n}\n";
    const _: &[u8] = b"interface %resource {\n    use types.{key, value, key-value, %resource as telemetry-resource};\n\n    /// Returns the telemetry resource used by the host.\n    %resource: func() -> telemetry-resource;\n}\n";
    const _: &[u8] = b"package wasi:keyvalue@0.2.0-draft2;\n\n/// The `wasi:keyvalue/imports` world provides common APIs for interacting with key-value stores.\n/// Components targeting this world will be able to do:\n/// \n/// 1. CRUD (create, read, update, delete) operations on key-value stores.\n/// 2. Atomic `increment` and CAS (compare-and-swap) operations.\n/// 3. Batch operations that can reduce the number of round trips to the network.\nworld imports {\n\t/// The `store` capability allows the component to perform eventually consistent operations on\n\t/// the key-value store.\n\timport store;\n\n\t/// The `atomic` capability allows the component to perform atomic / `increment` and CAS\n\t/// (compare-and-swap) operations.\n\timport atomics;\n\n\t/// The `batch` capability allows the component to perform eventually consistent batch\n\t/// operations that can reduce the number of round trips to the network.\n\timport batch;\n}\n\nworld watch-service {\n\tinclude imports;\n\texport watcher;\n}";
    const _: &[u8] = b"interface incoming-handler {\n    use types.{message, error, topic};\n\n    /// Whenever this guest receives a message in one of the subscribed topics, the message is\n    /// sent to this handler. The guest is responsible for matching on the topic and handling the\n    /// message accordingly. Implementors (such as hosts) calling this interface should make their\n    /// own decisions on how to handle errors returned from this function.\n    handle: async func(message: message) -> result<_, error>;\n\n\n    /// Server configuration.\n    ///\n    /// This can be extended to include other configuration options in the\n    /// future.\n    record configuration {\n        /// Subscription topics\n        topics: list<topic>,\n    }\n\n    /// Configure is called by the runtime to get the server\'s runtime\n    /// configuration.\n    configure: async func() -> result<configuration, error>;\n\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import streams;\n\n    @since(version = 0.2.0)\n    import poll;\n}\n";
    const _: &[u8] = b"// Types used by blobstore\ninterface types {\n  use wasi:io/streams@0.2.6.{input-stream, output-stream};\n\n  // name of a container, a collection of objects.\n  // The container name may be any valid UTF-8 string.\n  type container-name = string;\n\n  // name of an object within a container\n  // The object name may be any valid UTF-8 string.\n  type object-name = string;\n\n  // TODO: define timestamp to include seconds since\n  // Unix epoch and nanoseconds\n  // https://github.com/WebAssembly/wasi-blob-store/issues/7\n  type timestamp = u64;\n\n  // size of an object, in bytes\n  type object-size = u64;\n\n  type error = string;\n\n  // information about a container\n  record container-metadata {\n    // the container\'s name\n    name: container-name,\n    // date and time container was created\n    created-at: timestamp,\n  }\n\n  // information about an object\n  record object-metadata {\n    // the object\'s name\n    name: object-name,\n    // the object\'s parent container\n    container: container-name,\n    // date and time the object was created\n    created-at: timestamp,\n    // size of the object, in bytes\n    size: object-size,\n  }\n\n  // identifier for an object that includes its container name\n  record object-id {\n    container: container-name,\n    object: object-name\n  }\n\n  /// A data is the data stored in a data blob. The value can be of any type\n  /// that can be represented in a byte array. It provides a way to write the value\n  /// to the output-stream defined in the `wasi-io` interface.\n  // Soon: switch to `resource value { ... }`\n  resource outgoing-value {\n    new-outgoing-value: static func() -> outgoing-value;\n\n    /// Returns a stream for writing the value contents.\n    ///\n    /// The returned `output-stream` is a child resource: it must be dropped\n    /// before the parent `outgoing-value` resource is dropped (or finished),\n    /// otherwise the `outgoing-value` drop or `finish` will trap.\n    ///\n    /// Returns success on the first call: the `output-stream` resource for\n    /// this `outgoing-value` may be retrieved at most once. Subsequent calls\n    /// will return error.\n    outgoing-value-write-body: func() -> result<output-stream, error>;\n\n    /// Finalize an outgoing value. This must be\n    /// called to signal that the outgoing value is complete. If the `outgoing-value`\n    /// is dropped without calling `outgoing-value.finalize`, the implementation\n    /// should treat the value as corrupted.\n    finish: static func(this: outgoing-value) -> result<_, error>;\n  }\n\n  /// A incoming-value is a wrapper around a value. It provides a way to read the value\n  /// from the input-stream defined in the `wasi-io` interface.\n  ///\n  /// The incoming-value provides two ways to consume the value:\n  /// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the\n  ///    value as a list of bytes.\n  /// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the\n  ///    value as an input-stream.\n  // Soon: switch to `resource incoming-value { ... }`\n  resource incoming-value {\n      incoming-value-consume-sync: static func(this: incoming-value) -> result<incoming-value-sync-body, error>;\n      incoming-value-consume-async: static func(this: incoming-value) -> result<incoming-value-async-body, error>;\n      size: func() -> u64;\n  }\n\n  type incoming-value-async-body = input-stream;\n  type incoming-value-sync-body = list<u8>;\n}\n";
    const _: &[u8] = b"interface vault {\n    /// An error type that encapsulates the different errors that can occur fetching secrets\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// Open the specified locker.\n    /// \n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(locker-id: string) -> result<locker, error>;\n\n    /// A locker contains collection of related secrets.\n    resource locker {\n        /// Get the specified secret.\n        ///\n        /// Returns `none` if the specified secret does not exist.\n        get: func(secret-id: string) -> result<option<list<u8>>, error>;\n\n        /// Store a secret in the vault. If the `id` already exists, the\n        /// secret will be overwritten.\n        set: func(secret-id: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the specified secret.\n        /// \n        /// Will do nothing if the secret does not exist.\n        delete: func(secret-id: string) -> result<_, error>;\n\n        /// Check if the specified secret exists.\n        exists: func(secret-id: string) -> result<bool, error>;\n\n        /// List all `secret-id`s in the locker.\n        list-ids: func() -> result<list<string>, error>;\n    }\n}";
    const _: &[u8] = b"package wasmgrid:service;\n\nworld blobstore {\n\tinclude wasi:blobstore/imports@0.2.0-draft;\n}\n\nworld keyvalue {\n\tinclude wasi:keyvalue/watch-service@0.2.0-draft2;\n}\n\nworld messaging {\n\tinclude wasi:messaging/messaging-request-reply@0.2.0-draft;\n}\n\nworld otel {\n\tinclude wasi:otel/imports@0.2.0-draft;\n}\n\nworld sql {\n\tinclude wasi:sql/imports@0.2.0-draft;\n}\n\nworld vault {\n\tinclude wasi:vault/imports@0.1.0-draft;\n}";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Monotonic Clock is a clock API intended to let users measure elapsed\n/// time.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A monotonic clock is a clock which has an unspecified initial value, and\n/// successive reads of the clock will produce non-decreasing values.\n@since(version = 0.2.0)\ninterface monotonic-clock {\n    @since(version = 0.2.0)\n    use wasi:io/poll@0.2.6.{pollable};\n\n    /// An instant in time, in nanoseconds. An instant is relative to an\n    /// unspecified initial value, and can only be compared to instances from\n    /// the same monotonic-clock.\n    @since(version = 0.2.0)\n    type instant = u64;\n\n    /// A duration of time, in nanoseconds.\n    @since(version = 0.2.0)\n    type duration = u64;\n\n    /// Read the current value of the clock.\n    ///\n    /// The clock is monotonic, therefore calling this function repeatedly will\n    /// produce a sequence of non-decreasing values.\n    @since(version = 0.2.0)\n    now: func() -> instant;\n\n    /// Query the resolution of the clock. Returns the duration of time\n    /// corresponding to a clock tick.\n    @since(version = 0.2.0)\n    resolution: func() -> duration;\n\n    /// Create a `pollable` which will resolve once the specified instant\n    /// has occurred.\n    @since(version = 0.2.0)\n    subscribe-instant: func(\n        when: instant,\n    ) -> pollable;\n\n    /// Create a `pollable` that will resolve after the specified duration has\n    /// elapsed from the time this function is invoked.\n    @since(version = 0.2.0)\n    subscribe-duration: func(\n        when: duration,\n    ) -> pollable;\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// WASI I/O is an I/O abstraction API which is currently focused on providing\n/// stream types.\n///\n/// In the future, the component model is expected to add built-in stream types;\n/// when it does, they are expected to subsume this API.\n@since(version = 0.2.0)\ninterface streams {\n    @since(version = 0.2.0)\n    use error.{error};\n    @since(version = 0.2.0)\n    use poll.{pollable};\n\n    /// An error for input-stream and output-stream operations.\n    @since(version = 0.2.0)\n    variant stream-error {\n        /// The last operation (a write or flush) failed before completion.\n        ///\n        /// More information is available in the `error` payload.\n        ///\n        /// After this, the stream will be closed. All future operations return\n        /// `stream-error::closed`.\n        last-operation-failed(error),\n        /// The stream is closed: no more input will be accepted by the\n        /// stream. A closed output-stream will return this error on all\n        /// future operations.\n        closed\n    }\n\n    /// An input bytestream.\n    ///\n    /// `input-stream`s are *non-blocking* to the extent practical on underlying\n    /// platforms. I/O operations always return promptly; if fewer bytes are\n    /// promptly available than requested, they return the number of bytes promptly\n    /// available, which could even be zero. To wait for data to be available,\n    /// use the `subscribe` function to obtain a `pollable` which can be polled\n    /// for using `wasi:io/poll`.\n    @since(version = 0.2.0)\n    resource input-stream {\n        /// Perform a non-blocking read from the stream.\n        ///\n        /// When the source of a `read` is binary data, the bytes from the source\n        /// are returned verbatim. When the source of a `read` is known to the\n        /// implementation to be text, bytes containing the UTF-8 encoding of the\n        /// text are returned.\n        ///\n        /// This function returns a list of bytes containing the read data,\n        /// when successful. The returned list will contain up to `len` bytes;\n        /// it may return fewer than requested, but not more. The list is\n        /// empty when no bytes are available for reading at this time. The\n        /// pollable given by `subscribe` will be ready when more bytes are\n        /// available.\n        ///\n        /// This function fails with a `stream-error` when the operation\n        /// encounters an error, giving `last-operation-failed`, or when the\n        /// stream is closed, giving `closed`.\n        ///\n        /// When the caller gives a `len` of 0, it represents a request to\n        /// read 0 bytes. If the stream is still open, this call should\n        /// succeed and return an empty list, or otherwise fail with `closed`.\n        ///\n        /// The `len` parameter is a `u64`, which could represent a list of u8 which\n        /// is not possible to allocate in wasm32, or not desirable to allocate as\n        /// as a return value by the callee. The callee may return a list of bytes\n        /// less than `len` in size while more bytes are available for reading.\n        @since(version = 0.2.0)\n        read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Read bytes from a stream, after blocking until at least one byte can\n        /// be read. Except for blocking, behavior is identical to `read`.\n        @since(version = 0.2.0)\n        blocking-read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Skip bytes from a stream. Returns number of bytes skipped.\n        ///\n        /// Behaves identical to `read`, except instead of returning a list\n        /// of bytes, returns the number of bytes consumed from the stream.\n        @since(version = 0.2.0)\n        skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Skip bytes from a stream, after blocking until at least one byte\n        /// can be skipped. Except for blocking behavior, identical to `skip`.\n        @since(version = 0.2.0)\n        blocking-skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Create a `pollable` which will resolve once either the specified stream\n        /// has bytes available to read or the other end of the stream has been\n        /// closed.\n        /// The created `pollable` is a child resource of the `input-stream`.\n        /// Implementations may trap if the `input-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n    }\n\n\n    /// An output bytestream.\n    ///\n    /// `output-stream`s are *non-blocking* to the extent practical on\n    /// underlying platforms. Except where specified otherwise, I/O operations also\n    /// always return promptly, after the number of bytes that can be written\n    /// promptly, which could even be zero. To wait for the stream to be ready to\n    /// accept data, the `subscribe` function to obtain a `pollable` which can be\n    /// polled for using `wasi:io/poll`.\n    ///\n    /// Dropping an `output-stream` while there\'s still an active write in\n    /// progress may result in the data being lost. Before dropping the stream,\n    /// be sure to fully flush your writes.\n    @since(version = 0.2.0)\n    resource output-stream {\n        /// Check readiness for writing. This function never blocks.\n        ///\n        /// Returns the number of bytes permitted for the next call to `write`,\n        /// or an error. Calling `write` with more bytes than this function has\n        /// permitted will trap.\n        ///\n        /// When this function returns 0 bytes, the `subscribe` pollable will\n        /// become ready when this function will report at least 1 byte, or an\n        /// error.\n        @since(version = 0.2.0)\n        check-write: func() -> result<u64, stream-error>;\n\n        /// Perform a write. This function never blocks.\n        ///\n        /// When the destination of a `write` is binary data, the bytes from\n        /// `contents` are written verbatim. When the destination of a `write` is\n        /// known to the implementation to be text, the bytes of `contents` are\n        /// transcoded from UTF-8 into the encoding of the destination and then\n        /// written.\n        ///\n        /// Precondition: check-write gave permit of Ok(n) and contents has a\n        /// length of less than or equal to n. Otherwise, this function will trap.\n        ///\n        /// returns Err(closed) without writing if the stream has closed since\n        /// the last call to check-write provided a permit.\n        @since(version = 0.2.0)\n        write: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 bytes, and then flush the stream. Block\n        /// until all of these operations are complete, or an error occurs.\n        ///\n        /// Returns success when all of the contents written are successfully\n        /// flushed to output. If an error occurs at any point before all\n        /// contents are successfully flushed, that error is returned as soon as\n        /// possible. If writing and flushing the complete contents causes the\n        /// stream to become closed, this call should return success, and\n        /// subsequent calls to check-write or other interfaces should return\n        /// stream-error::closed.\n        @since(version = 0.2.0)\n        blocking-write-and-flush: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Request to flush buffered output. This function never blocks.\n        ///\n        /// This tells the output-stream that the caller intends any buffered\n        /// output to be flushed. the output which is expected to be flushed\n        /// is all that has been passed to `write` prior to this call.\n        ///\n        /// Upon calling this function, the `output-stream` will not accept any\n        /// writes (`check-write` will return `ok(0)`) until the flush has\n        /// completed. The `subscribe` pollable will become ready when the\n        /// flush has completed and the stream can accept more writes.\n        @since(version = 0.2.0)\n        flush: func() -> result<_, stream-error>;\n\n        /// Request to flush buffered output, and block until flush completes\n        /// and stream is ready for writing again.\n        @since(version = 0.2.0)\n        blocking-flush: func() -> result<_, stream-error>;\n\n        /// Create a `pollable` which will resolve once the output-stream\n        /// is ready for more writing, or an error has occurred. When this\n        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an\n        /// error.\n        ///\n        /// If the stream is closed, this pollable is always ready immediately.\n        ///\n        /// The created `pollable` is a child resource of the `output-stream`.\n        /// Implementations may trap if the `output-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n\n        /// Write zeroes to a stream.\n        ///\n        /// This should be used precisely like `write` with the exact same\n        /// preconditions (must use check-write first), but instead of\n        /// passing a list of bytes, you simply pass the number of zero-bytes\n        /// that should be written.\n        @since(version = 0.2.0)\n        write-zeroes: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 zeroes, and then flush the stream.\n        /// Block until all of these operations are complete, or an error\n        /// occurs.\n        ///\n        /// Functionality is equivelant to `blocking-write-and-flush` with\n        /// contents given as a list of len containing only zeroes.\n        @since(version = 0.2.0)\n        blocking-write-zeroes-and-flush: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Read from one stream and write to another.\n        ///\n        /// The behavior of splice is equivalent to:\n        /// 1. calling `check-write` on the `output-stream`\n        /// 2. calling `read` on the `input-stream` with the smaller of the\n        /// `check-write` permitted length and the `len` provided to `splice`\n        /// 3. calling `write` on the `output-stream` with that read data.\n        ///\n        /// Any error reported by the call to `check-write`, `read`, or\n        /// `write` ends the splice and reports that error.\n        ///\n        /// This function returns the number of bytes transferred; it may be less\n        /// than `len`.\n        @since(version = 0.2.0)\n        splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Read from one stream and write to another, with blocking.\n        ///\n        /// This is similar to `splice`, except that it blocks until the\n        /// `output-stream` is ready for writing, and the `input-stream`\n        /// is ready for reading, before performing the `splice`.\n        @since(version = 0.2.0)\n        blocking-splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n    }\n}\n";
    const _: &[u8] = b"interface types {\n    /// A type alias for list<tuple<string, string>> to represent metadata attached to a message\n    type metadata = list<tuple<string, string>>;\n\n    /// A type alias for string to represent a message topic\n    type topic = string;\n\n    /// A connection to a message-exchange service (e.g., buffer, broker, etc.).\n    resource client {\n        connect: static func(name: string) -> result<client, error>;\n        disconnect: func() -> result<_, error>;\n    }\n\n    /// Errors that can occur when using the messaging interface.\n    variant error {\n        /// The request or operation timed out.\n        timeout,\n        /// An error occurred with the connection. Includes a message for additional context\n        connection(string),\n        /// A permission error occurred. Includes a message for additional context\n        permission-denied(string),\n        /// A catch all for other types of errors\n        other(string),\n    }\n\n    /// A message with a binary payload and additional information\n    resource message {\n        constructor(data: list<u8>);\n        // new: static func(data: stream<u8>) -> message;\n\n        /// The topic/subject/channel this message was received on, if any\n        topic: func() -> option<topic>;\n        /// An optional content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        content-type: func() -> option<string>;\n        /// Set the content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        set-content-type: func(content-type: string);\n        /// An opaque blob of data\n        data: func() -> list<u8>;\n        /// Set the opaque blob of data for this message, discarding the old value\n        set-data: func(data: list<u8>);\n        /// Optional metadata (also called headers or attributes in some systems) attached to the\n        /// message. This metadata is simply decoration and should not be interpreted by a host\n        /// to ensure portability across different implementors (e.g., Kafka -> NATS, etc.).\n        metadata: func() -> option<metadata>;\n        /// Add a new key-value pair to the metadata, overwriting any existing value for the same key\n        add-metadata: func(key: string, value: string);\n        /// Set the metadata\n        set-metadata: func(meta: metadata);\n        /// Remove a key-value pair from the metadata\n        remove-metadata: func(key: string);\n    }\n}\n";
    const _: &[u8] = b"package wasi:vault@0.1.0-draft;\n\nworld imports {\n  import vault;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides watch operations.\n/// \n/// This interface is used to provide event-driven mechanisms to handle\n/// keyvalue changes.\ninterface watcher {\n\t/// A keyvalue interface that provides handle-watch operations.\n\tuse store.{bucket};\n\n\t/// Handle the `set` event for the given bucket and key. It includes a reference to the `bucket`\n\t/// that can be used to interact with the store.\n\ton-set: func(bucket: bucket, key: string, value: list<u8>);\n\n\t/// Handle the `delete` event for the given bucket and key. It includes a reference to the\n\t/// `bucket` that can be used to interact with the store.\n\ton-delete: func(bucket: bucket, key: string);\n}";
    const _: &[u8] = b"interface metrics {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, %resource, error};\n\n    /// Gathers and returns all metric data related to the [MetricReader] from the\n    /// SDK and stores it in the provided [ResourceMetrics] reference.\n    ///\n    /// An error is returned if this is called after shutdown.\n    %export: func(rm: resource-metrics) -> result<_, error>;\n\n    /// A collection of scope metrics and the associated resource that created them.\n    record resource-metrics {\n        /// The entity that collected the metrics.\n        %resource: %resource,\n\n        /// The collection of metrics with unique [InstrumentationScope]s.\n        scope-metrics: list<scope-metrics>,\n    }\n\n    record scope-metrics {\n        /// The instrumentation scope that the meter was created with.\n        scope: instrumentation-scope,\n\n        /// The list of aggregations created by the meter.\n        metrics: list<metric>,\n    }\n\n    /// A collection of one or more aggregated time series from an [Instrument].\n    ///\n    /// [Instrument]: crate::metrics::Instrument\n    record metric {\n        /// The name of the instrument that created this data.\n        name: string,\n\n        /// The description of the instrument, which can be used in documentation.\n        description: string,\n\n        /// The unit in which the instrument reports.\n        unit: string,\n\n        /// The aggregated data from an instrument.\n        data: aggregated-metrics,\n    }\n\n    /// Aggregated metrics data from an instrument\n    variant aggregated-metrics {\n        /// All metric data with `f64` value type\n        %f64(metric-data),\n\n        /// All metric data with `u64` value type\n        %u64(metric-data),\n\n        /// All metric data with `i64` value type\n        %s64(metric-data),\n    }\n\n    /// Metric data for all types\n    variant metric-data {\n        /// Metric data for Gauge\n        gauge(gauge),\n\n        /// Metric data for Sum\n        sum(sum),\n\n        /// Metric data for Histogram\n        histogram(histogram),\n\n        /// Metric data for ExponentialHistogram\n        exponential-histogram(exponential-histogram),\n    }\n\n    /// A measurement of the current value of an instrument.\n    record gauge {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<gauge-data-point>,\n\n        /// The time when the time series was started.\n        start-time: option<datetime>,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record gauge-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the sum of all measurements of values from an instrument.\n    record sum {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<sum-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n\n        /// Whether this aggregation only increases or decreases.\n        is-monotonic: bool,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record sum-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the histogram of all measurements of values from an instrument.\n    record histogram {\n        /// Individual aggregated measurements with unique attributes.\n        data-points: list<histogram-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single histogram data point in a time series.\n    record histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The upper bounds of the buckets of the histogram.\n        ///\n        /// Because the last boundary is +infinity this one is implied.\n        bounds: list<f64>,\n\n        /// The count of each of the buckets.\n        bucket-counts: list<u64>,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// The histogram of all measurements of values from an instrument.\n    record exponential-histogram {\n        /// The individual aggregated measurements with unique attributes.\n        data-points: list<exponential-histogram-data-point>,\n\n        /// When the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single exponential histogram data point in a time series.\n    record exponential-histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// Describes the resolution of the histogram.\n        ///\n        /// Boundaries are located at powers of the base, where:\n        ///\n        ///   base = 2 ^ (2 ^ -scale)\n        scale: s8,\n\n        /// The number of values whose absolute value is less than or equal to\n        /// `zero_threshold`.\n        ///\n        /// When `zero_threshold` is `0`, this is the number of values that cannot be\n        /// expressed using the standard exponential formula as well as values that have\n        /// been rounded to zero.\n        zero-count: u64,\n\n        /// The range of positive value bucket counts.\n        positive-bucket: exponential-bucket,\n\n        /// The range of negative value bucket counts.\n        negative-bucket: exponential-bucket,\n\n        /// The width of the zero region.\n        ///\n        /// Where the zero region is defined as the closed interval\n        /// [-zero_threshold, zero_threshold].\n        zero-threshold: f64,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// A set of bucket counts, encoded in a contiguous array of counts.\n    record exponential-bucket {\n        /// The bucket index of the first entry in the `counts` vec.\n        offset: s32,\n\n        /// A vec where `counts[i]` carries the count of the bucket at index `offset + i`.\n        ///\n        /// `counts[i]` is the count of values greater than base^(offset+i) and less than\n        /// or equal to base^(offset+i+1).\n        counts: list<u64>,\n    }\n\n    /// Defines the window that an aggregation was calculated over.\n    enum temporality {\n        /// A measurement interval that continues to expand forward in time from a\n        /// starting point.\n        ///\n        /// New measurements are added to all previous measurements since a start time.\n        cumulative,\n\n        /// A measurement interval that resets each cycle.\n        ///\n        /// Measurements from one cycle are recorded independently, measurements from\n        /// other cycles do not affect them.\n        delta,\n\n        /// Configures Synchronous Counter and Histogram instruments to use\n        /// Delta aggregation temporality, which allows them to shed memory\n        /// following a cardinality explosion, thus use less memory.\n        low-memory,\n    }\n\n    /// A measurement sampled from a time series providing a typical example.\n    record exemplar {\n        /// The attributes recorded with the measurement but filtered out of the\n        /// time series\' aggregated data.\n        filtered-attributes: list<key-value>,\n\n        /// The time when the measurement was recorded.\n        time: datetime,\n\n        /// The measured value.\n        value: data-value,\n\n        /// The ID of the span that was active during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        span-id: string,\n\n        /// The ID of the trace the active span belonged to during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        trace-id: string,\n    }\n\n    variant data-value {\n        /// All metric data with `f64` value type\n        %f64(f64),\n\n        /// All metric data with `u64` value type\n        %u64(u64),\n\n        /// All metric data with `s64` value type\n        %s64(s64),\n    }\n\n\n    /// The identifier of a group of instruments that all perform the same function.\n    enum instrument-kind {\n        /// Identifies a group of instruments that record increasing values synchronously\n        /// with the code path they are measuring.\n        counter,\n\n        /// A group of instruments that record increasing and decreasing values\n        /// synchronously with the code path they are measuring.\n        up-down-counter,\n\n        /// A group of instruments that record a distribution of values synchronously with\n        /// the code path they are measuring.\n        histogram,\n\n        /// A group of instruments that record increasing values in an asynchronous\n        /// callback.\n        observable-counter,\n\n        /// A group of instruments that record increasing and decreasing values in an\n        /// asynchronous callback.\n        observable-up-down-counter,\n\n        /// a group of instruments that record current value synchronously with\n        /// the code path they are measuring.\n        gauge,\n\n        /// a group of instruments that record current values in an asynchronous callback.\n        observable-gauge,\n    }\n}\n";
    const _: &[u8] = b"// a Container is a collection of objects\ninterface container {\n  use wasi:io/streams@0.2.6.{\n    input-stream,\n    output-stream,\n  };\n\n  use types.{\n    container-metadata,\n    error,\n    incoming-value,\n    object-metadata,\n    object-name,\n    outgoing-value,\n  };\n\n  // this defines the `container` resource\n  resource container {\n    // returns container name\n    name: func() -> result<string, error>;\n\n    // returns container metadata\n    info: func() -> result<container-metadata, error>;\n\n    // retrieves an object or portion of an object, as a resource.\n    // Start and end offsets are inclusive.\n    // Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime\n    // of the data-blob resource, even if the object they came from is later deleted.\n    get-data: func(name: object-name, start: u64, end: u64) -> result<incoming-value, error>;\n\n    // creates or replaces an object with the data blob.\n    write-data: func(name: object-name, data: borrow<outgoing-value>) -> result<_, error>;\n\n    // returns list of objects in the container. Order is undefined.\n    list-objects: func() -> result<stream-object-names, error>;\n\n    // deletes object.\n    // does not return error if object did not exist.\n    delete-object: func(name: object-name) -> result<_, error>;\n\n    // deletes multiple objects in the container\n    delete-objects: func(names: list<object-name>) -> result<_, error>;\n\n    // returns true if the object exists in this container\n    has-object: func(name: object-name) -> result<bool, error>;\n\n    // returns metadata for the object\n    object-info: func(name: object-name) -> result<object-metadata, error>;\n\n    // removes all objects within the container, leaving the container empty.\n    clear: func() -> result<_, error>;\n  }\n\n  // this defines the `stream-object-names` resource which is a representation of stream<object-name>\n  resource stream-object-names {\n    // reads the next number of objects from the stream\n    //\n    // This function returns the list of objects read, and a boolean indicating if the end of the stream was reached.\n    read-stream-object-names: func(len: u64) -> result<tuple<list<object-name>, bool>, error>;\n\n    // skip the next number of objects in the stream\n    //\n    // This function returns the number of objects skipped, and a boolean indicating if the end of the stream was reached.\n    skip-stream-object-names: func(num: u64) -> result<tuple<u64, bool>, error>;\n  }\n}\n";
    const _: &[u8] = b"interface tracing {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, error};\n\n    /// Returns the current span context of the host.\n    context: func() -> span-context;\n\n    /// Called by the guest to export spans.\n    %export: func(span: list<span-data>) -> result<_, error>;\n\n    /// The data associated with a span.\n    record span-data {\n        /// Span context.\n        span-context: span-context,\n        /// Span parent id.\n        parent-span-id: string,\n        /// Span kind.\n        span-kind: span-kind,\n        // Span name.\n        name: string,\n        /// Span start time.\n        start-time: datetime,\n        /// Span end time.\n        end-time: datetime,\n        /// Span attributes.\n        attributes: list<key-value>,\n        /// Span events.\n        events: list<event>,\n        /// Span Links.\n        links: list<link>,\n        /// Span status.\n        status: status,\n        /// Instrumentation scope that produced this span.\n        instrumentation-scope: instrumentation-scope,\n        /// Number of attributes dropped by the span due to limits being reached.\n        dropped-attributes: u32,\n        /// Number of events dropped by the span due to limits being reached.\n        dropped-events: u32,\n        /// Number of links dropped by the span due to limits being reached.\n        dropped-links: u32,\n    }\n\n    /// Identifying trace information about a span that can be serialized and propagated.\n    record span-context {\n        /// The `trace-id` for this `span-context`.\n        trace-id: trace-id,\n        /// The `span-id` for this `span-context`.\n        span-id: span-id,\n        /// The `trace-flags` for this `span-context`.\n        trace-flags: trace-flags,\n        /// Whether this `span-context` was propagated from a remote parent.\n        is-remote: bool,\n        /// The `trace-state` for this `span-context`.\n        trace-state: trace-state,\n    }\n\n    /// The trace that this `span-context` belongs to.\n    ///\n    /// 16 bytes encoded as a hexadecimal string.\n    type trace-id = string;\n\n    /// The id of this `span-context`.\n    ///\n    /// 8 bytes encoded as a hexadecimal string.\n    type span-id = string;\n\n    /// Flags that can be set on a `span-context`.\n    flags trace-flags {\n        /// Whether the `span` should be sampled or not.\n        sampled,\n    }\n\n    /// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.\n    ///\n    /// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.\n    type trace-state = list<tuple<string, string>>;\n\n    /// Describes the relationship between the Span, its parents, and its children in a trace.\n    enum span-kind {\n        /// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.\n        client,\n        /// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.\n        server,\n        /// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.\n        producer,\n        /// Indicates that the span describes a child of an asynchronous consumer request.\n        consumer,\n        /// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.\n        internal\n    }\n\n    /// An event describing a specific moment in time on a span and associated attributes.\n    record event {\n        /// Event name.\n        name: string,\n        /// Event time.\n        time: datetime,\n        /// Event attributes.\n        attributes: list<key-value>,\n    }\n\n    /// Describes a relationship to another `span`.\n    record link {\n        /// Denotes which `span` to link to.\n        span-context: span-context,\n        /// Attributes describing the link.\n        attributes: list<key-value>,\n    }\n\n    /// The `status` of a `span`.\n    variant status {\n        /// The default status.\n        unset,\n        /// The operation has been validated by an Application developer or Operator to have completed successfully.\n        ok,\n        /// The operation contains an error with a description.\n        error(string),\n    }\n}\n";
}
/// Bindings for the `wasi:otel` world.
pub mod otel {
    #![allow(clippy::collection_is_never_read)]
    pub use self::wasi::otel::*;
    #[allow(dead_code, clippy::all)]
    pub mod wasi {
        pub mod clocks {
            /// WASI Wall Clock is a clock API intended to let users query the current
            /// time. The name "wall" makes an analogy to a "clock on the wall", which
            /// is not necessarily monotonic as it may be reset.
            ///
            /// It is intended to be portable at least between Unix-family platforms and
            /// Windows.
            ///
            /// A wall clock is a clock which measures the date and time according to
            /// some external reference.
            ///
            /// External references may be reset, so this clock is not necessarily
            /// monotonic, making it unsuitable for measuring elapsed time.
            ///
            /// It is intended for reporting the current date and time for humans.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod wall_clock {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                /// A time and date in seconds plus nanoseconds.
                #[repr(C)]
                pub struct Datetime {
                    pub seconds: u64,
                    pub nanoseconds: u32,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Datetime {
                    #[inline]
                    fn clone(&self) -> Datetime {
                        let _: ::core::clone::AssertParamIsClone<u64>;
                        let _: ::core::clone::AssertParamIsClone<u32>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Datetime {}
                impl ::core::fmt::Debug for Datetime {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Datetime")
                            .field("seconds", &self.seconds)
                            .field("nanoseconds", &self.nanoseconds)
                            .finish()
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Read the current value of the clock.
                ///
                /// This clock is not monotonic, therefore calling this function repeatedly
                /// will not necessarily produce a sequence of non-decreasing values.
                ///
                /// The returned timestamps represent the number of seconds since
                /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
                /// also known as [Unix Time].
                ///
                /// The nanoseconds field of the output is always less than 1000000000.
                ///
                /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
                /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
                #[allow(async_fn_in_trait)]
                pub fn now() -> Datetime {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(ptr0);
                        let l2 = *ptr0.add(0).cast::<i64>();
                        let l3 = *ptr0.add(8).cast::<i32>();
                        let result4 = Datetime {
                            seconds: l2 as u64,
                            nanoseconds: l3 as u32,
                        };
                        result4
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Query the resolution of the clock.
                ///
                /// The nanoseconds field of the output is always less than 1000000000.
                #[allow(async_fn_in_trait)]
                pub fn resolution() -> Datetime {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(ptr0);
                        let l2 = *ptr0.add(0).cast::<i64>();
                        let l3 = *ptr0.add(8).cast::<i32>();
                        let result4 = Datetime {
                            seconds: l2 as u64,
                            nanoseconds: l3 as u32,
                        };
                        result4
                    }
                }
            }
        }
        pub mod otel {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                /// The key part of attribute `key-value` pairs.
                pub type Key = _rt::String;
                /// The value part of attribute `key-value` pairs.
                pub enum Value {
                    /// A string value.
                    String(_rt::String),
                    /// A boolean value.
                    Bool(bool),
                    /// A double precision floating point value.
                    F64(f64),
                    /// A signed 64 bit integer value.
                    S64(i64),
                    /// A homogeneous array of string values.
                    StringArray(_rt::Vec<_rt::String>),
                    /// A homogeneous array of boolean values.
                    BoolArray(_rt::Vec<bool>),
                    /// A homogeneous array of double precision floating point values.
                    F64Array(_rt::Vec<f64>),
                    /// A homogeneous array of 64 bit integer values.
                    S64Array(_rt::Vec<i64>),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Value {
                    #[inline]
                    fn clone(&self) -> Value {
                        match self {
                            Value::String(__self_0) => {
                                Value::String(::core::clone::Clone::clone(__self_0))
                            }
                            Value::Bool(__self_0) => {
                                Value::Bool(::core::clone::Clone::clone(__self_0))
                            }
                            Value::F64(__self_0) => {
                                Value::F64(::core::clone::Clone::clone(__self_0))
                            }
                            Value::S64(__self_0) => {
                                Value::S64(::core::clone::Clone::clone(__self_0))
                            }
                            Value::StringArray(__self_0) => {
                                Value::StringArray(::core::clone::Clone::clone(__self_0))
                            }
                            Value::BoolArray(__self_0) => {
                                Value::BoolArray(::core::clone::Clone::clone(__self_0))
                            }
                            Value::F64Array(__self_0) => {
                                Value::F64Array(::core::clone::Clone::clone(__self_0))
                            }
                            Value::S64Array(__self_0) => {
                                Value::S64Array(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Value {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Value::String(e) => {
                                f.debug_tuple("Value::String").field(e).finish()
                            }
                            Value::Bool(e) => {
                                f.debug_tuple("Value::Bool").field(e).finish()
                            }
                            Value::F64(e) => {
                                f.debug_tuple("Value::F64").field(e).finish()
                            }
                            Value::S64(e) => {
                                f.debug_tuple("Value::S64").field(e).finish()
                            }
                            Value::StringArray(e) => {
                                f.debug_tuple("Value::StringArray").field(e).finish()
                            }
                            Value::BoolArray(e) => {
                                f.debug_tuple("Value::BoolArray").field(e).finish()
                            }
                            Value::F64Array(e) => {
                                f.debug_tuple("Value::F64Array").field(e).finish()
                            }
                            Value::S64Array(e) => {
                                f.debug_tuple("Value::S64Array").field(e).finish()
                            }
                        }
                    }
                }
                /// A key-value pair describing an attribute.
                pub struct KeyValue {
                    /// The attribute name.
                    pub key: Key,
                    /// The attribute value.
                    pub value: Value,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for KeyValue {
                    #[inline]
                    fn clone(&self) -> KeyValue {
                        KeyValue {
                            key: ::core::clone::Clone::clone(&self.key),
                            value: ::core::clone::Clone::clone(&self.value),
                        }
                    }
                }
                impl ::core::fmt::Debug for KeyValue {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("KeyValue")
                            .field("key", &self.key)
                            .field("value", &self.value)
                            .finish()
                    }
                }
                /// The host resource describing the entity producing telemetry.
                pub struct Resource {
                    /// Specifies the resource attributes to associate with emitted telemetry.
                    pub attributes: _rt::Vec<KeyValue>,
                    /// Schema URL used by this library.
                    /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url
                    pub schema_url: Option<_rt::String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Resource {
                    #[inline]
                    fn clone(&self) -> Resource {
                        Resource {
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                            schema_url: ::core::clone::Clone::clone(&self.schema_url),
                        }
                    }
                }
                impl ::core::fmt::Debug for Resource {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Resource")
                            .field("attributes", &self.attributes)
                            .field("schema-url", &self.schema_url)
                            .finish()
                    }
                }
                /// Describes the instrumentation scope that produced a span.
                pub struct InstrumentationScope {
                    /// Name of the instrumentation scope.
                    pub name: _rt::String,
                    /// The library version.
                    pub version: Option<_rt::String>,
                    /// Schema URL used by this library.
                    /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url
                    pub schema_url: Option<_rt::String>,
                    /// Specifies the instrumentation scope attributes to associate with emitted telemetry.
                    pub attributes: _rt::Vec<KeyValue>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for InstrumentationScope {
                    #[inline]
                    fn clone(&self) -> InstrumentationScope {
                        InstrumentationScope {
                            name: ::core::clone::Clone::clone(&self.name),
                            version: ::core::clone::Clone::clone(&self.version),
                            schema_url: ::core::clone::Clone::clone(&self.schema_url),
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                        }
                    }
                }
                impl ::core::fmt::Debug for InstrumentationScope {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("InstrumentationScope")
                            .field("name", &self.name)
                            .field("version", &self.version)
                            .field("schema-url", &self.schema_url)
                            .field("attributes", &self.attributes)
                            .finish()
                    }
                }
                /// The set of errors which may be raised by functions in this package
                pub enum Error {
                    /// Shutdown has already been invoked.
                    AlreadyShutdown,
                    /// Operation timed out before completing.
                    Timeout(u64),
                    /// Operation failed due to an internal error.
                    InternalFailure(_rt::String),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Error {
                    #[inline]
                    fn clone(&self) -> Error {
                        match self {
                            Error::AlreadyShutdown => Error::AlreadyShutdown,
                            Error::Timeout(__self_0) => {
                                Error::Timeout(::core::clone::Clone::clone(__self_0))
                            }
                            Error::InternalFailure(__self_0) => {
                                Error::InternalFailure(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Error::AlreadyShutdown => {
                                f.debug_tuple("Error::AlreadyShutdown").finish()
                            }
                            Error::Timeout(e) => {
                                f.debug_tuple("Error::Timeout").field(e).finish()
                            }
                            Error::InternalFailure(e) => {
                                f.debug_tuple("Error::InternalFailure").field(e).finish()
                            }
                        }
                    }
                }
                impl ::core::fmt::Display for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for Error {}
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod tracing {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
                pub type KeyValue = super::super::super::wasi::otel::types::KeyValue;
                pub type InstrumentationScope = super::super::super::wasi::otel::types::InstrumentationScope;
                pub type Error = super::super::super::wasi::otel::types::Error;
                /// The trace that this `span-context` belongs to.
                ///
                /// 16 bytes encoded as a hexadecimal string.
                pub type TraceId = _rt::String;
                /// The id of this `span-context`.
                ///
                /// 8 bytes encoded as a hexadecimal string.
                pub type SpanId = _rt::String;
                /// Flags that can be set on a `span-context`.
                pub struct TraceFlags(
                    <TraceFlags as ::bitflags::__private::PublicFlags>::Internal,
                );
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for TraceFlags {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for TraceFlags {
                    #[inline]
                    fn eq(&self, other: &TraceFlags) -> bool {
                        self.0 == other.0
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Eq for TraceFlags {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<
                            <TraceFlags as ::bitflags::__private::PublicFlags>::Internal,
                        >;
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for TraceFlags {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &TraceFlags,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for TraceFlags {
                    #[inline]
                    fn cmp(&self, other: &TraceFlags) -> ::core::cmp::Ordering {
                        ::core::cmp::Ord::cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::hash::Hash for TraceFlags {
                    #[inline]
                    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                        ::core::hash::Hash::hash(&self.0, state)
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for TraceFlags {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TraceFlags",
                            &&self.0,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TraceFlags {
                    #[inline]
                    fn clone(&self) -> TraceFlags {
                        let _: ::core::clone::AssertParamIsClone<
                            <TraceFlags as ::bitflags::__private::PublicFlags>::Internal,
                        >;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for TraceFlags {}
                impl TraceFlags {
                    /// Whether the `span` should be sampled or not.
                    #[allow(deprecated, non_upper_case_globals)]
                    pub const SAMPLED: Self = Self::from_bits_retain(1 << 0);
                }
                impl ::bitflags::Flags for TraceFlags {
                    const FLAGS: &'static [::bitflags::Flag<TraceFlags>] = &[
                        {
                            #[allow(deprecated, non_upper_case_globals)]
                            ::bitflags::Flag::new("SAMPLED", TraceFlags::SAMPLED)
                        },
                    ];
                    type Bits = u8;
                    fn bits(&self) -> u8 {
                        TraceFlags::bits(self)
                    }
                    fn from_bits_retain(bits: u8) -> TraceFlags {
                        TraceFlags::from_bits_retain(bits)
                    }
                }
                #[allow(
                    dead_code,
                    deprecated,
                    unused_doc_comments,
                    unused_attributes,
                    unused_mut,
                    unused_imports,
                    non_upper_case_globals,
                    clippy::assign_op_pattern,
                    clippy::indexing_slicing,
                    clippy::same_name_method,
                    clippy::iter_without_into_iter,
                )]
                const _: () = {
                    #[repr(transparent)]
                    pub struct InternalBitFlags(u8);
                    #[automatically_derived]
                    impl ::core::clone::Clone for InternalBitFlags {
                        #[inline]
                        fn clone(&self) -> InternalBitFlags {
                            let _: ::core::clone::AssertParamIsClone<u8>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for InternalBitFlags {}
                    #[automatically_derived]
                    impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
                    #[automatically_derived]
                    impl ::core::cmp::PartialEq for InternalBitFlags {
                        #[inline]
                        fn eq(&self, other: &InternalBitFlags) -> bool {
                            self.0 == other.0
                        }
                    }
                    #[automatically_derived]
                    impl ::core::cmp::Eq for InternalBitFlags {
                        #[inline]
                        #[doc(hidden)]
                        #[coverage(off)]
                        fn assert_receiver_is_total_eq(&self) -> () {
                            let _: ::core::cmp::AssertParamIsEq<u8>;
                        }
                    }
                    #[automatically_derived]
                    impl ::core::cmp::PartialOrd for InternalBitFlags {
                        #[inline]
                        fn partial_cmp(
                            &self,
                            other: &InternalBitFlags,
                        ) -> ::core::option::Option<::core::cmp::Ordering> {
                            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                        }
                    }
                    #[automatically_derived]
                    impl ::core::cmp::Ord for InternalBitFlags {
                        #[inline]
                        fn cmp(
                            &self,
                            other: &InternalBitFlags,
                        ) -> ::core::cmp::Ordering {
                            ::core::cmp::Ord::cmp(&self.0, &other.0)
                        }
                    }
                    #[automatically_derived]
                    impl ::core::hash::Hash for InternalBitFlags {
                        #[inline]
                        fn hash<__H: ::core::hash::Hasher>(
                            &self,
                            state: &mut __H,
                        ) -> () {
                            ::core::hash::Hash::hash(&self.0, state)
                        }
                    }
                    impl ::bitflags::__private::PublicFlags for TraceFlags {
                        type Primitive = u8;
                        type Internal = InternalBitFlags;
                    }
                    impl ::bitflags::__private::core::default::Default
                    for InternalBitFlags {
                        #[inline]
                        fn default() -> Self {
                            InternalBitFlags::empty()
                        }
                    }
                    impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            if self.is_empty() {
                                f.write_fmt(
                                    format_args!("{0:#x}", <u8 as ::bitflags::Bits>::EMPTY),
                                )
                            } else {
                                ::bitflags::__private::core::fmt::Display::fmt(self, f)
                            }
                        }
                    }
                    impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            ::bitflags::parser::to_writer(&TraceFlags(*self), f)
                        }
                    }
                    impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                        type Err = ::bitflags::parser::ParseError;
                        fn from_str(
                            s: &str,
                        ) -> ::bitflags::__private::core::result::Result<
                            Self,
                            Self::Err,
                        > {
                            ::bitflags::parser::from_str::<TraceFlags>(s)
                                .map(|flags| flags.0)
                        }
                    }
                    impl ::bitflags::__private::core::convert::AsRef<u8>
                    for InternalBitFlags {
                        fn as_ref(&self) -> &u8 {
                            &self.0
                        }
                    }
                    impl ::bitflags::__private::core::convert::From<u8>
                    for InternalBitFlags {
                        fn from(bits: u8) -> Self {
                            Self::from_bits_retain(bits)
                        }
                    }
                    #[allow(dead_code, deprecated, unused_attributes)]
                    impl InternalBitFlags {
                        /// Get a flags value with all bits unset.
                        #[inline]
                        pub const fn empty() -> Self {
                            Self(<u8 as ::bitflags::Bits>::EMPTY)
                        }
                        /// Get a flags value with all known bits set.
                        #[inline]
                        pub const fn all() -> Self {
                            let mut truncated = <u8 as ::bitflags::Bits>::EMPTY;
                            let mut i = 0;
                            {
                                {
                                    let flag = <TraceFlags as ::bitflags::Flags>::FLAGS[i]
                                        .value()
                                        .bits();
                                    truncated = truncated | flag;
                                    i += 1;
                                }
                            };
                            let _ = i;
                            Self(truncated)
                        }
                        /// Get the underlying bits value.
                        ///
                        /// The returned value is exactly the bits set in this flags value.
                        #[inline]
                        pub const fn bits(&self) -> u8 {
                            self.0
                        }
                        /// Convert from a bits value.
                        ///
                        /// This method will return `None` if any unknown bits are set.
                        #[inline]
                        pub const fn from_bits(
                            bits: u8,
                        ) -> ::bitflags::__private::core::option::Option<Self> {
                            let truncated = Self::from_bits_truncate(bits).0;
                            if truncated == bits {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            } else {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                        /// Convert from a bits value, unsetting any unknown bits.
                        #[inline]
                        pub const fn from_bits_truncate(bits: u8) -> Self {
                            Self(bits & Self::all().0)
                        }
                        /// Convert from a bits value exactly.
                        #[inline]
                        pub const fn from_bits_retain(bits: u8) -> Self {
                            Self(bits)
                        }
                        /// Get a flags value with the bits of a flag with the given name set.
                        ///
                        /// This method will return `None` if `name` is empty or doesn't
                        /// correspond to any named flag.
                        #[inline]
                        pub fn from_name(
                            name: &str,
                        ) -> ::bitflags::__private::core::option::Option<Self> {
                            {
                                if name == "SAMPLED" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(TraceFlags::SAMPLED.bits()),
                                    );
                                }
                            };
                            let _ = name;
                            ::bitflags::__private::core::option::Option::None
                        }
                        /// Whether all bits in this flags value are unset.
                        #[inline]
                        pub const fn is_empty(&self) -> bool {
                            self.0 == <u8 as ::bitflags::Bits>::EMPTY
                        }
                        /// Whether all known bits in this flags value are set.
                        #[inline]
                        pub const fn is_all(&self) -> bool {
                            Self::all().0 | self.0 == self.0
                        }
                        /// Whether any set bits in a source flags value are also set in a target flags value.
                        #[inline]
                        pub const fn intersects(&self, other: Self) -> bool {
                            self.0 & other.0 != <u8 as ::bitflags::Bits>::EMPTY
                        }
                        /// Whether all set bits in a source flags value are also set in a target flags value.
                        #[inline]
                        pub const fn contains(&self, other: Self) -> bool {
                            self.0 & other.0 == other.0
                        }
                        /// The bitwise or (`|`) of the bits in two flags values.
                        #[inline]
                        pub fn insert(&mut self, other: Self) {
                            *self = Self(self.0).union(other);
                        }
                        /// The intersection of a source flags value with the complement of a target flags
                        /// value (`&!`).
                        ///
                        /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                        /// `remove` won't truncate `other`, but the `!` operator will.
                        #[inline]
                        pub fn remove(&mut self, other: Self) {
                            *self = Self(self.0).difference(other);
                        }
                        /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                        #[inline]
                        pub fn toggle(&mut self, other: Self) {
                            *self = Self(self.0).symmetric_difference(other);
                        }
                        /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                        #[inline]
                        pub fn set(&mut self, other: Self, value: bool) {
                            if value {
                                self.insert(other);
                            } else {
                                self.remove(other);
                            }
                        }
                        /// The bitwise and (`&`) of the bits in two flags values.
                        #[inline]
                        #[must_use]
                        pub const fn intersection(self, other: Self) -> Self {
                            Self(self.0 & other.0)
                        }
                        /// The bitwise or (`|`) of the bits in two flags values.
                        #[inline]
                        #[must_use]
                        pub const fn union(self, other: Self) -> Self {
                            Self(self.0 | other.0)
                        }
                        /// The intersection of a source flags value with the complement of a target flags
                        /// value (`&!`).
                        ///
                        /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                        /// `difference` won't truncate `other`, but the `!` operator will.
                        #[inline]
                        #[must_use]
                        pub const fn difference(self, other: Self) -> Self {
                            Self(self.0 & !other.0)
                        }
                        /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                        #[inline]
                        #[must_use]
                        pub const fn symmetric_difference(self, other: Self) -> Self {
                            Self(self.0 ^ other.0)
                        }
                        /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                        #[inline]
                        #[must_use]
                        pub const fn complement(self) -> Self {
                            Self::from_bits_truncate(!self.0)
                        }
                    }
                    impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            let inner = self.0;
                            ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                        }
                    }
                    impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            let inner = self.0;
                            ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                        }
                    }
                    impl ::bitflags::__private::core::fmt::LowerHex
                    for InternalBitFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            let inner = self.0;
                            ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                        }
                    }
                    impl ::bitflags::__private::core::fmt::UpperHex
                    for InternalBitFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            let inner = self.0;
                            ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                        type Output = Self;
                        /// The bitwise or (`|`) of the bits in two flags values.
                        #[inline]
                        fn bitor(self, other: InternalBitFlags) -> Self {
                            self.union(other)
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitOrAssign
                    for InternalBitFlags {
                        /// The bitwise or (`|`) of the bits in two flags values.
                        #[inline]
                        fn bitor_assign(&mut self, other: Self) {
                            self.insert(other);
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                        type Output = Self;
                        /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                        #[inline]
                        fn bitxor(self, other: Self) -> Self {
                            self.symmetric_difference(other)
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitXorAssign
                    for InternalBitFlags {
                        /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                        #[inline]
                        fn bitxor_assign(&mut self, other: Self) {
                            self.toggle(other);
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                        type Output = Self;
                        /// The bitwise and (`&`) of the bits in two flags values.
                        #[inline]
                        fn bitand(self, other: Self) -> Self {
                            self.intersection(other)
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitAndAssign
                    for InternalBitFlags {
                        /// The bitwise and (`&`) of the bits in two flags values.
                        #[inline]
                        fn bitand_assign(&mut self, other: Self) {
                            *self = Self::from_bits_retain(self.bits())
                                .intersection(other);
                        }
                    }
                    impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                        type Output = Self;
                        /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                        ///
                        /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                        /// `difference` won't truncate `other`, but the `!` operator will.
                        #[inline]
                        fn sub(self, other: Self) -> Self {
                            self.difference(other)
                        }
                    }
                    impl ::bitflags::__private::core::ops::SubAssign
                    for InternalBitFlags {
                        /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                        ///
                        /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                        /// `difference` won't truncate `other`, but the `!` operator will.
                        #[inline]
                        fn sub_assign(&mut self, other: Self) {
                            self.remove(other);
                        }
                    }
                    impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                        type Output = Self;
                        /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                        #[inline]
                        fn not(self) -> Self {
                            self.complement()
                        }
                    }
                    impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
                    for InternalBitFlags {
                        /// The bitwise or (`|`) of the bits in each flags value.
                        fn extend<
                            T: ::bitflags::__private::core::iter::IntoIterator<
                                    Item = Self,
                                >,
                        >(&mut self, iterator: T) {
                            for item in iterator {
                                self.insert(item)
                            }
                        }
                    }
                    impl ::bitflags::__private::core::iter::FromIterator<
                        InternalBitFlags,
                    > for InternalBitFlags {
                        /// The bitwise or (`|`) of the bits in each flags value.
                        fn from_iter<
                            T: ::bitflags::__private::core::iter::IntoIterator<
                                    Item = Self,
                                >,
                        >(iterator: T) -> Self {
                            use ::bitflags::__private::core::iter::Extend;
                            let mut result = Self::empty();
                            result.extend(iterator);
                            result
                        }
                    }
                    impl InternalBitFlags {
                        /// Yield a set of contained flags values.
                        ///
                        /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                        /// will be yielded together as a final flags value.
                        #[inline]
                        pub const fn iter(&self) -> ::bitflags::iter::Iter<TraceFlags> {
                            ::bitflags::iter::Iter::__private_const_new(
                                <TraceFlags as ::bitflags::Flags>::FLAGS,
                                TraceFlags::from_bits_retain(self.bits()),
                                TraceFlags::from_bits_retain(self.bits()),
                            )
                        }
                        /// Yield a set of contained named flags values.
                        ///
                        /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                        /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                        #[inline]
                        pub const fn iter_names(
                            &self,
                        ) -> ::bitflags::iter::IterNames<TraceFlags> {
                            ::bitflags::iter::IterNames::__private_const_new(
                                <TraceFlags as ::bitflags::Flags>::FLAGS,
                                TraceFlags::from_bits_retain(self.bits()),
                                TraceFlags::from_bits_retain(self.bits()),
                            )
                        }
                    }
                    impl ::bitflags::__private::core::iter::IntoIterator
                    for InternalBitFlags {
                        type Item = TraceFlags;
                        type IntoIter = ::bitflags::iter::Iter<TraceFlags>;
                        fn into_iter(self) -> Self::IntoIter {
                            self.iter()
                        }
                    }
                    impl InternalBitFlags {
                        /// Returns a mutable reference to the raw value of the flags currently stored.
                        #[inline]
                        pub fn bits_mut(&mut self) -> &mut u8 {
                            &mut self.0
                        }
                    }
                    #[allow(dead_code, deprecated, unused_attributes)]
                    impl TraceFlags {
                        /// Get a flags value with all bits unset.
                        #[inline]
                        pub const fn empty() -> Self {
                            Self(InternalBitFlags::empty())
                        }
                        /// Get a flags value with all known bits set.
                        #[inline]
                        pub const fn all() -> Self {
                            Self(InternalBitFlags::all())
                        }
                        /// Get the underlying bits value.
                        ///
                        /// The returned value is exactly the bits set in this flags value.
                        #[inline]
                        pub const fn bits(&self) -> u8 {
                            self.0.bits()
                        }
                        /// Convert from a bits value.
                        ///
                        /// This method will return `None` if any unknown bits are set.
                        #[inline]
                        pub const fn from_bits(
                            bits: u8,
                        ) -> ::bitflags::__private::core::option::Option<Self> {
                            match InternalBitFlags::from_bits(bits) {
                                ::bitflags::__private::core::option::Option::Some(bits) => {
                                    ::bitflags::__private::core::option::Option::Some(
                                        Self(bits),
                                    )
                                }
                                ::bitflags::__private::core::option::Option::None => {
                                    ::bitflags::__private::core::option::Option::None
                                }
                            }
                        }
                        /// Convert from a bits value, unsetting any unknown bits.
                        #[inline]
                        pub const fn from_bits_truncate(bits: u8) -> Self {
                            Self(InternalBitFlags::from_bits_truncate(bits))
                        }
                        /// Convert from a bits value exactly.
                        #[inline]
                        pub const fn from_bits_retain(bits: u8) -> Self {
                            Self(InternalBitFlags::from_bits_retain(bits))
                        }
                        /// Get a flags value with the bits of a flag with the given name set.
                        ///
                        /// This method will return `None` if `name` is empty or doesn't
                        /// correspond to any named flag.
                        #[inline]
                        pub fn from_name(
                            name: &str,
                        ) -> ::bitflags::__private::core::option::Option<Self> {
                            match InternalBitFlags::from_name(name) {
                                ::bitflags::__private::core::option::Option::Some(bits) => {
                                    ::bitflags::__private::core::option::Option::Some(
                                        Self(bits),
                                    )
                                }
                                ::bitflags::__private::core::option::Option::None => {
                                    ::bitflags::__private::core::option::Option::None
                                }
                            }
                        }
                        /// Whether all bits in this flags value are unset.
                        #[inline]
                        pub const fn is_empty(&self) -> bool {
                            self.0.is_empty()
                        }
                        /// Whether all known bits in this flags value are set.
                        #[inline]
                        pub const fn is_all(&self) -> bool {
                            self.0.is_all()
                        }
                        /// Whether any set bits in a source flags value are also set in a target flags value.
                        #[inline]
                        pub const fn intersects(&self, other: Self) -> bool {
                            self.0.intersects(other.0)
                        }
                        /// Whether all set bits in a source flags value are also set in a target flags value.
                        #[inline]
                        pub const fn contains(&self, other: Self) -> bool {
                            self.0.contains(other.0)
                        }
                        /// The bitwise or (`|`) of the bits in two flags values.
                        #[inline]
                        pub fn insert(&mut self, other: Self) {
                            self.0.insert(other.0)
                        }
                        /// The intersection of a source flags value with the complement of a target flags
                        /// value (`&!`).
                        ///
                        /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                        /// `remove` won't truncate `other`, but the `!` operator will.
                        #[inline]
                        pub fn remove(&mut self, other: Self) {
                            self.0.remove(other.0)
                        }
                        /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                        #[inline]
                        pub fn toggle(&mut self, other: Self) {
                            self.0.toggle(other.0)
                        }
                        /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                        #[inline]
                        pub fn set(&mut self, other: Self, value: bool) {
                            self.0.set(other.0, value)
                        }
                        /// The bitwise and (`&`) of the bits in two flags values.
                        #[inline]
                        #[must_use]
                        pub const fn intersection(self, other: Self) -> Self {
                            Self(self.0.intersection(other.0))
                        }
                        /// The bitwise or (`|`) of the bits in two flags values.
                        #[inline]
                        #[must_use]
                        pub const fn union(self, other: Self) -> Self {
                            Self(self.0.union(other.0))
                        }
                        /// The intersection of a source flags value with the complement of a target flags
                        /// value (`&!`).
                        ///
                        /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                        /// `difference` won't truncate `other`, but the `!` operator will.
                        #[inline]
                        #[must_use]
                        pub const fn difference(self, other: Self) -> Self {
                            Self(self.0.difference(other.0))
                        }
                        /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                        #[inline]
                        #[must_use]
                        pub const fn symmetric_difference(self, other: Self) -> Self {
                            Self(self.0.symmetric_difference(other.0))
                        }
                        /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                        #[inline]
                        #[must_use]
                        pub const fn complement(self) -> Self {
                            Self(self.0.complement())
                        }
                    }
                    impl ::bitflags::__private::core::fmt::Binary for TraceFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            let inner = self.0;
                            ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                        }
                    }
                    impl ::bitflags::__private::core::fmt::Octal for TraceFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            let inner = self.0;
                            ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                        }
                    }
                    impl ::bitflags::__private::core::fmt::LowerHex for TraceFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            let inner = self.0;
                            ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                        }
                    }
                    impl ::bitflags::__private::core::fmt::UpperHex for TraceFlags {
                        fn fmt(
                            &self,
                            f: &mut ::bitflags::__private::core::fmt::Formatter,
                        ) -> ::bitflags::__private::core::fmt::Result {
                            let inner = self.0;
                            ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitOr for TraceFlags {
                        type Output = Self;
                        /// The bitwise or (`|`) of the bits in two flags values.
                        #[inline]
                        fn bitor(self, other: TraceFlags) -> Self {
                            self.union(other)
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitOrAssign for TraceFlags {
                        /// The bitwise or (`|`) of the bits in two flags values.
                        #[inline]
                        fn bitor_assign(&mut self, other: Self) {
                            self.insert(other);
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitXor for TraceFlags {
                        type Output = Self;
                        /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                        #[inline]
                        fn bitxor(self, other: Self) -> Self {
                            self.symmetric_difference(other)
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitXorAssign for TraceFlags {
                        /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                        #[inline]
                        fn bitxor_assign(&mut self, other: Self) {
                            self.toggle(other);
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitAnd for TraceFlags {
                        type Output = Self;
                        /// The bitwise and (`&`) of the bits in two flags values.
                        #[inline]
                        fn bitand(self, other: Self) -> Self {
                            self.intersection(other)
                        }
                    }
                    impl ::bitflags::__private::core::ops::BitAndAssign for TraceFlags {
                        /// The bitwise and (`&`) of the bits in two flags values.
                        #[inline]
                        fn bitand_assign(&mut self, other: Self) {
                            *self = Self::from_bits_retain(self.bits())
                                .intersection(other);
                        }
                    }
                    impl ::bitflags::__private::core::ops::Sub for TraceFlags {
                        type Output = Self;
                        /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                        ///
                        /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                        /// `difference` won't truncate `other`, but the `!` operator will.
                        #[inline]
                        fn sub(self, other: Self) -> Self {
                            self.difference(other)
                        }
                    }
                    impl ::bitflags::__private::core::ops::SubAssign for TraceFlags {
                        /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                        ///
                        /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                        /// `difference` won't truncate `other`, but the `!` operator will.
                        #[inline]
                        fn sub_assign(&mut self, other: Self) {
                            self.remove(other);
                        }
                    }
                    impl ::bitflags::__private::core::ops::Not for TraceFlags {
                        type Output = Self;
                        /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                        #[inline]
                        fn not(self) -> Self {
                            self.complement()
                        }
                    }
                    impl ::bitflags::__private::core::iter::Extend<TraceFlags>
                    for TraceFlags {
                        /// The bitwise or (`|`) of the bits in each flags value.
                        fn extend<
                            T: ::bitflags::__private::core::iter::IntoIterator<
                                    Item = Self,
                                >,
                        >(&mut self, iterator: T) {
                            for item in iterator {
                                self.insert(item)
                            }
                        }
                    }
                    impl ::bitflags::__private::core::iter::FromIterator<TraceFlags>
                    for TraceFlags {
                        /// The bitwise or (`|`) of the bits in each flags value.
                        fn from_iter<
                            T: ::bitflags::__private::core::iter::IntoIterator<
                                    Item = Self,
                                >,
                        >(iterator: T) -> Self {
                            use ::bitflags::__private::core::iter::Extend;
                            let mut result = Self::empty();
                            result.extend(iterator);
                            result
                        }
                    }
                    impl TraceFlags {
                        /// Yield a set of contained flags values.
                        ///
                        /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                        /// will be yielded together as a final flags value.
                        #[inline]
                        pub const fn iter(&self) -> ::bitflags::iter::Iter<TraceFlags> {
                            ::bitflags::iter::Iter::__private_const_new(
                                <TraceFlags as ::bitflags::Flags>::FLAGS,
                                TraceFlags::from_bits_retain(self.bits()),
                                TraceFlags::from_bits_retain(self.bits()),
                            )
                        }
                        /// Yield a set of contained named flags values.
                        ///
                        /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                        /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                        #[inline]
                        pub const fn iter_names(
                            &self,
                        ) -> ::bitflags::iter::IterNames<TraceFlags> {
                            ::bitflags::iter::IterNames::__private_const_new(
                                <TraceFlags as ::bitflags::Flags>::FLAGS,
                                TraceFlags::from_bits_retain(self.bits()),
                                TraceFlags::from_bits_retain(self.bits()),
                            )
                        }
                    }
                    impl ::bitflags::__private::core::iter::IntoIterator for TraceFlags {
                        type Item = TraceFlags;
                        type IntoIter = ::bitflags::iter::Iter<TraceFlags>;
                        fn into_iter(self) -> Self::IntoIter {
                            self.iter()
                        }
                    }
                };
                /// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.
                ///
                /// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.
                pub type TraceState = _rt::Vec<(_rt::String, _rt::String)>;
                /// Identifying trace information about a span that can be serialized and propagated.
                pub struct SpanContext {
                    /// The `trace-id` for this `span-context`.
                    pub trace_id: TraceId,
                    /// The `span-id` for this `span-context`.
                    pub span_id: SpanId,
                    /// The `trace-flags` for this `span-context`.
                    pub trace_flags: TraceFlags,
                    /// Whether this `span-context` was propagated from a remote parent.
                    pub is_remote: bool,
                    /// The `trace-state` for this `span-context`.
                    pub trace_state: TraceState,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SpanContext {
                    #[inline]
                    fn clone(&self) -> SpanContext {
                        SpanContext {
                            trace_id: ::core::clone::Clone::clone(&self.trace_id),
                            span_id: ::core::clone::Clone::clone(&self.span_id),
                            trace_flags: ::core::clone::Clone::clone(&self.trace_flags),
                            is_remote: ::core::clone::Clone::clone(&self.is_remote),
                            trace_state: ::core::clone::Clone::clone(&self.trace_state),
                        }
                    }
                }
                impl ::core::fmt::Debug for SpanContext {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SpanContext")
                            .field("trace-id", &self.trace_id)
                            .field("span-id", &self.span_id)
                            .field("trace-flags", &self.trace_flags)
                            .field("is-remote", &self.is_remote)
                            .field("trace-state", &self.trace_state)
                            .finish()
                    }
                }
                /// Describes the relationship between the Span, its parents, and its children in a trace.
                #[repr(u8)]
                pub enum SpanKind {
                    /// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.
                    Client,
                    /// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.
                    Server,
                    /// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.
                    Producer,
                    /// Indicates that the span describes a child of an asynchronous consumer request.
                    Consumer,
                    /// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.
                    Internal,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SpanKind {
                    #[inline]
                    fn clone(&self) -> SpanKind {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for SpanKind {}
                #[automatically_derived]
                impl ::core::cmp::Eq for SpanKind {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for SpanKind {
                    #[inline]
                    fn cmp(&self, other: &SpanKind) -> ::core::cmp::Ordering {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for SpanKind {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for SpanKind {
                    #[inline]
                    fn eq(&self, other: &SpanKind) -> bool {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        __self_discr == __arg1_discr
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for SpanKind {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &SpanKind,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
                impl ::core::fmt::Debug for SpanKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            SpanKind::Client => {
                                f.debug_tuple("SpanKind::Client").finish()
                            }
                            SpanKind::Server => {
                                f.debug_tuple("SpanKind::Server").finish()
                            }
                            SpanKind::Producer => {
                                f.debug_tuple("SpanKind::Producer").finish()
                            }
                            SpanKind::Consumer => {
                                f.debug_tuple("SpanKind::Consumer").finish()
                            }
                            SpanKind::Internal => {
                                f.debug_tuple("SpanKind::Internal").finish()
                            }
                        }
                    }
                }
                impl SpanKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> SpanKind {
                        if !true {
                            return unsafe { ::core::mem::transmute(val) };
                        }
                        match val {
                            0 => SpanKind::Client,
                            1 => SpanKind::Server,
                            2 => SpanKind::Producer,
                            3 => SpanKind::Consumer,
                            4 => SpanKind::Internal,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        }
                    }
                }
                /// An event describing a specific moment in time on a span and associated attributes.
                pub struct Event {
                    /// Event name.
                    pub name: _rt::String,
                    /// Event time.
                    pub time: Datetime,
                    /// Event attributes.
                    pub attributes: _rt::Vec<KeyValue>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Event {
                    #[inline]
                    fn clone(&self) -> Event {
                        Event {
                            name: ::core::clone::Clone::clone(&self.name),
                            time: ::core::clone::Clone::clone(&self.time),
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                        }
                    }
                }
                impl ::core::fmt::Debug for Event {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Event")
                            .field("name", &self.name)
                            .field("time", &self.time)
                            .field("attributes", &self.attributes)
                            .finish()
                    }
                }
                /// Describes a relationship to another `span`.
                pub struct Link {
                    /// Denotes which `span` to link to.
                    pub span_context: SpanContext,
                    /// Attributes describing the link.
                    pub attributes: _rt::Vec<KeyValue>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Link {
                    #[inline]
                    fn clone(&self) -> Link {
                        Link {
                            span_context: ::core::clone::Clone::clone(
                                &self.span_context,
                            ),
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                        }
                    }
                }
                impl ::core::fmt::Debug for Link {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Link")
                            .field("span-context", &self.span_context)
                            .field("attributes", &self.attributes)
                            .finish()
                    }
                }
                /// The `status` of a `span`.
                pub enum Status {
                    /// The default status.
                    Unset,
                    /// The operation has been validated by an Application developer or Operator to have completed successfully.
                    Ok,
                    /// The operation contains an error with a description.
                    Error(_rt::String),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Status {
                    #[inline]
                    fn clone(&self) -> Status {
                        match self {
                            Status::Unset => Status::Unset,
                            Status::Ok => Status::Ok,
                            Status::Error(__self_0) => {
                                Status::Error(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Status {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Status::Unset => f.debug_tuple("Status::Unset").finish(),
                            Status::Ok => f.debug_tuple("Status::Ok").finish(),
                            Status::Error(e) => {
                                f.debug_tuple("Status::Error").field(e).finish()
                            }
                        }
                    }
                }
                /// The data associated with a span.
                pub struct SpanData {
                    /// Span context.
                    pub span_context: SpanContext,
                    /// Span parent id.
                    pub parent_span_id: _rt::String,
                    /// Span kind.
                    pub span_kind: SpanKind,
                    /// Span name.
                    pub name: _rt::String,
                    /// Span start time.
                    pub start_time: Datetime,
                    /// Span end time.
                    pub end_time: Datetime,
                    /// Span attributes.
                    pub attributes: _rt::Vec<KeyValue>,
                    /// Span events.
                    pub events: _rt::Vec<Event>,
                    /// Span Links.
                    pub links: _rt::Vec<Link>,
                    /// Span status.
                    pub status: Status,
                    /// Instrumentation scope that produced this span.
                    pub instrumentation_scope: InstrumentationScope,
                    /// Number of attributes dropped by the span due to limits being reached.
                    pub dropped_attributes: u32,
                    /// Number of events dropped by the span due to limits being reached.
                    pub dropped_events: u32,
                    /// Number of links dropped by the span due to limits being reached.
                    pub dropped_links: u32,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SpanData {
                    #[inline]
                    fn clone(&self) -> SpanData {
                        SpanData {
                            span_context: ::core::clone::Clone::clone(
                                &self.span_context,
                            ),
                            parent_span_id: ::core::clone::Clone::clone(
                                &self.parent_span_id,
                            ),
                            span_kind: ::core::clone::Clone::clone(&self.span_kind),
                            name: ::core::clone::Clone::clone(&self.name),
                            start_time: ::core::clone::Clone::clone(&self.start_time),
                            end_time: ::core::clone::Clone::clone(&self.end_time),
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                            events: ::core::clone::Clone::clone(&self.events),
                            links: ::core::clone::Clone::clone(&self.links),
                            status: ::core::clone::Clone::clone(&self.status),
                            instrumentation_scope: ::core::clone::Clone::clone(
                                &self.instrumentation_scope,
                            ),
                            dropped_attributes: ::core::clone::Clone::clone(
                                &self.dropped_attributes,
                            ),
                            dropped_events: ::core::clone::Clone::clone(
                                &self.dropped_events,
                            ),
                            dropped_links: ::core::clone::Clone::clone(
                                &self.dropped_links,
                            ),
                        }
                    }
                }
                impl ::core::fmt::Debug for SpanData {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SpanData")
                            .field("span-context", &self.span_context)
                            .field("parent-span-id", &self.parent_span_id)
                            .field("span-kind", &self.span_kind)
                            .field("name", &self.name)
                            .field("start-time", &self.start_time)
                            .field("end-time", &self.end_time)
                            .field("attributes", &self.attributes)
                            .field("events", &self.events)
                            .field("links", &self.links)
                            .field("status", &self.status)
                            .field("instrumentation-scope", &self.instrumentation_scope)
                            .field("dropped-attributes", &self.dropped_attributes)
                            .field("dropped-events", &self.dropped_events)
                            .field("dropped-links", &self.dropped_links)
                            .finish()
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Returns the current span context of the host.
                #[allow(async_fn_in_trait)]
                pub fn context() -> SpanContext {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 7 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 7
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(ptr0);
                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                        let l3 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len4 = l3;
                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                        let l5 = *ptr0
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l6 = *ptr0
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len7 = l6;
                        let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                        let l8 = i32::from(
                            *ptr0
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>(),
                        );
                        let l9 = i32::from(
                            *ptr0
                                .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>(),
                        );
                        let l10 = *ptr0
                            .add(5 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l11 = *ptr0
                            .add(6 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let base18 = l10;
                        let len18 = l11;
                        let mut result18 = _rt::Vec::with_capacity(len18);
                        for i in 0..len18 {
                            let base = base18
                                .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                            let e18 = {
                                let l12 = *base.add(0).cast::<*mut u8>();
                                let l13 = *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len14 = l13;
                                let bytes14 = _rt::Vec::from_raw_parts(
                                    l12.cast(),
                                    len14,
                                    len14,
                                );
                                let l15 = *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l16 = *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len17 = l16;
                                let bytes17 = _rt::Vec::from_raw_parts(
                                    l15.cast(),
                                    len17,
                                    len17,
                                );
                                (_rt::string_lift(bytes14), _rt::string_lift(bytes17))
                            };
                            result18.push(e18);
                        }
                        _rt::cabi_dealloc(
                            base18,
                            len18 * (4 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result19 = SpanContext {
                            trace_id: _rt::string_lift(bytes4),
                            span_id: _rt::string_lift(bytes7),
                            trace_flags: TraceFlags::empty()
                                | TraceFlags::from_bits_retain(((l8 as u8) << 0) as _),
                            is_remote: _rt::bool_lift(l9 as u8),
                            trace_state: result18,
                        };
                        result19
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Called by the guest to export spans.
                #[allow(async_fn_in_trait)]
                pub fn export(span: &[SpanData]) -> Result<(), Error> {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 16 + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16
                                + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec72 = span;
                        let len72 = vec72.len();
                        let layout72 = _rt::alloc::Layout::from_size_align(
                                vec72.len()
                                    * (40 + 32 * ::core::mem::size_of::<*const u8>()),
                                8,
                            )
                            .unwrap();
                        let (result72, _cleanup72) = wit_bindgen::rt::Cleanup::new(
                            layout72,
                        );
                        for (i, e) in vec72.into_iter().enumerate() {
                            let base = result72
                                .add(i * (40 + 32 * ::core::mem::size_of::<*const u8>()));
                            {
                                let SpanData {
                                    span_context: span_context0,
                                    parent_span_id: parent_span_id0,
                                    span_kind: span_kind0,
                                    name: name0,
                                    start_time: start_time0,
                                    end_time: end_time0,
                                    attributes: attributes0,
                                    events: events0,
                                    links: links0,
                                    status: status0,
                                    instrumentation_scope: instrumentation_scope0,
                                    dropped_attributes: dropped_attributes0,
                                    dropped_events: dropped_events0,
                                    dropped_links: dropped_links0,
                                } = e;
                                let SpanContext {
                                    trace_id: trace_id1,
                                    span_id: span_id1,
                                    trace_flags: trace_flags1,
                                    is_remote: is_remote1,
                                    trace_state: trace_state1,
                                } = span_context0;
                                let vec2 = trace_id1;
                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                let len2 = vec2.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len2;
                                *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                                let vec3 = span_id1;
                                let ptr3 = vec3.as_ptr().cast::<u8>();
                                let len3 = vec3.len();
                                *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len3;
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = ptr3.cast_mut();
                                let flags4 = trace_flags1;
                                *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>() = ((flags4.bits() >> 0) as i32) as u8;
                                *base
                                    .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>() = (match is_remote1 {
                                    true => 1,
                                    false => 0,
                                }) as u8;
                                let vec8 = trace_state1;
                                let len8 = vec8.len();
                                let layout8 = _rt::alloc::Layout::from_size_align(
                                        vec8.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    )
                                    .unwrap();
                                let (result8, _cleanup8) = wit_bindgen::rt::Cleanup::new(
                                    layout8,
                                );
                                cleanup_list.extend(_cleanup8);
                                for (i, e) in vec8.into_iter().enumerate() {
                                    let base = result8
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let (t5_0, t5_1) = e;
                                        let vec6 = t5_0;
                                        let ptr6 = vec6.as_ptr().cast::<u8>();
                                        let len6 = vec6.len();
                                        *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len6;
                                        *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                                        let vec7 = t5_1;
                                        let ptr7 = vec7.as_ptr().cast::<u8>();
                                        let len7 = vec7.len();
                                        *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len7;
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr7.cast_mut();
                                    }
                                }
                                *base
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len8;
                                *base
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result8;
                                let vec9 = parent_span_id0;
                                let ptr9 = vec9.as_ptr().cast::<u8>();
                                let len9 = vec9.len();
                                *base
                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len9;
                                *base
                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = ptr9.cast_mut();
                                *base
                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>() = (span_kind0.clone() as i32) as u8;
                                let vec10 = name0;
                                let ptr10 = vec10.as_ptr().cast::<u8>();
                                let len10 = vec10.len();
                                *base
                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len10;
                                *base
                                    .add(10 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = ptr10.cast_mut();
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds11,
                                    nanoseconds: nanoseconds11,
                                } = start_time0;
                                *base
                                    .add(12 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i64>() = _rt::as_i64(seconds11);
                                *base
                                    .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>() = _rt::as_i32(nanoseconds11);
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds12,
                                    nanoseconds: nanoseconds12,
                                } = end_time0;
                                *base
                                    .add(16 + 12 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i64>() = _rt::as_i64(seconds12);
                                *base
                                    .add(24 + 12 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>() = _rt::as_i32(nanoseconds12);
                                let vec22 = attributes0;
                                let len22 = vec22.len();
                                let layout22 = _rt::alloc::Layout::from_size_align(
                                        vec22.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    )
                                    .unwrap();
                                let (result22, _cleanup22) = wit_bindgen::rt::Cleanup::new(
                                    layout22,
                                );
                                cleanup_list.extend(_cleanup22);
                                for (i, e) in vec22.into_iter().enumerate() {
                                    let base = result22
                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let super::super::super::wasi::otel::types::KeyValue {
                                            key: key13,
                                            value: value13,
                                        } = e;
                                        let vec14 = key13;
                                        let ptr14 = vec14.as_ptr().cast::<u8>();
                                        let len14 = vec14.len();
                                        *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len14;
                                        *base.add(0).cast::<*mut u8>() = ptr14.cast_mut();
                                        use super::super::super::wasi::otel::types::Value as V21;
                                        match value13 {
                                            V21::String(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (0i32) as u8;
                                                let vec15 = e;
                                                let ptr15 = vec15.as_ptr().cast::<u8>();
                                                let len15 = vec15.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len15;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr15.cast_mut();
                                            }
                                            V21::Bool(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (1i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V21::F64(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (2i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>() = _rt::as_f64(e);
                                            }
                                            V21::S64(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (3i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>() = _rt::as_i64(e);
                                            }
                                            V21::StringArray(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (4i32) as u8;
                                                let vec17 = e;
                                                let len17 = vec17.len();
                                                let layout17 = _rt::alloc::Layout::from_size_align(
                                                        vec17.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    )
                                                    .unwrap();
                                                let (result17, _cleanup17) = wit_bindgen::rt::Cleanup::new(
                                                    layout17,
                                                );
                                                cleanup_list.extend(_cleanup17);
                                                for (i, e) in vec17.into_iter().enumerate() {
                                                    let base = result17
                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        let vec16 = e;
                                                        let ptr16 = vec16.as_ptr().cast::<u8>();
                                                        let len16 = vec16.len();
                                                        *base
                                                            .add(::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len16;
                                                        *base.add(0).cast::<*mut u8>() = ptr16.cast_mut();
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len17;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result17;
                                            }
                                            V21::BoolArray(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (5i32) as u8;
                                                let vec18 = e;
                                                let len18 = vec18.len();
                                                let layout18 = _rt::alloc::Layout::from_size_align(
                                                        vec18.len() * 1,
                                                        1,
                                                    )
                                                    .unwrap();
                                                let (result18, _cleanup18) = wit_bindgen::rt::Cleanup::new(
                                                    layout18,
                                                );
                                                cleanup_list.extend(_cleanup18);
                                                for (i, e) in vec18.into_iter().enumerate() {
                                                    let base = result18.add(i * 1);
                                                    {
                                                        *base.add(0).cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len18;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result18;
                                            }
                                            V21::F64Array(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (6i32) as u8;
                                                let vec19 = e;
                                                let ptr19 = vec19.as_ptr().cast::<u8>();
                                                let len19 = vec19.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len19;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr19.cast_mut();
                                            }
                                            V21::S64Array(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (7i32) as u8;
                                                let vec20 = e;
                                                let ptr20 = vec20.as_ptr().cast::<u8>();
                                                let len20 = vec20.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len20;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr20.cast_mut();
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(32 + 13 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len22;
                                *base
                                    .add(32 + 12 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result22;
                                let vec36 = events0;
                                let len36 = vec36.len();
                                let layout36 = _rt::alloc::Layout::from_size_align(
                                        vec36.len()
                                            * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    )
                                    .unwrap();
                                let (result36, _cleanup36) = wit_bindgen::rt::Cleanup::new(
                                    layout36,
                                );
                                cleanup_list.extend(_cleanup36);
                                for (i, e) in vec36.into_iter().enumerate() {
                                    let base = result36
                                        .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let Event {
                                            name: name23,
                                            time: time23,
                                            attributes: attributes23,
                                        } = e;
                                        let vec24 = name23;
                                        let ptr24 = vec24.as_ptr().cast::<u8>();
                                        let len24 = vec24.len();
                                        *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len24;
                                        *base.add(0).cast::<*mut u8>() = ptr24.cast_mut();
                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                            seconds: seconds25,
                                            nanoseconds: nanoseconds25,
                                        } = time23;
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>() = _rt::as_i64(seconds25);
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i32>() = _rt::as_i32(nanoseconds25);
                                        let vec35 = attributes23;
                                        let len35 = vec35.len();
                                        let layout35 = _rt::alloc::Layout::from_size_align(
                                                vec35.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                8,
                                            )
                                            .unwrap();
                                        let (result35, _cleanup35) = wit_bindgen::rt::Cleanup::new(
                                            layout35,
                                        );
                                        cleanup_list.extend(_cleanup35);
                                        for (i, e) in vec35.into_iter().enumerate() {
                                            let base = result35
                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                            {
                                                let super::super::super::wasi::otel::types::KeyValue {
                                                    key: key26,
                                                    value: value26,
                                                } = e;
                                                let vec27 = key26;
                                                let ptr27 = vec27.as_ptr().cast::<u8>();
                                                let len27 = vec27.len();
                                                *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len27;
                                                *base.add(0).cast::<*mut u8>() = ptr27.cast_mut();
                                                use super::super::super::wasi::otel::types::Value as V34;
                                                match value26 {
                                                    V34::String(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (0i32) as u8;
                                                        let vec28 = e;
                                                        let ptr28 = vec28.as_ptr().cast::<u8>();
                                                        let len28 = vec28.len();
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len28;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr28.cast_mut();
                                                    }
                                                    V34::Bool(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (1i32) as u8;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V34::F64(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (2i32) as u8;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<f64>() = _rt::as_f64(e);
                                                    }
                                                    V34::S64(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (3i32) as u8;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(e);
                                                    }
                                                    V34::StringArray(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (4i32) as u8;
                                                        let vec30 = e;
                                                        let len30 = vec30.len();
                                                        let layout30 = _rt::alloc::Layout::from_size_align(
                                                                vec30.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            )
                                                            .unwrap();
                                                        let (result30, _cleanup30) = wit_bindgen::rt::Cleanup::new(
                                                            layout30,
                                                        );
                                                        cleanup_list.extend(_cleanup30);
                                                        for (i, e) in vec30.into_iter().enumerate() {
                                                            let base = result30
                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let vec29 = e;
                                                                let ptr29 = vec29.as_ptr().cast::<u8>();
                                                                let len29 = vec29.len();
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len29;
                                                                *base.add(0).cast::<*mut u8>() = ptr29.cast_mut();
                                                            }
                                                        }
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len30;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result30;
                                                    }
                                                    V34::BoolArray(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (5i32) as u8;
                                                        let vec31 = e;
                                                        let len31 = vec31.len();
                                                        let layout31 = _rt::alloc::Layout::from_size_align(
                                                                vec31.len() * 1,
                                                                1,
                                                            )
                                                            .unwrap();
                                                        let (result31, _cleanup31) = wit_bindgen::rt::Cleanup::new(
                                                            layout31,
                                                        );
                                                        cleanup_list.extend(_cleanup31);
                                                        for (i, e) in vec31.into_iter().enumerate() {
                                                            let base = result31.add(i * 1);
                                                            {
                                                                *base.add(0).cast::<u8>() = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                        }
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len31;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result31;
                                                    }
                                                    V34::F64Array(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (6i32) as u8;
                                                        let vec32 = e;
                                                        let ptr32 = vec32.as_ptr().cast::<u8>();
                                                        let len32 = vec32.len();
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len32;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr32.cast_mut();
                                                    }
                                                    V34::S64Array(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (7i32) as u8;
                                                        let vec33 = e;
                                                        let ptr33 = vec33.as_ptr().cast::<u8>();
                                                        let len33 = vec33.len();
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len33;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr33.cast_mut();
                                                    }
                                                }
                                            }
                                        }
                                        *base
                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len35;
                                        *base
                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = result35;
                                    }
                                }
                                *base
                                    .add(32 + 15 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len36;
                                *base
                                    .add(32 + 14 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result36;
                                let vec56 = links0;
                                let len56 = vec56.len();
                                let layout56 = _rt::alloc::Layout::from_size_align(
                                        vec56.len() * (9 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    )
                                    .unwrap();
                                let (result56, _cleanup56) = wit_bindgen::rt::Cleanup::new(
                                    layout56,
                                );
                                cleanup_list.extend(_cleanup56);
                                for (i, e) in vec56.into_iter().enumerate() {
                                    let base = result56
                                        .add(i * (9 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let Link {
                                            span_context: span_context37,
                                            attributes: attributes37,
                                        } = e;
                                        let SpanContext {
                                            trace_id: trace_id38,
                                            span_id: span_id38,
                                            trace_flags: trace_flags38,
                                            is_remote: is_remote38,
                                            trace_state: trace_state38,
                                        } = span_context37;
                                        let vec39 = trace_id38;
                                        let ptr39 = vec39.as_ptr().cast::<u8>();
                                        let len39 = vec39.len();
                                        *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len39;
                                        *base.add(0).cast::<*mut u8>() = ptr39.cast_mut();
                                        let vec40 = span_id38;
                                        let ptr40 = vec40.as_ptr().cast::<u8>();
                                        let len40 = vec40.len();
                                        *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len40;
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr40.cast_mut();
                                        let flags41 = trace_flags38;
                                        *base
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = ((flags41.bits() >> 0) as i32) as u8;
                                        *base
                                            .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (match is_remote38 {
                                            true => 1,
                                            false => 0,
                                        }) as u8;
                                        let vec45 = trace_state38;
                                        let len45 = vec45.len();
                                        let layout45 = _rt::alloc::Layout::from_size_align(
                                                vec45.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            )
                                            .unwrap();
                                        let (result45, _cleanup45) = wit_bindgen::rt::Cleanup::new(
                                            layout45,
                                        );
                                        cleanup_list.extend(_cleanup45);
                                        for (i, e) in vec45.into_iter().enumerate() {
                                            let base = result45
                                                .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                            {
                                                let (t42_0, t42_1) = e;
                                                let vec43 = t42_0;
                                                let ptr43 = vec43.as_ptr().cast::<u8>();
                                                let len43 = vec43.len();
                                                *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len43;
                                                *base.add(0).cast::<*mut u8>() = ptr43.cast_mut();
                                                let vec44 = t42_1;
                                                let ptr44 = vec44.as_ptr().cast::<u8>();
                                                let len44 = vec44.len();
                                                *base
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len44;
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr44.cast_mut();
                                            }
                                        }
                                        *base
                                            .add(6 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len45;
                                        *base
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = result45;
                                        let vec55 = attributes37;
                                        let len55 = vec55.len();
                                        let layout55 = _rt::alloc::Layout::from_size_align(
                                                vec55.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                8,
                                            )
                                            .unwrap();
                                        let (result55, _cleanup55) = wit_bindgen::rt::Cleanup::new(
                                            layout55,
                                        );
                                        cleanup_list.extend(_cleanup55);
                                        for (i, e) in vec55.into_iter().enumerate() {
                                            let base = result55
                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                            {
                                                let super::super::super::wasi::otel::types::KeyValue {
                                                    key: key46,
                                                    value: value46,
                                                } = e;
                                                let vec47 = key46;
                                                let ptr47 = vec47.as_ptr().cast::<u8>();
                                                let len47 = vec47.len();
                                                *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len47;
                                                *base.add(0).cast::<*mut u8>() = ptr47.cast_mut();
                                                use super::super::super::wasi::otel::types::Value as V54;
                                                match value46 {
                                                    V54::String(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (0i32) as u8;
                                                        let vec48 = e;
                                                        let ptr48 = vec48.as_ptr().cast::<u8>();
                                                        let len48 = vec48.len();
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len48;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr48.cast_mut();
                                                    }
                                                    V54::Bool(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (1i32) as u8;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V54::F64(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (2i32) as u8;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<f64>() = _rt::as_f64(e);
                                                    }
                                                    V54::S64(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (3i32) as u8;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(e);
                                                    }
                                                    V54::StringArray(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (4i32) as u8;
                                                        let vec50 = e;
                                                        let len50 = vec50.len();
                                                        let layout50 = _rt::alloc::Layout::from_size_align(
                                                                vec50.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                ::core::mem::size_of::<*const u8>(),
                                                            )
                                                            .unwrap();
                                                        let (result50, _cleanup50) = wit_bindgen::rt::Cleanup::new(
                                                            layout50,
                                                        );
                                                        cleanup_list.extend(_cleanup50);
                                                        for (i, e) in vec50.into_iter().enumerate() {
                                                            let base = result50
                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let vec49 = e;
                                                                let ptr49 = vec49.as_ptr().cast::<u8>();
                                                                let len49 = vec49.len();
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len49;
                                                                *base.add(0).cast::<*mut u8>() = ptr49.cast_mut();
                                                            }
                                                        }
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len50;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result50;
                                                    }
                                                    V54::BoolArray(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (5i32) as u8;
                                                        let vec51 = e;
                                                        let len51 = vec51.len();
                                                        let layout51 = _rt::alloc::Layout::from_size_align(
                                                                vec51.len() * 1,
                                                                1,
                                                            )
                                                            .unwrap();
                                                        let (result51, _cleanup51) = wit_bindgen::rt::Cleanup::new(
                                                            layout51,
                                                        );
                                                        cleanup_list.extend(_cleanup51);
                                                        for (i, e) in vec51.into_iter().enumerate() {
                                                            let base = result51.add(i * 1);
                                                            {
                                                                *base.add(0).cast::<u8>() = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                        }
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len51;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result51;
                                                    }
                                                    V54::F64Array(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (6i32) as u8;
                                                        let vec52 = e;
                                                        let ptr52 = vec52.as_ptr().cast::<u8>();
                                                        let len52 = vec52.len();
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len52;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr52.cast_mut();
                                                    }
                                                    V54::S64Array(e) => {
                                                        *base
                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (7i32) as u8;
                                                        let vec53 = e;
                                                        let ptr53 = vec53.as_ptr().cast::<u8>();
                                                        let len53 = vec53.len();
                                                        *base
                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len53;
                                                        *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = ptr53.cast_mut();
                                                    }
                                                }
                                            }
                                        }
                                        *base
                                            .add(8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len55;
                                        *base
                                            .add(7 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = result55;
                                    }
                                }
                                *base
                                    .add(32 + 17 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len56;
                                *base
                                    .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result56;
                                match status0 {
                                    Status::Unset => {
                                        *base
                                            .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (0i32) as u8;
                                    }
                                    Status::Ok => {
                                        *base
                                            .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (1i32) as u8;
                                    }
                                    Status::Error(e) => {
                                        *base
                                            .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (2i32) as u8;
                                        let vec57 = e;
                                        let ptr57 = vec57.as_ptr().cast::<u8>();
                                        let len57 = vec57.len();
                                        *base
                                            .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len57;
                                        *base
                                            .add(32 + 19 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr57.cast_mut();
                                    }
                                }
                                let super::super::super::wasi::otel::types::InstrumentationScope {
                                    name: name58,
                                    version: version58,
                                    schema_url: schema_url58,
                                    attributes: attributes58,
                                } = instrumentation_scope0;
                                let vec59 = name58;
                                let ptr59 = vec59.as_ptr().cast::<u8>();
                                let len59 = vec59.len();
                                *base
                                    .add(32 + 22 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len59;
                                *base
                                    .add(32 + 21 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = ptr59.cast_mut();
                                match version58 {
                                    Some(e) => {
                                        *base
                                            .add(32 + 23 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (1i32) as u8;
                                        let vec60 = e;
                                        let ptr60 = vec60.as_ptr().cast::<u8>();
                                        let len60 = vec60.len();
                                        *base
                                            .add(32 + 25 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len60;
                                        *base
                                            .add(32 + 24 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr60.cast_mut();
                                    }
                                    None => {
                                        *base
                                            .add(32 + 23 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (0i32) as u8;
                                    }
                                };
                                match schema_url58 {
                                    Some(e) => {
                                        *base
                                            .add(32 + 26 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (1i32) as u8;
                                        let vec61 = e;
                                        let ptr61 = vec61.as_ptr().cast::<u8>();
                                        let len61 = vec61.len();
                                        *base
                                            .add(32 + 28 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len61;
                                        *base
                                            .add(32 + 27 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr61.cast_mut();
                                    }
                                    None => {
                                        *base
                                            .add(32 + 26 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (0i32) as u8;
                                    }
                                };
                                let vec71 = attributes58;
                                let len71 = vec71.len();
                                let layout71 = _rt::alloc::Layout::from_size_align(
                                        vec71.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    )
                                    .unwrap();
                                let (result71, _cleanup71) = wit_bindgen::rt::Cleanup::new(
                                    layout71,
                                );
                                cleanup_list.extend(_cleanup71);
                                for (i, e) in vec71.into_iter().enumerate() {
                                    let base = result71
                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let super::super::super::wasi::otel::types::KeyValue {
                                            key: key62,
                                            value: value62,
                                        } = e;
                                        let vec63 = key62;
                                        let ptr63 = vec63.as_ptr().cast::<u8>();
                                        let len63 = vec63.len();
                                        *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len63;
                                        *base.add(0).cast::<*mut u8>() = ptr63.cast_mut();
                                        use super::super::super::wasi::otel::types::Value as V70;
                                        match value62 {
                                            V70::String(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (0i32) as u8;
                                                let vec64 = e;
                                                let ptr64 = vec64.as_ptr().cast::<u8>();
                                                let len64 = vec64.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len64;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr64.cast_mut();
                                            }
                                            V70::Bool(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (1i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V70::F64(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (2i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>() = _rt::as_f64(e);
                                            }
                                            V70::S64(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (3i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>() = _rt::as_i64(e);
                                            }
                                            V70::StringArray(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (4i32) as u8;
                                                let vec66 = e;
                                                let len66 = vec66.len();
                                                let layout66 = _rt::alloc::Layout::from_size_align(
                                                        vec66.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    )
                                                    .unwrap();
                                                let (result66, _cleanup66) = wit_bindgen::rt::Cleanup::new(
                                                    layout66,
                                                );
                                                cleanup_list.extend(_cleanup66);
                                                for (i, e) in vec66.into_iter().enumerate() {
                                                    let base = result66
                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        let vec65 = e;
                                                        let ptr65 = vec65.as_ptr().cast::<u8>();
                                                        let len65 = vec65.len();
                                                        *base
                                                            .add(::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len65;
                                                        *base.add(0).cast::<*mut u8>() = ptr65.cast_mut();
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len66;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result66;
                                            }
                                            V70::BoolArray(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (5i32) as u8;
                                                let vec67 = e;
                                                let len67 = vec67.len();
                                                let layout67 = _rt::alloc::Layout::from_size_align(
                                                        vec67.len() * 1,
                                                        1,
                                                    )
                                                    .unwrap();
                                                let (result67, _cleanup67) = wit_bindgen::rt::Cleanup::new(
                                                    layout67,
                                                );
                                                cleanup_list.extend(_cleanup67);
                                                for (i, e) in vec67.into_iter().enumerate() {
                                                    let base = result67.add(i * 1);
                                                    {
                                                        *base.add(0).cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len67;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result67;
                                            }
                                            V70::F64Array(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (6i32) as u8;
                                                let vec68 = e;
                                                let ptr68 = vec68.as_ptr().cast::<u8>();
                                                let len68 = vec68.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len68;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr68.cast_mut();
                                            }
                                            V70::S64Array(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (7i32) as u8;
                                                let vec69 = e;
                                                let ptr69 = vec69.as_ptr().cast::<u8>();
                                                let len69 = vec69.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len69;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr69.cast_mut();
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(32 + 30 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len71;
                                *base
                                    .add(32 + 29 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result71;
                                *base
                                    .add(32 + 31 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>() = _rt::as_i32(dropped_attributes0);
                                *base
                                    .add(36 + 31 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>() = _rt::as_i32(dropped_events0);
                                *base
                                    .add(40 + 31 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>() = _rt::as_i32(dropped_links0);
                            }
                        }
                        let ptr73 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import74(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import74(result72, len72, ptr73);
                        let l75 = i32::from(*ptr73.add(0).cast::<u8>());
                        let result82 = match l75 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l76 = i32::from(*ptr73.add(8).cast::<u8>());
                                    use super::super::super::wasi::otel::types::Error as V81;
                                    let v81 = match l76 {
                                        0 => V81::AlreadyShutdown,
                                        1 => {
                                            let e81 = {
                                                let l77 = *ptr73.add(16).cast::<i64>();
                                                l77 as u64
                                            };
                                            V81::Timeout(e81)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &2) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e81 = {
                                                let l78 = *ptr73.add(16).cast::<*mut u8>();
                                                let l79 = *ptr73
                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len80 = l79;
                                                let bytes80 = _rt::Vec::from_raw_parts(
                                                    l78.cast(),
                                                    len80,
                                                    len80,
                                                );
                                                _rt::string_lift(bytes80)
                                            };
                                            V81::InternalFailure(e81)
                                        }
                                    };
                                    v81
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result82
                    }
                }
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod metrics {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
                pub type KeyValue = super::super::super::wasi::otel::types::KeyValue;
                pub type InstrumentationScope = super::super::super::wasi::otel::types::InstrumentationScope;
                pub type Resource = super::super::super::wasi::otel::types::Resource;
                pub type Error = super::super::super::wasi::otel::types::Error;
                /// A set of bucket counts, encoded in a contiguous array of counts.
                pub struct ExponentialBucket {
                    /// The bucket index of the first entry in the `counts` vec.
                    pub offset: i32,
                    /// A vec where `counts[i]` carries the count of the bucket at index `offset + i`.
                    ///
                    /// `counts[i]` is the count of values greater than base^(offset+i) and less than
                    /// or equal to base^(offset+i+1).
                    pub counts: _rt::Vec<u64>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ExponentialBucket {
                    #[inline]
                    fn clone(&self) -> ExponentialBucket {
                        ExponentialBucket {
                            offset: ::core::clone::Clone::clone(&self.offset),
                            counts: ::core::clone::Clone::clone(&self.counts),
                        }
                    }
                }
                impl ::core::fmt::Debug for ExponentialBucket {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ExponentialBucket")
                            .field("offset", &self.offset)
                            .field("counts", &self.counts)
                            .finish()
                    }
                }
                /// Defines the window that an aggregation was calculated over.
                #[repr(u8)]
                pub enum Temporality {
                    /// A measurement interval that continues to expand forward in time from a
                    /// starting point.
                    ///
                    /// New measurements are added to all previous measurements since a start time.
                    Cumulative,
                    /// A measurement interval that resets each cycle.
                    ///
                    /// Measurements from one cycle are recorded independently, measurements from
                    /// other cycles do not affect them.
                    Delta,
                    /// Configures Synchronous Counter and Histogram instruments to use
                    /// Delta aggregation temporality, which allows them to shed memory
                    /// following a cardinality explosion, thus use less memory.
                    LowMemory,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Temporality {
                    #[inline]
                    fn clone(&self) -> Temporality {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Temporality {}
                #[automatically_derived]
                impl ::core::cmp::Eq for Temporality {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for Temporality {
                    #[inline]
                    fn cmp(&self, other: &Temporality) -> ::core::cmp::Ordering {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Temporality {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Temporality {
                    #[inline]
                    fn eq(&self, other: &Temporality) -> bool {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        __self_discr == __arg1_discr
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for Temporality {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &Temporality,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
                impl ::core::fmt::Debug for Temporality {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Temporality::Cumulative => {
                                f.debug_tuple("Temporality::Cumulative").finish()
                            }
                            Temporality::Delta => {
                                f.debug_tuple("Temporality::Delta").finish()
                            }
                            Temporality::LowMemory => {
                                f.debug_tuple("Temporality::LowMemory").finish()
                            }
                        }
                    }
                }
                impl Temporality {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> Temporality {
                        if !true {
                            return unsafe { ::core::mem::transmute(val) };
                        }
                        match val {
                            0 => Temporality::Cumulative,
                            1 => Temporality::Delta,
                            2 => Temporality::LowMemory,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        }
                    }
                }
                pub enum DataValue {
                    /// All metric data with `f64` value type
                    F64(f64),
                    /// All metric data with `u64` value type
                    U64(u64),
                    /// All metric data with `s64` value type
                    S64(i64),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for DataValue {
                    #[inline]
                    fn clone(&self) -> DataValue {
                        let _: ::core::clone::AssertParamIsClone<f64>;
                        let _: ::core::clone::AssertParamIsClone<u64>;
                        let _: ::core::clone::AssertParamIsClone<i64>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for DataValue {}
                impl ::core::fmt::Debug for DataValue {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            DataValue::F64(e) => {
                                f.debug_tuple("DataValue::F64").field(e).finish()
                            }
                            DataValue::U64(e) => {
                                f.debug_tuple("DataValue::U64").field(e).finish()
                            }
                            DataValue::S64(e) => {
                                f.debug_tuple("DataValue::S64").field(e).finish()
                            }
                        }
                    }
                }
                /// A measurement sampled from a time series providing a typical example.
                pub struct Exemplar {
                    /// The attributes recorded with the measurement but filtered out of the
                    /// time series' aggregated data.
                    pub filtered_attributes: _rt::Vec<KeyValue>,
                    /// The time when the measurement was recorded.
                    pub time: Datetime,
                    /// The measured value.
                    pub value: DataValue,
                    /// The ID of the span that was active during the measurement.
                    ///
                    /// If no span was active or the span was not sampled this will be empty.
                    pub span_id: _rt::String,
                    /// The ID of the trace the active span belonged to during the measurement.
                    ///
                    /// If no span was active or the span was not sampled this will be empty.
                    pub trace_id: _rt::String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Exemplar {
                    #[inline]
                    fn clone(&self) -> Exemplar {
                        Exemplar {
                            filtered_attributes: ::core::clone::Clone::clone(
                                &self.filtered_attributes,
                            ),
                            time: ::core::clone::Clone::clone(&self.time),
                            value: ::core::clone::Clone::clone(&self.value),
                            span_id: ::core::clone::Clone::clone(&self.span_id),
                            trace_id: ::core::clone::Clone::clone(&self.trace_id),
                        }
                    }
                }
                impl ::core::fmt::Debug for Exemplar {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Exemplar")
                            .field("filtered-attributes", &self.filtered_attributes)
                            .field("time", &self.time)
                            .field("value", &self.value)
                            .field("span-id", &self.span_id)
                            .field("trace-id", &self.trace_id)
                            .finish()
                    }
                }
                /// DataPoint is a single data point in a time series.
                pub struct GaugeDataPoint {
                    /// Attributes is the set of key value pairs that uniquely identify the
                    /// time series.
                    pub attributes: _rt::Vec<KeyValue>,
                    /// The value of this data point.
                    pub value: DataValue,
                    /// The sampled exemplars collected during the time series.
                    pub exemplars: _rt::Vec<Exemplar>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for GaugeDataPoint {
                    #[inline]
                    fn clone(&self) -> GaugeDataPoint {
                        GaugeDataPoint {
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                            value: ::core::clone::Clone::clone(&self.value),
                            exemplars: ::core::clone::Clone::clone(&self.exemplars),
                        }
                    }
                }
                impl ::core::fmt::Debug for GaugeDataPoint {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("GaugeDataPoint")
                            .field("attributes", &self.attributes)
                            .field("value", &self.value)
                            .field("exemplars", &self.exemplars)
                            .finish()
                    }
                }
                /// A measurement of the current value of an instrument.
                pub struct Gauge {
                    /// Represents individual aggregated measurements with unique attributes.
                    pub data_points: _rt::Vec<GaugeDataPoint>,
                    /// The time when the time series was started.
                    pub start_time: Option<Datetime>,
                    /// The time when the time series was recorded.
                    pub time: Datetime,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Gauge {
                    #[inline]
                    fn clone(&self) -> Gauge {
                        Gauge {
                            data_points: ::core::clone::Clone::clone(&self.data_points),
                            start_time: ::core::clone::Clone::clone(&self.start_time),
                            time: ::core::clone::Clone::clone(&self.time),
                        }
                    }
                }
                impl ::core::fmt::Debug for Gauge {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Gauge")
                            .field("data-points", &self.data_points)
                            .field("start-time", &self.start_time)
                            .field("time", &self.time)
                            .finish()
                    }
                }
                /// DataPoint is a single data point in a time series.
                pub struct SumDataPoint {
                    /// Attributes is the set of key value pairs that uniquely identify the
                    /// time series.
                    pub attributes: _rt::Vec<KeyValue>,
                    /// The value of this data point.
                    pub value: DataValue,
                    /// The sampled exemplars collected during the time series.
                    pub exemplars: _rt::Vec<Exemplar>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SumDataPoint {
                    #[inline]
                    fn clone(&self) -> SumDataPoint {
                        SumDataPoint {
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                            value: ::core::clone::Clone::clone(&self.value),
                            exemplars: ::core::clone::Clone::clone(&self.exemplars),
                        }
                    }
                }
                impl ::core::fmt::Debug for SumDataPoint {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SumDataPoint")
                            .field("attributes", &self.attributes)
                            .field("value", &self.value)
                            .field("exemplars", &self.exemplars)
                            .finish()
                    }
                }
                /// Represents the sum of all measurements of values from an instrument.
                pub struct Sum {
                    /// Represents individual aggregated measurements with unique attributes.
                    pub data_points: _rt::Vec<SumDataPoint>,
                    /// The time when the time series was started.
                    pub start_time: Datetime,
                    /// The time when the time series was recorded.
                    pub time: Datetime,
                    /// Describes if the aggregation is reported as the change from the last report
                    /// time, or the cumulative changes since a fixed start time.
                    pub temporality: Temporality,
                    /// Whether this aggregation only increases or decreases.
                    pub is_monotonic: bool,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Sum {
                    #[inline]
                    fn clone(&self) -> Sum {
                        Sum {
                            data_points: ::core::clone::Clone::clone(&self.data_points),
                            start_time: ::core::clone::Clone::clone(&self.start_time),
                            time: ::core::clone::Clone::clone(&self.time),
                            temporality: ::core::clone::Clone::clone(&self.temporality),
                            is_monotonic: ::core::clone::Clone::clone(&self.is_monotonic),
                        }
                    }
                }
                impl ::core::fmt::Debug for Sum {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Sum")
                            .field("data-points", &self.data_points)
                            .field("start-time", &self.start_time)
                            .field("time", &self.time)
                            .field("temporality", &self.temporality)
                            .field("is-monotonic", &self.is_monotonic)
                            .finish()
                    }
                }
                /// A single histogram data point in a time series.
                pub struct HistogramDataPoint {
                    /// The set of key value pairs that uniquely identify the time series.
                    pub attributes: _rt::Vec<KeyValue>,
                    /// The number of updates this histogram has been calculated with.
                    pub count: u64,
                    /// The upper bounds of the buckets of the histogram.
                    ///
                    /// Because the last boundary is +infinity this one is implied.
                    pub bounds: _rt::Vec<f64>,
                    /// The count of each of the buckets.
                    pub bucket_counts: _rt::Vec<u64>,
                    /// The minimum value recorded.
                    pub min: Option<DataValue>,
                    /// The maximum value recorded.
                    pub max: Option<DataValue>,
                    /// The sum of the values recorded.
                    pub sum: DataValue,
                    /// The sampled exemplars collected during the time series.
                    pub exemplars: _rt::Vec<Exemplar>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for HistogramDataPoint {
                    #[inline]
                    fn clone(&self) -> HistogramDataPoint {
                        HistogramDataPoint {
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                            count: ::core::clone::Clone::clone(&self.count),
                            bounds: ::core::clone::Clone::clone(&self.bounds),
                            bucket_counts: ::core::clone::Clone::clone(
                                &self.bucket_counts,
                            ),
                            min: ::core::clone::Clone::clone(&self.min),
                            max: ::core::clone::Clone::clone(&self.max),
                            sum: ::core::clone::Clone::clone(&self.sum),
                            exemplars: ::core::clone::Clone::clone(&self.exemplars),
                        }
                    }
                }
                impl ::core::fmt::Debug for HistogramDataPoint {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("HistogramDataPoint")
                            .field("attributes", &self.attributes)
                            .field("count", &self.count)
                            .field("bounds", &self.bounds)
                            .field("bucket-counts", &self.bucket_counts)
                            .field("min", &self.min)
                            .field("max", &self.max)
                            .field("sum", &self.sum)
                            .field("exemplars", &self.exemplars)
                            .finish()
                    }
                }
                /// Represents the histogram of all measurements of values from an instrument.
                pub struct Histogram {
                    /// Individual aggregated measurements with unique attributes.
                    pub data_points: _rt::Vec<HistogramDataPoint>,
                    /// The time when the time series was started.
                    pub start_time: Datetime,
                    /// The time when the time series was recorded.
                    pub time: Datetime,
                    /// Describes if the aggregation is reported as the change from the last report
                    /// time, or the cumulative changes since a fixed start time.
                    pub temporality: Temporality,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Histogram {
                    #[inline]
                    fn clone(&self) -> Histogram {
                        Histogram {
                            data_points: ::core::clone::Clone::clone(&self.data_points),
                            start_time: ::core::clone::Clone::clone(&self.start_time),
                            time: ::core::clone::Clone::clone(&self.time),
                            temporality: ::core::clone::Clone::clone(&self.temporality),
                        }
                    }
                }
                impl ::core::fmt::Debug for Histogram {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Histogram")
                            .field("data-points", &self.data_points)
                            .field("start-time", &self.start_time)
                            .field("time", &self.time)
                            .field("temporality", &self.temporality)
                            .finish()
                    }
                }
                /// A single exponential histogram data point in a time series.
                pub struct ExponentialHistogramDataPoint {
                    /// The set of key value pairs that uniquely identify the time series.
                    pub attributes: _rt::Vec<KeyValue>,
                    /// The number of updates this histogram has been calculated with.
                    pub count: u64,
                    /// The minimum value recorded.
                    pub min: Option<DataValue>,
                    /// The maximum value recorded.
                    pub max: Option<DataValue>,
                    /// The sum of the values recorded.
                    pub sum: DataValue,
                    /// Describes the resolution of the histogram.
                    ///
                    /// Boundaries are located at powers of the base, where:
                    ///
                    ///   base = 2 ^ (2 ^ -scale)
                    pub scale: i8,
                    /// The number of values whose absolute value is less than or equal to
                    /// `zero_threshold`.
                    ///
                    /// When `zero_threshold` is `0`, this is the number of values that cannot be
                    /// expressed using the standard exponential formula as well as values that have
                    /// been rounded to zero.
                    pub zero_count: u64,
                    /// The range of positive value bucket counts.
                    pub positive_bucket: ExponentialBucket,
                    /// The range of negative value bucket counts.
                    pub negative_bucket: ExponentialBucket,
                    /// The width of the zero region.
                    ///
                    /// Where the zero region is defined as the closed interval
                    /// [-zero_threshold, zero_threshold].
                    pub zero_threshold: f64,
                    /// The sampled exemplars collected during the time series.
                    pub exemplars: _rt::Vec<Exemplar>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ExponentialHistogramDataPoint {
                    #[inline]
                    fn clone(&self) -> ExponentialHistogramDataPoint {
                        ExponentialHistogramDataPoint {
                            attributes: ::core::clone::Clone::clone(&self.attributes),
                            count: ::core::clone::Clone::clone(&self.count),
                            min: ::core::clone::Clone::clone(&self.min),
                            max: ::core::clone::Clone::clone(&self.max),
                            sum: ::core::clone::Clone::clone(&self.sum),
                            scale: ::core::clone::Clone::clone(&self.scale),
                            zero_count: ::core::clone::Clone::clone(&self.zero_count),
                            positive_bucket: ::core::clone::Clone::clone(
                                &self.positive_bucket,
                            ),
                            negative_bucket: ::core::clone::Clone::clone(
                                &self.negative_bucket,
                            ),
                            zero_threshold: ::core::clone::Clone::clone(
                                &self.zero_threshold,
                            ),
                            exemplars: ::core::clone::Clone::clone(&self.exemplars),
                        }
                    }
                }
                impl ::core::fmt::Debug for ExponentialHistogramDataPoint {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ExponentialHistogramDataPoint")
                            .field("attributes", &self.attributes)
                            .field("count", &self.count)
                            .field("min", &self.min)
                            .field("max", &self.max)
                            .field("sum", &self.sum)
                            .field("scale", &self.scale)
                            .field("zero-count", &self.zero_count)
                            .field("positive-bucket", &self.positive_bucket)
                            .field("negative-bucket", &self.negative_bucket)
                            .field("zero-threshold", &self.zero_threshold)
                            .field("exemplars", &self.exemplars)
                            .finish()
                    }
                }
                /// The histogram of all measurements of values from an instrument.
                pub struct ExponentialHistogram {
                    /// The individual aggregated measurements with unique attributes.
                    pub data_points: _rt::Vec<ExponentialHistogramDataPoint>,
                    /// When the time series was started.
                    pub start_time: Datetime,
                    /// The time when the time series was recorded.
                    pub time: Datetime,
                    /// Describes if the aggregation is reported as the change from the last report
                    /// time, or the cumulative changes since a fixed start time.
                    pub temporality: Temporality,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ExponentialHistogram {
                    #[inline]
                    fn clone(&self) -> ExponentialHistogram {
                        ExponentialHistogram {
                            data_points: ::core::clone::Clone::clone(&self.data_points),
                            start_time: ::core::clone::Clone::clone(&self.start_time),
                            time: ::core::clone::Clone::clone(&self.time),
                            temporality: ::core::clone::Clone::clone(&self.temporality),
                        }
                    }
                }
                impl ::core::fmt::Debug for ExponentialHistogram {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ExponentialHistogram")
                            .field("data-points", &self.data_points)
                            .field("start-time", &self.start_time)
                            .field("time", &self.time)
                            .field("temporality", &self.temporality)
                            .finish()
                    }
                }
                /// Metric data for all types
                pub enum MetricData {
                    /// Metric data for Gauge
                    Gauge(Gauge),
                    /// Metric data for Sum
                    Sum(Sum),
                    /// Metric data for Histogram
                    Histogram(Histogram),
                    /// Metric data for ExponentialHistogram
                    ExponentialHistogram(ExponentialHistogram),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for MetricData {
                    #[inline]
                    fn clone(&self) -> MetricData {
                        match self {
                            MetricData::Gauge(__self_0) => {
                                MetricData::Gauge(::core::clone::Clone::clone(__self_0))
                            }
                            MetricData::Sum(__self_0) => {
                                MetricData::Sum(::core::clone::Clone::clone(__self_0))
                            }
                            MetricData::Histogram(__self_0) => {
                                MetricData::Histogram(::core::clone::Clone::clone(__self_0))
                            }
                            MetricData::ExponentialHistogram(__self_0) => {
                                MetricData::ExponentialHistogram(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for MetricData {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            MetricData::Gauge(e) => {
                                f.debug_tuple("MetricData::Gauge").field(e).finish()
                            }
                            MetricData::Sum(e) => {
                                f.debug_tuple("MetricData::Sum").field(e).finish()
                            }
                            MetricData::Histogram(e) => {
                                f.debug_tuple("MetricData::Histogram").field(e).finish()
                            }
                            MetricData::ExponentialHistogram(e) => {
                                f.debug_tuple("MetricData::ExponentialHistogram")
                                    .field(e)
                                    .finish()
                            }
                        }
                    }
                }
                /// Aggregated metrics data from an instrument
                pub enum AggregatedMetrics {
                    /// All metric data with `f64` value type
                    F64(MetricData),
                    /// All metric data with `u64` value type
                    U64(MetricData),
                    /// All metric data with `i64` value type
                    S64(MetricData),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for AggregatedMetrics {
                    #[inline]
                    fn clone(&self) -> AggregatedMetrics {
                        match self {
                            AggregatedMetrics::F64(__self_0) => {
                                AggregatedMetrics::F64(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            AggregatedMetrics::U64(__self_0) => {
                                AggregatedMetrics::U64(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            AggregatedMetrics::S64(__self_0) => {
                                AggregatedMetrics::S64(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for AggregatedMetrics {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AggregatedMetrics::F64(e) => {
                                f.debug_tuple("AggregatedMetrics::F64").field(e).finish()
                            }
                            AggregatedMetrics::U64(e) => {
                                f.debug_tuple("AggregatedMetrics::U64").field(e).finish()
                            }
                            AggregatedMetrics::S64(e) => {
                                f.debug_tuple("AggregatedMetrics::S64").field(e).finish()
                            }
                        }
                    }
                }
                /// A collection of one or more aggregated time series from an [Instrument].
                ///
                /// [Instrument]: crate::metrics::Instrument
                pub struct Metric {
                    /// The name of the instrument that created this data.
                    pub name: _rt::String,
                    /// The description of the instrument, which can be used in documentation.
                    pub description: _rt::String,
                    /// The unit in which the instrument reports.
                    pub unit: _rt::String,
                    /// The aggregated data from an instrument.
                    pub data: AggregatedMetrics,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Metric {
                    #[inline]
                    fn clone(&self) -> Metric {
                        Metric {
                            name: ::core::clone::Clone::clone(&self.name),
                            description: ::core::clone::Clone::clone(&self.description),
                            unit: ::core::clone::Clone::clone(&self.unit),
                            data: ::core::clone::Clone::clone(&self.data),
                        }
                    }
                }
                impl ::core::fmt::Debug for Metric {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Metric")
                            .field("name", &self.name)
                            .field("description", &self.description)
                            .field("unit", &self.unit)
                            .field("data", &self.data)
                            .finish()
                    }
                }
                pub struct ScopeMetrics {
                    /// The instrumentation scope that the meter was created with.
                    pub scope: InstrumentationScope,
                    /// The list of aggregations created by the meter.
                    pub metrics: _rt::Vec<Metric>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ScopeMetrics {
                    #[inline]
                    fn clone(&self) -> ScopeMetrics {
                        ScopeMetrics {
                            scope: ::core::clone::Clone::clone(&self.scope),
                            metrics: ::core::clone::Clone::clone(&self.metrics),
                        }
                    }
                }
                impl ::core::fmt::Debug for ScopeMetrics {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ScopeMetrics")
                            .field("scope", &self.scope)
                            .field("metrics", &self.metrics)
                            .finish()
                    }
                }
                /// A collection of scope metrics and the associated resource that created them.
                pub struct ResourceMetrics {
                    /// The entity that collected the metrics.
                    pub resource: Resource,
                    /// The collection of metrics with unique [InstrumentationScope]s.
                    pub scope_metrics: _rt::Vec<ScopeMetrics>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ResourceMetrics {
                    #[inline]
                    fn clone(&self) -> ResourceMetrics {
                        ResourceMetrics {
                            resource: ::core::clone::Clone::clone(&self.resource),
                            scope_metrics: ::core::clone::Clone::clone(
                                &self.scope_metrics,
                            ),
                        }
                    }
                }
                impl ::core::fmt::Debug for ResourceMetrics {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ResourceMetrics")
                            .field("resource", &self.resource)
                            .field("scope-metrics", &self.scope_metrics)
                            .finish()
                    }
                }
                /// The identifier of a group of instruments that all perform the same function.
                #[repr(u8)]
                pub enum InstrumentKind {
                    /// Identifies a group of instruments that record increasing values synchronously
                    /// with the code path they are measuring.
                    Counter,
                    /// A group of instruments that record increasing and decreasing values
                    /// synchronously with the code path they are measuring.
                    UpDownCounter,
                    /// A group of instruments that record a distribution of values synchronously with
                    /// the code path they are measuring.
                    Histogram,
                    /// A group of instruments that record increasing values in an asynchronous
                    /// callback.
                    ObservableCounter,
                    /// A group of instruments that record increasing and decreasing values in an
                    /// asynchronous callback.
                    ObservableUpDownCounter,
                    /// a group of instruments that record current value synchronously with
                    /// the code path they are measuring.
                    Gauge,
                    /// a group of instruments that record current values in an asynchronous callback.
                    ObservableGauge,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for InstrumentKind {
                    #[inline]
                    fn clone(&self) -> InstrumentKind {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for InstrumentKind {}
                #[automatically_derived]
                impl ::core::cmp::Eq for InstrumentKind {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for InstrumentKind {
                    #[inline]
                    fn cmp(&self, other: &InstrumentKind) -> ::core::cmp::Ordering {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for InstrumentKind {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for InstrumentKind {
                    #[inline]
                    fn eq(&self, other: &InstrumentKind) -> bool {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        __self_discr == __arg1_discr
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for InstrumentKind {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &InstrumentKind,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        let __self_discr = ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
                impl ::core::fmt::Debug for InstrumentKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            InstrumentKind::Counter => {
                                f.debug_tuple("InstrumentKind::Counter").finish()
                            }
                            InstrumentKind::UpDownCounter => {
                                f.debug_tuple("InstrumentKind::UpDownCounter").finish()
                            }
                            InstrumentKind::Histogram => {
                                f.debug_tuple("InstrumentKind::Histogram").finish()
                            }
                            InstrumentKind::ObservableCounter => {
                                f.debug_tuple("InstrumentKind::ObservableCounter").finish()
                            }
                            InstrumentKind::ObservableUpDownCounter => {
                                f.debug_tuple("InstrumentKind::ObservableUpDownCounter")
                                    .finish()
                            }
                            InstrumentKind::Gauge => {
                                f.debug_tuple("InstrumentKind::Gauge").finish()
                            }
                            InstrumentKind::ObservableGauge => {
                                f.debug_tuple("InstrumentKind::ObservableGauge").finish()
                            }
                        }
                    }
                }
                impl InstrumentKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> InstrumentKind {
                        if !true {
                            return unsafe { ::core::mem::transmute(val) };
                        }
                        match val {
                            0 => InstrumentKind::Counter,
                            1 => InstrumentKind::UpDownCounter,
                            2 => InstrumentKind::Histogram,
                            3 => InstrumentKind::ObservableCounter,
                            4 => InstrumentKind::ObservableUpDownCounter,
                            5 => InstrumentKind::Gauge,
                            6 => InstrumentKind::ObservableGauge,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        }
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Gathers and returns all metric data related to the [MetricReader] from the
                /// SDK and stores it in the provided [ResourceMetrics] reference.
                ///
                /// An error is returned if this is called after shutdown.
                #[allow(async_fn_in_trait)]
                pub fn export(rm: &ResourceMetrics) -> Result<(), Error> {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 16 + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16
                                + 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let ResourceMetrics {
                            resource: resource0,
                            scope_metrics: scope_metrics0,
                        } = rm;
                        let super::super::super::wasi::otel::types::Resource {
                            attributes: attributes1,
                            schema_url: schema_url1,
                        } = resource0;
                        let vec11 = attributes1;
                        let len11 = vec11.len();
                        let layout11 = _rt::alloc::Layout::from_size_align(
                                vec11.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            )
                            .unwrap();
                        let (result11, _cleanup11) = wit_bindgen::rt::Cleanup::new(
                            layout11,
                        );
                        for (i, e) in vec11.into_iter().enumerate() {
                            let base = result11
                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                            {
                                let super::super::super::wasi::otel::types::KeyValue {
                                    key: key2,
                                    value: value2,
                                } = e;
                                let vec3 = key2;
                                let ptr3 = vec3.as_ptr().cast::<u8>();
                                let len3 = vec3.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len3;
                                *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                                use super::super::super::wasi::otel::types::Value as V10;
                                match value2 {
                                    V10::String(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (0i32) as u8;
                                        let vec4 = e;
                                        let ptr4 = vec4.as_ptr().cast::<u8>();
                                        let len4 = vec4.len();
                                        *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len4;
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr4.cast_mut();
                                    }
                                    V10::Bool(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (1i32) as u8;
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (match e {
                                            true => 1,
                                            false => 0,
                                        }) as u8;
                                    }
                                    V10::F64(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (2i32) as u8;
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<f64>() = _rt::as_f64(e);
                                    }
                                    V10::S64(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (3i32) as u8;
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>() = _rt::as_i64(e);
                                    }
                                    V10::StringArray(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (4i32) as u8;
                                        let vec6 = e;
                                        let len6 = vec6.len();
                                        let layout6 = _rt::alloc::Layout::from_size_align(
                                                vec6.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            )
                                            .unwrap();
                                        let (result6, _cleanup6) = wit_bindgen::rt::Cleanup::new(
                                            layout6,
                                        );
                                        cleanup_list.extend(_cleanup6);
                                        for (i, e) in vec6.into_iter().enumerate() {
                                            let base = result6
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            {
                                                let vec5 = e;
                                                let ptr5 = vec5.as_ptr().cast::<u8>();
                                                let len5 = vec5.len();
                                                *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len5;
                                                *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                                            }
                                        }
                                        *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len6;
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = result6;
                                    }
                                    V10::BoolArray(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (5i32) as u8;
                                        let vec7 = e;
                                        let len7 = vec7.len();
                                        let layout7 = _rt::alloc::Layout::from_size_align(
                                                vec7.len() * 1,
                                                1,
                                            )
                                            .unwrap();
                                        let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(
                                            layout7,
                                        );
                                        cleanup_list.extend(_cleanup7);
                                        for (i, e) in vec7.into_iter().enumerate() {
                                            let base = result7.add(i * 1);
                                            {
                                                *base.add(0).cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                        }
                                        *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len7;
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = result7;
                                    }
                                    V10::F64Array(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (6i32) as u8;
                                        let vec8 = e;
                                        let ptr8 = vec8.as_ptr().cast::<u8>();
                                        let len8 = vec8.len();
                                        *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len8;
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr8.cast_mut();
                                    }
                                    V10::S64Array(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (7i32) as u8;
                                        let vec9 = e;
                                        let ptr9 = vec9.as_ptr().cast::<u8>();
                                        let len9 = vec9.len();
                                        *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len9;
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr9.cast_mut();
                                    }
                                }
                            }
                        }
                        let (result13_0, result13_1, result13_2) = match schema_url1 {
                            Some(e) => {
                                let vec12 = e;
                                let ptr12 = vec12.as_ptr().cast::<u8>();
                                let len12 = vec12.len();
                                (1i32, ptr12.cast_mut(), len12)
                            }
                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                        };
                        let vec412 = scope_metrics0;
                        let len412 = vec412.len();
                        let layout412 = _rt::alloc::Layout::from_size_align(
                                vec412.len() * (12 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            )
                            .unwrap();
                        let (result412, _cleanup412) = wit_bindgen::rt::Cleanup::new(
                            layout412,
                        );
                        for (i, e) in vec412.into_iter().enumerate() {
                            let base = result412
                                .add(i * (12 * ::core::mem::size_of::<*const u8>()));
                            {
                                let ScopeMetrics { scope: scope14, metrics: metrics14 } = e;
                                let super::super::super::wasi::otel::types::InstrumentationScope {
                                    name: name15,
                                    version: version15,
                                    schema_url: schema_url15,
                                    attributes: attributes15,
                                } = scope14;
                                let vec16 = name15;
                                let ptr16 = vec16.as_ptr().cast::<u8>();
                                let len16 = vec16.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len16;
                                *base.add(0).cast::<*mut u8>() = ptr16.cast_mut();
                                match version15 {
                                    Some(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (1i32) as u8;
                                        let vec17 = e;
                                        let ptr17 = vec17.as_ptr().cast::<u8>();
                                        let len17 = vec17.len();
                                        *base
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len17;
                                        *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr17.cast_mut();
                                    }
                                    None => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (0i32) as u8;
                                    }
                                };
                                match schema_url15 {
                                    Some(e) => {
                                        *base
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (1i32) as u8;
                                        let vec18 = e;
                                        let ptr18 = vec18.as_ptr().cast::<u8>();
                                        let len18 = vec18.len();
                                        *base
                                            .add(7 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len18;
                                        *base
                                            .add(6 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr18.cast_mut();
                                    }
                                    None => {
                                        *base
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (0i32) as u8;
                                    }
                                };
                                let vec28 = attributes15;
                                let len28 = vec28.len();
                                let layout28 = _rt::alloc::Layout::from_size_align(
                                        vec28.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    )
                                    .unwrap();
                                let (result28, _cleanup28) = wit_bindgen::rt::Cleanup::new(
                                    layout28,
                                );
                                cleanup_list.extend(_cleanup28);
                                for (i, e) in vec28.into_iter().enumerate() {
                                    let base = result28
                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let super::super::super::wasi::otel::types::KeyValue {
                                            key: key19,
                                            value: value19,
                                        } = e;
                                        let vec20 = key19;
                                        let ptr20 = vec20.as_ptr().cast::<u8>();
                                        let len20 = vec20.len();
                                        *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len20;
                                        *base.add(0).cast::<*mut u8>() = ptr20.cast_mut();
                                        use super::super::super::wasi::otel::types::Value as V27;
                                        match value19 {
                                            V27::String(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (0i32) as u8;
                                                let vec21 = e;
                                                let ptr21 = vec21.as_ptr().cast::<u8>();
                                                let len21 = vec21.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len21;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr21.cast_mut();
                                            }
                                            V27::Bool(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (1i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V27::F64(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (2i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>() = _rt::as_f64(e);
                                            }
                                            V27::S64(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (3i32) as u8;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>() = _rt::as_i64(e);
                                            }
                                            V27::StringArray(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (4i32) as u8;
                                                let vec23 = e;
                                                let len23 = vec23.len();
                                                let layout23 = _rt::alloc::Layout::from_size_align(
                                                        vec23.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    )
                                                    .unwrap();
                                                let (result23, _cleanup23) = wit_bindgen::rt::Cleanup::new(
                                                    layout23,
                                                );
                                                cleanup_list.extend(_cleanup23);
                                                for (i, e) in vec23.into_iter().enumerate() {
                                                    let base = result23
                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                    {
                                                        let vec22 = e;
                                                        let ptr22 = vec22.as_ptr().cast::<u8>();
                                                        let len22 = vec22.len();
                                                        *base
                                                            .add(::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len22;
                                                        *base.add(0).cast::<*mut u8>() = ptr22.cast_mut();
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len23;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result23;
                                            }
                                            V27::BoolArray(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (5i32) as u8;
                                                let vec24 = e;
                                                let len24 = vec24.len();
                                                let layout24 = _rt::alloc::Layout::from_size_align(
                                                        vec24.len() * 1,
                                                        1,
                                                    )
                                                    .unwrap();
                                                let (result24, _cleanup24) = wit_bindgen::rt::Cleanup::new(
                                                    layout24,
                                                );
                                                cleanup_list.extend(_cleanup24);
                                                for (i, e) in vec24.into_iter().enumerate() {
                                                    let base = result24.add(i * 1);
                                                    {
                                                        *base.add(0).cast::<u8>() = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                }
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len24;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = result24;
                                            }
                                            V27::F64Array(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (6i32) as u8;
                                                let vec25 = e;
                                                let ptr25 = vec25.as_ptr().cast::<u8>();
                                                let len25 = vec25.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len25;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr25.cast_mut();
                                            }
                                            V27::S64Array(e) => {
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (7i32) as u8;
                                                let vec26 = e;
                                                let ptr26 = vec26.as_ptr().cast::<u8>();
                                                let len26 = vec26.len();
                                                *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>() = len26;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>() = ptr26.cast_mut();
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len28;
                                *base
                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result28;
                                let vec411 = metrics14;
                                let len411 = vec411.len();
                                let layout411 = _rt::alloc::Layout::from_size_align(
                                        vec411.len()
                                            * (56 + 8 * ::core::mem::size_of::<*const u8>()),
                                        8,
                                    )
                                    .unwrap();
                                let (result411, _cleanup411) = wit_bindgen::rt::Cleanup::new(
                                    layout411,
                                );
                                cleanup_list.extend(_cleanup411);
                                for (i, e) in vec411.into_iter().enumerate() {
                                    let base = result411
                                        .add(i * (56 + 8 * ::core::mem::size_of::<*const u8>()));
                                    {
                                        let Metric {
                                            name: name29,
                                            description: description29,
                                            unit: unit29,
                                            data: data29,
                                        } = e;
                                        let vec30 = name29;
                                        let ptr30 = vec30.as_ptr().cast::<u8>();
                                        let len30 = vec30.len();
                                        *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len30;
                                        *base.add(0).cast::<*mut u8>() = ptr30.cast_mut();
                                        let vec31 = description29;
                                        let ptr31 = vec31.as_ptr().cast::<u8>();
                                        let len31 = vec31.len();
                                        *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len31;
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr31.cast_mut();
                                        let vec32 = unit29;
                                        let ptr32 = vec32.as_ptr().cast::<u8>();
                                        let len32 = vec32.len();
                                        *base
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>() = len32;
                                        *base
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>() = ptr32.cast_mut();
                                        match data29 {
                                            AggregatedMetrics::F64(e) => {
                                                *base
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (0i32) as u8;
                                                match e {
                                                    MetricData::Gauge(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (0i32) as u8;
                                                        let Gauge {
                                                            data_points: data_points33,
                                                            start_time: start_time33,
                                                            time: time33,
                                                        } = e;
                                                        let vec60 = data_points33;
                                                        let len60 = vec60.len();
                                                        let layout60 = _rt::alloc::Layout::from_size_align(
                                                                vec60.len()
                                                                    * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result60, _cleanup60) = wit_bindgen::rt::Cleanup::new(
                                                            layout60,
                                                        );
                                                        cleanup_list.extend(_cleanup60);
                                                        for (i, e) in vec60.into_iter().enumerate() {
                                                            let base = result60
                                                                .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let GaugeDataPoint {
                                                                    attributes: attributes34,
                                                                    value: value34,
                                                                    exemplars: exemplars34,
                                                                } = e;
                                                                let vec44 = attributes34;
                                                                let len44 = vec44.len();
                                                                let layout44 = _rt::alloc::Layout::from_size_align(
                                                                        vec44.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result44, _cleanup44) = wit_bindgen::rt::Cleanup::new(
                                                                    layout44,
                                                                );
                                                                cleanup_list.extend(_cleanup44);
                                                                for (i, e) in vec44.into_iter().enumerate() {
                                                                    let base = result44
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key35,
                                                                            value: value35,
                                                                        } = e;
                                                                        let vec36 = key35;
                                                                        let ptr36 = vec36.as_ptr().cast::<u8>();
                                                                        let len36 = vec36.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len36;
                                                                        *base.add(0).cast::<*mut u8>() = ptr36.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V43;
                                                                        match value35 {
                                                                            V43::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec37 = e;
                                                                                let ptr37 = vec37.as_ptr().cast::<u8>();
                                                                                let len37 = vec37.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len37;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr37.cast_mut();
                                                                            }
                                                                            V43::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V43::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V43::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V43::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec39 = e;
                                                                                let len39 = vec39.len();
                                                                                let layout39 = _rt::alloc::Layout::from_size_align(
                                                                                        vec39.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result39, _cleanup39) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout39,
                                                                                );
                                                                                cleanup_list.extend(_cleanup39);
                                                                                for (i, e) in vec39.into_iter().enumerate() {
                                                                                    let base = result39
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec38 = e;
                                                                                        let ptr38 = vec38.as_ptr().cast::<u8>();
                                                                                        let len38 = vec38.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len38;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr38.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len39;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result39;
                                                                            }
                                                                            V43::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec40 = e;
                                                                                let len40 = vec40.len();
                                                                                let layout40 = _rt::alloc::Layout::from_size_align(
                                                                                        vec40.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result40, _cleanup40) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout40,
                                                                                );
                                                                                cleanup_list.extend(_cleanup40);
                                                                                for (i, e) in vec40.into_iter().enumerate() {
                                                                                    let base = result40.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len40;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result40;
                                                                            }
                                                                            V43::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec41 = e;
                                                                                let ptr41 = vec41.as_ptr().cast::<u8>();
                                                                                let len41 = vec41.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len41;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr41.cast_mut();
                                                                            }
                                                                            V43::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec42 = e;
                                                                                let ptr42 = vec42.as_ptr().cast::<u8>();
                                                                                let len42 = vec42.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len42;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr42.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len44;
                                                                *base.add(0).cast::<*mut u8>() = result44;
                                                                match value34 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec59 = exemplars34;
                                                                let len59 = vec59.len();
                                                                let layout59 = _rt::alloc::Layout::from_size_align(
                                                                        vec59.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result59, _cleanup59) = wit_bindgen::rt::Cleanup::new(
                                                                    layout59,
                                                                );
                                                                cleanup_list.extend(_cleanup59);
                                                                for (i, e) in vec59.into_iter().enumerate() {
                                                                    let base = result59
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes45,
                                                                            time: time45,
                                                                            value: value45,
                                                                            span_id: span_id45,
                                                                            trace_id: trace_id45,
                                                                        } = e;
                                                                        let vec55 = filtered_attributes45;
                                                                        let len55 = vec55.len();
                                                                        let layout55 = _rt::alloc::Layout::from_size_align(
                                                                                vec55.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result55, _cleanup55) = wit_bindgen::rt::Cleanup::new(
                                                                            layout55,
                                                                        );
                                                                        cleanup_list.extend(_cleanup55);
                                                                        for (i, e) in vec55.into_iter().enumerate() {
                                                                            let base = result55
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key46,
                                                                                    value: value46,
                                                                                } = e;
                                                                                let vec47 = key46;
                                                                                let ptr47 = vec47.as_ptr().cast::<u8>();
                                                                                let len47 = vec47.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len47;
                                                                                *base.add(0).cast::<*mut u8>() = ptr47.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V54;
                                                                                match value46 {
                                                                                    V54::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec48 = e;
                                                                                        let ptr48 = vec48.as_ptr().cast::<u8>();
                                                                                        let len48 = vec48.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len48;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr48.cast_mut();
                                                                                    }
                                                                                    V54::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V54::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V54::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V54::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec50 = e;
                                                                                        let len50 = vec50.len();
                                                                                        let layout50 = _rt::alloc::Layout::from_size_align(
                                                                                                vec50.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result50, _cleanup50) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout50,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup50);
                                                                                        for (i, e) in vec50.into_iter().enumerate() {
                                                                                            let base = result50
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec49 = e;
                                                                                                let ptr49 = vec49.as_ptr().cast::<u8>();
                                                                                                let len49 = vec49.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len49;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr49.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len50;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result50;
                                                                                    }
                                                                                    V54::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec51 = e;
                                                                                        let len51 = vec51.len();
                                                                                        let layout51 = _rt::alloc::Layout::from_size_align(
                                                                                                vec51.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result51, _cleanup51) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout51,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup51);
                                                                                        for (i, e) in vec51.into_iter().enumerate() {
                                                                                            let base = result51.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len51;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result51;
                                                                                    }
                                                                                    V54::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec52 = e;
                                                                                        let ptr52 = vec52.as_ptr().cast::<u8>();
                                                                                        let len52 = vec52.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len52;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr52.cast_mut();
                                                                                    }
                                                                                    V54::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec53 = e;
                                                                                        let ptr53 = vec53.as_ptr().cast::<u8>();
                                                                                        let len53 = vec53.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len53;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr53.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len55;
                                                                        *base.add(0).cast::<*mut u8>() = result55;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds56,
                                                                            nanoseconds: nanoseconds56,
                                                                        } = time45;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds56);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds56);
                                                                        match value45 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec57 = span_id45;
                                                                        let ptr57 = vec57.as_ptr().cast::<u8>();
                                                                        let len57 = vec57.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len57;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr57.cast_mut();
                                                                        let vec58 = trace_id45;
                                                                        let ptr58 = vec58.as_ptr().cast::<u8>();
                                                                        let len58 = vec58.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len58;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr58.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len59;
                                                                *base
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result59;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len60;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result60;
                                                        match start_time33 {
                                                            Some(e) => {
                                                                *base
                                                                    .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (1i32) as u8;
                                                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: seconds61,
                                                                    nanoseconds: nanoseconds61,
                                                                } = e;
                                                                *base
                                                                    .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(seconds61);
                                                                *base
                                                                    .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(nanoseconds61);
                                                            }
                                                            None => {
                                                                *base
                                                                    .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds62,
                                                            nanoseconds: nanoseconds62,
                                                        } = time33;
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds62);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds62);
                                                    }
                                                    MetricData::Sum(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (1i32) as u8;
                                                        let Sum {
                                                            data_points: data_points63,
                                                            start_time: start_time63,
                                                            time: time63,
                                                            temporality: temporality63,
                                                            is_monotonic: is_monotonic63,
                                                        } = e;
                                                        let vec90 = data_points63;
                                                        let len90 = vec90.len();
                                                        let layout90 = _rt::alloc::Layout::from_size_align(
                                                                vec90.len()
                                                                    * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result90, _cleanup90) = wit_bindgen::rt::Cleanup::new(
                                                            layout90,
                                                        );
                                                        cleanup_list.extend(_cleanup90);
                                                        for (i, e) in vec90.into_iter().enumerate() {
                                                            let base = result90
                                                                .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let SumDataPoint {
                                                                    attributes: attributes64,
                                                                    value: value64,
                                                                    exemplars: exemplars64,
                                                                } = e;
                                                                let vec74 = attributes64;
                                                                let len74 = vec74.len();
                                                                let layout74 = _rt::alloc::Layout::from_size_align(
                                                                        vec74.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result74, _cleanup74) = wit_bindgen::rt::Cleanup::new(
                                                                    layout74,
                                                                );
                                                                cleanup_list.extend(_cleanup74);
                                                                for (i, e) in vec74.into_iter().enumerate() {
                                                                    let base = result74
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key65,
                                                                            value: value65,
                                                                        } = e;
                                                                        let vec66 = key65;
                                                                        let ptr66 = vec66.as_ptr().cast::<u8>();
                                                                        let len66 = vec66.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len66;
                                                                        *base.add(0).cast::<*mut u8>() = ptr66.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V73;
                                                                        match value65 {
                                                                            V73::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec67 = e;
                                                                                let ptr67 = vec67.as_ptr().cast::<u8>();
                                                                                let len67 = vec67.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len67;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr67.cast_mut();
                                                                            }
                                                                            V73::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V73::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V73::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V73::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec69 = e;
                                                                                let len69 = vec69.len();
                                                                                let layout69 = _rt::alloc::Layout::from_size_align(
                                                                                        vec69.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result69, _cleanup69) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout69,
                                                                                );
                                                                                cleanup_list.extend(_cleanup69);
                                                                                for (i, e) in vec69.into_iter().enumerate() {
                                                                                    let base = result69
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec68 = e;
                                                                                        let ptr68 = vec68.as_ptr().cast::<u8>();
                                                                                        let len68 = vec68.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len68;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr68.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len69;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result69;
                                                                            }
                                                                            V73::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec70 = e;
                                                                                let len70 = vec70.len();
                                                                                let layout70 = _rt::alloc::Layout::from_size_align(
                                                                                        vec70.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result70, _cleanup70) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout70,
                                                                                );
                                                                                cleanup_list.extend(_cleanup70);
                                                                                for (i, e) in vec70.into_iter().enumerate() {
                                                                                    let base = result70.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len70;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result70;
                                                                            }
                                                                            V73::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec71 = e;
                                                                                let ptr71 = vec71.as_ptr().cast::<u8>();
                                                                                let len71 = vec71.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len71;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr71.cast_mut();
                                                                            }
                                                                            V73::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec72 = e;
                                                                                let ptr72 = vec72.as_ptr().cast::<u8>();
                                                                                let len72 = vec72.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len72;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr72.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len74;
                                                                *base.add(0).cast::<*mut u8>() = result74;
                                                                match value64 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec89 = exemplars64;
                                                                let len89 = vec89.len();
                                                                let layout89 = _rt::alloc::Layout::from_size_align(
                                                                        vec89.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result89, _cleanup89) = wit_bindgen::rt::Cleanup::new(
                                                                    layout89,
                                                                );
                                                                cleanup_list.extend(_cleanup89);
                                                                for (i, e) in vec89.into_iter().enumerate() {
                                                                    let base = result89
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes75,
                                                                            time: time75,
                                                                            value: value75,
                                                                            span_id: span_id75,
                                                                            trace_id: trace_id75,
                                                                        } = e;
                                                                        let vec85 = filtered_attributes75;
                                                                        let len85 = vec85.len();
                                                                        let layout85 = _rt::alloc::Layout::from_size_align(
                                                                                vec85.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result85, _cleanup85) = wit_bindgen::rt::Cleanup::new(
                                                                            layout85,
                                                                        );
                                                                        cleanup_list.extend(_cleanup85);
                                                                        for (i, e) in vec85.into_iter().enumerate() {
                                                                            let base = result85
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key76,
                                                                                    value: value76,
                                                                                } = e;
                                                                                let vec77 = key76;
                                                                                let ptr77 = vec77.as_ptr().cast::<u8>();
                                                                                let len77 = vec77.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len77;
                                                                                *base.add(0).cast::<*mut u8>() = ptr77.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V84;
                                                                                match value76 {
                                                                                    V84::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec78 = e;
                                                                                        let ptr78 = vec78.as_ptr().cast::<u8>();
                                                                                        let len78 = vec78.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len78;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr78.cast_mut();
                                                                                    }
                                                                                    V84::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V84::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V84::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V84::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec80 = e;
                                                                                        let len80 = vec80.len();
                                                                                        let layout80 = _rt::alloc::Layout::from_size_align(
                                                                                                vec80.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result80, _cleanup80) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout80,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup80);
                                                                                        for (i, e) in vec80.into_iter().enumerate() {
                                                                                            let base = result80
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec79 = e;
                                                                                                let ptr79 = vec79.as_ptr().cast::<u8>();
                                                                                                let len79 = vec79.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len79;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr79.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len80;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result80;
                                                                                    }
                                                                                    V84::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec81 = e;
                                                                                        let len81 = vec81.len();
                                                                                        let layout81 = _rt::alloc::Layout::from_size_align(
                                                                                                vec81.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result81, _cleanup81) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout81,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup81);
                                                                                        for (i, e) in vec81.into_iter().enumerate() {
                                                                                            let base = result81.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len81;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result81;
                                                                                    }
                                                                                    V84::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec82 = e;
                                                                                        let ptr82 = vec82.as_ptr().cast::<u8>();
                                                                                        let len82 = vec82.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len82;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr82.cast_mut();
                                                                                    }
                                                                                    V84::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec83 = e;
                                                                                        let ptr83 = vec83.as_ptr().cast::<u8>();
                                                                                        let len83 = vec83.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len83;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr83.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len85;
                                                                        *base.add(0).cast::<*mut u8>() = result85;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds86,
                                                                            nanoseconds: nanoseconds86,
                                                                        } = time75;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds86);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds86);
                                                                        match value75 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec87 = span_id75;
                                                                        let ptr87 = vec87.as_ptr().cast::<u8>();
                                                                        let len87 = vec87.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len87;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr87.cast_mut();
                                                                        let vec88 = trace_id75;
                                                                        let ptr88 = vec88.as_ptr().cast::<u8>();
                                                                        let len88 = vec88.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len88;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr88.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len89;
                                                                *base
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result89;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len90;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result90;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds91,
                                                            nanoseconds: nanoseconds91,
                                                        } = start_time63;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds91);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds91);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds92,
                                                            nanoseconds: nanoseconds92,
                                                        } = time63;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds92);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds92);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality63.clone() as i32) as u8;
                                                        *base
                                                            .add(49 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (match is_monotonic63 {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    MetricData::Histogram(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (2i32) as u8;
                                                        let Histogram {
                                                            data_points: data_points93,
                                                            start_time: start_time93,
                                                            time: time93,
                                                            temporality: temporality93,
                                                        } = e;
                                                        let vec122 = data_points93;
                                                        let len122 = vec122.len();
                                                        let layout122 = _rt::alloc::Layout::from_size_align(
                                                                vec122.len()
                                                                    * (72 + 8 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result122, _cleanup122) = wit_bindgen::rt::Cleanup::new(
                                                            layout122,
                                                        );
                                                        cleanup_list.extend(_cleanup122);
                                                        for (i, e) in vec122.into_iter().enumerate() {
                                                            let base = result122
                                                                .add(i * (72 + 8 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let HistogramDataPoint {
                                                                    attributes: attributes94,
                                                                    count: count94,
                                                                    bounds: bounds94,
                                                                    bucket_counts: bucket_counts94,
                                                                    min: min94,
                                                                    max: max94,
                                                                    sum: sum94,
                                                                    exemplars: exemplars94,
                                                                } = e;
                                                                let vec104 = attributes94;
                                                                let len104 = vec104.len();
                                                                let layout104 = _rt::alloc::Layout::from_size_align(
                                                                        vec104.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result104, _cleanup104) = wit_bindgen::rt::Cleanup::new(
                                                                    layout104,
                                                                );
                                                                cleanup_list.extend(_cleanup104);
                                                                for (i, e) in vec104.into_iter().enumerate() {
                                                                    let base = result104
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key95,
                                                                            value: value95,
                                                                        } = e;
                                                                        let vec96 = key95;
                                                                        let ptr96 = vec96.as_ptr().cast::<u8>();
                                                                        let len96 = vec96.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len96;
                                                                        *base.add(0).cast::<*mut u8>() = ptr96.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V103;
                                                                        match value95 {
                                                                            V103::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec97 = e;
                                                                                let ptr97 = vec97.as_ptr().cast::<u8>();
                                                                                let len97 = vec97.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len97;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr97.cast_mut();
                                                                            }
                                                                            V103::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V103::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V103::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V103::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec99 = e;
                                                                                let len99 = vec99.len();
                                                                                let layout99 = _rt::alloc::Layout::from_size_align(
                                                                                        vec99.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result99, _cleanup99) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout99,
                                                                                );
                                                                                cleanup_list.extend(_cleanup99);
                                                                                for (i, e) in vec99.into_iter().enumerate() {
                                                                                    let base = result99
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec98 = e;
                                                                                        let ptr98 = vec98.as_ptr().cast::<u8>();
                                                                                        let len98 = vec98.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len98;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr98.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len99;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result99;
                                                                            }
                                                                            V103::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec100 = e;
                                                                                let len100 = vec100.len();
                                                                                let layout100 = _rt::alloc::Layout::from_size_align(
                                                                                        vec100.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result100, _cleanup100) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout100,
                                                                                );
                                                                                cleanup_list.extend(_cleanup100);
                                                                                for (i, e) in vec100.into_iter().enumerate() {
                                                                                    let base = result100.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len100;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result100;
                                                                            }
                                                                            V103::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec101 = e;
                                                                                let ptr101 = vec101.as_ptr().cast::<u8>();
                                                                                let len101 = vec101.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len101;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr101.cast_mut();
                                                                            }
                                                                            V103::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec102 = e;
                                                                                let ptr102 = vec102.as_ptr().cast::<u8>();
                                                                                let len102 = vec102.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len102;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr102.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len104;
                                                                *base.add(0).cast::<*mut u8>() = result104;
                                                                *base
                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(count94);
                                                                let vec105 = bounds94;
                                                                let ptr105 = vec105.as_ptr().cast::<u8>();
                                                                let len105 = vec105.len();
                                                                *base
                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len105;
                                                                *base
                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr105.cast_mut();
                                                                let vec106 = bucket_counts94;
                                                                let ptr106 = vec106.as_ptr().cast::<u8>();
                                                                let len106 = vec106.len();
                                                                *base
                                                                    .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len106;
                                                                *base
                                                                    .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr106.cast_mut();
                                                                match min94 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match max94 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match sum94 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec121 = exemplars94;
                                                                let len121 = vec121.len();
                                                                let layout121 = _rt::alloc::Layout::from_size_align(
                                                                        vec121.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result121, _cleanup121) = wit_bindgen::rt::Cleanup::new(
                                                                    layout121,
                                                                );
                                                                cleanup_list.extend(_cleanup121);
                                                                for (i, e) in vec121.into_iter().enumerate() {
                                                                    let base = result121
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes107,
                                                                            time: time107,
                                                                            value: value107,
                                                                            span_id: span_id107,
                                                                            trace_id: trace_id107,
                                                                        } = e;
                                                                        let vec117 = filtered_attributes107;
                                                                        let len117 = vec117.len();
                                                                        let layout117 = _rt::alloc::Layout::from_size_align(
                                                                                vec117.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result117, _cleanup117) = wit_bindgen::rt::Cleanup::new(
                                                                            layout117,
                                                                        );
                                                                        cleanup_list.extend(_cleanup117);
                                                                        for (i, e) in vec117.into_iter().enumerate() {
                                                                            let base = result117
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key108,
                                                                                    value: value108,
                                                                                } = e;
                                                                                let vec109 = key108;
                                                                                let ptr109 = vec109.as_ptr().cast::<u8>();
                                                                                let len109 = vec109.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len109;
                                                                                *base.add(0).cast::<*mut u8>() = ptr109.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V116;
                                                                                match value108 {
                                                                                    V116::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec110 = e;
                                                                                        let ptr110 = vec110.as_ptr().cast::<u8>();
                                                                                        let len110 = vec110.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len110;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr110.cast_mut();
                                                                                    }
                                                                                    V116::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V116::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V116::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V116::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec112 = e;
                                                                                        let len112 = vec112.len();
                                                                                        let layout112 = _rt::alloc::Layout::from_size_align(
                                                                                                vec112.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result112, _cleanup112) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout112,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup112);
                                                                                        for (i, e) in vec112.into_iter().enumerate() {
                                                                                            let base = result112
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec111 = e;
                                                                                                let ptr111 = vec111.as_ptr().cast::<u8>();
                                                                                                let len111 = vec111.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len111;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr111.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len112;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result112;
                                                                                    }
                                                                                    V116::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec113 = e;
                                                                                        let len113 = vec113.len();
                                                                                        let layout113 = _rt::alloc::Layout::from_size_align(
                                                                                                vec113.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result113, _cleanup113) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout113,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup113);
                                                                                        for (i, e) in vec113.into_iter().enumerate() {
                                                                                            let base = result113.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len113;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result113;
                                                                                    }
                                                                                    V116::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec114 = e;
                                                                                        let ptr114 = vec114.as_ptr().cast::<u8>();
                                                                                        let len114 = vec114.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len114;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr114.cast_mut();
                                                                                    }
                                                                                    V116::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec115 = e;
                                                                                        let ptr115 = vec115.as_ptr().cast::<u8>();
                                                                                        let len115 = vec115.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len115;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr115.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len117;
                                                                        *base.add(0).cast::<*mut u8>() = result117;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds118,
                                                                            nanoseconds: nanoseconds118,
                                                                        } = time107;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds118);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds118);
                                                                        match value107 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec119 = span_id107;
                                                                        let ptr119 = vec119.as_ptr().cast::<u8>();
                                                                        let len119 = vec119.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len119;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr119.cast_mut();
                                                                        let vec120 = trace_id107;
                                                                        let ptr120 = vec120.as_ptr().cast::<u8>();
                                                                        let len120 = vec120.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len120;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr120.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(72 + 7 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len121;
                                                                *base
                                                                    .add(72 + 6 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result121;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len122;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result122;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds123,
                                                            nanoseconds: nanoseconds123,
                                                        } = start_time93;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds123);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds123);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds124,
                                                            nanoseconds: nanoseconds124,
                                                        } = time93;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds124);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds124);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality93.clone() as i32) as u8;
                                                    }
                                                    MetricData::ExponentialHistogram(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (3i32) as u8;
                                                        let ExponentialHistogram {
                                                            data_points: data_points125,
                                                            start_time: start_time125,
                                                            time: time125,
                                                            temporality: temporality125,
                                                        } = e;
                                                        let vec156 = data_points125;
                                                        let len156 = vec156.len();
                                                        let layout156 = _rt::alloc::Layout::from_size_align(
                                                                vec156.len()
                                                                    * (96 + 10 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result156, _cleanup156) = wit_bindgen::rt::Cleanup::new(
                                                            layout156,
                                                        );
                                                        cleanup_list.extend(_cleanup156);
                                                        for (i, e) in vec156.into_iter().enumerate() {
                                                            let base = result156
                                                                .add(i * (96 + 10 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let ExponentialHistogramDataPoint {
                                                                    attributes: attributes126,
                                                                    count: count126,
                                                                    min: min126,
                                                                    max: max126,
                                                                    sum: sum126,
                                                                    scale: scale126,
                                                                    zero_count: zero_count126,
                                                                    positive_bucket: positive_bucket126,
                                                                    negative_bucket: negative_bucket126,
                                                                    zero_threshold: zero_threshold126,
                                                                    exemplars: exemplars126,
                                                                } = e;
                                                                let vec136 = attributes126;
                                                                let len136 = vec136.len();
                                                                let layout136 = _rt::alloc::Layout::from_size_align(
                                                                        vec136.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result136, _cleanup136) = wit_bindgen::rt::Cleanup::new(
                                                                    layout136,
                                                                );
                                                                cleanup_list.extend(_cleanup136);
                                                                for (i, e) in vec136.into_iter().enumerate() {
                                                                    let base = result136
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key127,
                                                                            value: value127,
                                                                        } = e;
                                                                        let vec128 = key127;
                                                                        let ptr128 = vec128.as_ptr().cast::<u8>();
                                                                        let len128 = vec128.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len128;
                                                                        *base.add(0).cast::<*mut u8>() = ptr128.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V135;
                                                                        match value127 {
                                                                            V135::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec129 = e;
                                                                                let ptr129 = vec129.as_ptr().cast::<u8>();
                                                                                let len129 = vec129.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len129;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr129.cast_mut();
                                                                            }
                                                                            V135::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V135::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V135::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V135::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec131 = e;
                                                                                let len131 = vec131.len();
                                                                                let layout131 = _rt::alloc::Layout::from_size_align(
                                                                                        vec131.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result131, _cleanup131) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout131,
                                                                                );
                                                                                cleanup_list.extend(_cleanup131);
                                                                                for (i, e) in vec131.into_iter().enumerate() {
                                                                                    let base = result131
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec130 = e;
                                                                                        let ptr130 = vec130.as_ptr().cast::<u8>();
                                                                                        let len130 = vec130.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len130;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr130.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len131;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result131;
                                                                            }
                                                                            V135::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec132 = e;
                                                                                let len132 = vec132.len();
                                                                                let layout132 = _rt::alloc::Layout::from_size_align(
                                                                                        vec132.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result132, _cleanup132) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout132,
                                                                                );
                                                                                cleanup_list.extend(_cleanup132);
                                                                                for (i, e) in vec132.into_iter().enumerate() {
                                                                                    let base = result132.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len132;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result132;
                                                                            }
                                                                            V135::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec133 = e;
                                                                                let ptr133 = vec133.as_ptr().cast::<u8>();
                                                                                let len133 = vec133.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len133;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr133.cast_mut();
                                                                            }
                                                                            V135::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec134 = e;
                                                                                let ptr134 = vec134.as_ptr().cast::<u8>();
                                                                                let len134 = vec134.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len134;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr134.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len136;
                                                                *base.add(0).cast::<*mut u8>() = result136;
                                                                *base
                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(count126);
                                                                match min126 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match max126 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match sum126 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                *base
                                                                    .add(72 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (_rt::as_i32(scale126)) as u8;
                                                                *base
                                                                    .add(80 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(zero_count126);
                                                                let ExponentialBucket {
                                                                    offset: offset137,
                                                                    counts: counts137,
                                                                } = positive_bucket126;
                                                                *base
                                                                    .add(88 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(offset137);
                                                                let vec138 = counts137;
                                                                let ptr138 = vec138.as_ptr().cast::<u8>();
                                                                let len138 = vec138.len();
                                                                *base
                                                                    .add(88 + 4 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len138;
                                                                *base
                                                                    .add(88 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr138.cast_mut();
                                                                let ExponentialBucket {
                                                                    offset: offset139,
                                                                    counts: counts139,
                                                                } = negative_bucket126;
                                                                *base
                                                                    .add(88 + 5 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(offset139);
                                                                let vec140 = counts139;
                                                                let ptr140 = vec140.as_ptr().cast::<u8>();
                                                                let len140 = vec140.len();
                                                                *base
                                                                    .add(88 + 7 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len140;
                                                                *base
                                                                    .add(88 + 6 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr140.cast_mut();
                                                                *base
                                                                    .add(88 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<f64>() = _rt::as_f64(zero_threshold126);
                                                                let vec155 = exemplars126;
                                                                let len155 = vec155.len();
                                                                let layout155 = _rt::alloc::Layout::from_size_align(
                                                                        vec155.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result155, _cleanup155) = wit_bindgen::rt::Cleanup::new(
                                                                    layout155,
                                                                );
                                                                cleanup_list.extend(_cleanup155);
                                                                for (i, e) in vec155.into_iter().enumerate() {
                                                                    let base = result155
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes141,
                                                                            time: time141,
                                                                            value: value141,
                                                                            span_id: span_id141,
                                                                            trace_id: trace_id141,
                                                                        } = e;
                                                                        let vec151 = filtered_attributes141;
                                                                        let len151 = vec151.len();
                                                                        let layout151 = _rt::alloc::Layout::from_size_align(
                                                                                vec151.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result151, _cleanup151) = wit_bindgen::rt::Cleanup::new(
                                                                            layout151,
                                                                        );
                                                                        cleanup_list.extend(_cleanup151);
                                                                        for (i, e) in vec151.into_iter().enumerate() {
                                                                            let base = result151
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key142,
                                                                                    value: value142,
                                                                                } = e;
                                                                                let vec143 = key142;
                                                                                let ptr143 = vec143.as_ptr().cast::<u8>();
                                                                                let len143 = vec143.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len143;
                                                                                *base.add(0).cast::<*mut u8>() = ptr143.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V150;
                                                                                match value142 {
                                                                                    V150::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec144 = e;
                                                                                        let ptr144 = vec144.as_ptr().cast::<u8>();
                                                                                        let len144 = vec144.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len144;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr144.cast_mut();
                                                                                    }
                                                                                    V150::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V150::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V150::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V150::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec146 = e;
                                                                                        let len146 = vec146.len();
                                                                                        let layout146 = _rt::alloc::Layout::from_size_align(
                                                                                                vec146.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result146, _cleanup146) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout146,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup146);
                                                                                        for (i, e) in vec146.into_iter().enumerate() {
                                                                                            let base = result146
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec145 = e;
                                                                                                let ptr145 = vec145.as_ptr().cast::<u8>();
                                                                                                let len145 = vec145.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len145;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr145.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len146;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result146;
                                                                                    }
                                                                                    V150::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec147 = e;
                                                                                        let len147 = vec147.len();
                                                                                        let layout147 = _rt::alloc::Layout::from_size_align(
                                                                                                vec147.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result147, _cleanup147) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout147,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup147);
                                                                                        for (i, e) in vec147.into_iter().enumerate() {
                                                                                            let base = result147.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len147;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result147;
                                                                                    }
                                                                                    V150::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec148 = e;
                                                                                        let ptr148 = vec148.as_ptr().cast::<u8>();
                                                                                        let len148 = vec148.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len148;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr148.cast_mut();
                                                                                    }
                                                                                    V150::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec149 = e;
                                                                                        let ptr149 = vec149.as_ptr().cast::<u8>();
                                                                                        let len149 = vec149.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len149;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr149.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len151;
                                                                        *base.add(0).cast::<*mut u8>() = result151;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds152,
                                                                            nanoseconds: nanoseconds152,
                                                                        } = time141;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds152);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds152);
                                                                        match value141 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec153 = span_id141;
                                                                        let ptr153 = vec153.as_ptr().cast::<u8>();
                                                                        let len153 = vec153.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len153;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr153.cast_mut();
                                                                        let vec154 = trace_id141;
                                                                        let ptr154 = vec154.as_ptr().cast::<u8>();
                                                                        let len154 = vec154.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len154;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr154.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(96 + 9 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len155;
                                                                *base
                                                                    .add(96 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result155;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len156;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result156;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds157,
                                                            nanoseconds: nanoseconds157,
                                                        } = start_time125;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds157);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds157);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds158,
                                                            nanoseconds: nanoseconds158,
                                                        } = time125;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds158);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds158);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality125.clone() as i32) as u8;
                                                    }
                                                }
                                            }
                                            AggregatedMetrics::U64(e) => {
                                                *base
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (1i32) as u8;
                                                match e {
                                                    MetricData::Gauge(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (0i32) as u8;
                                                        let Gauge {
                                                            data_points: data_points159,
                                                            start_time: start_time159,
                                                            time: time159,
                                                        } = e;
                                                        let vec186 = data_points159;
                                                        let len186 = vec186.len();
                                                        let layout186 = _rt::alloc::Layout::from_size_align(
                                                                vec186.len()
                                                                    * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result186, _cleanup186) = wit_bindgen::rt::Cleanup::new(
                                                            layout186,
                                                        );
                                                        cleanup_list.extend(_cleanup186);
                                                        for (i, e) in vec186.into_iter().enumerate() {
                                                            let base = result186
                                                                .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let GaugeDataPoint {
                                                                    attributes: attributes160,
                                                                    value: value160,
                                                                    exemplars: exemplars160,
                                                                } = e;
                                                                let vec170 = attributes160;
                                                                let len170 = vec170.len();
                                                                let layout170 = _rt::alloc::Layout::from_size_align(
                                                                        vec170.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result170, _cleanup170) = wit_bindgen::rt::Cleanup::new(
                                                                    layout170,
                                                                );
                                                                cleanup_list.extend(_cleanup170);
                                                                for (i, e) in vec170.into_iter().enumerate() {
                                                                    let base = result170
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key161,
                                                                            value: value161,
                                                                        } = e;
                                                                        let vec162 = key161;
                                                                        let ptr162 = vec162.as_ptr().cast::<u8>();
                                                                        let len162 = vec162.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len162;
                                                                        *base.add(0).cast::<*mut u8>() = ptr162.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V169;
                                                                        match value161 {
                                                                            V169::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec163 = e;
                                                                                let ptr163 = vec163.as_ptr().cast::<u8>();
                                                                                let len163 = vec163.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len163;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr163.cast_mut();
                                                                            }
                                                                            V169::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V169::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V169::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V169::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec165 = e;
                                                                                let len165 = vec165.len();
                                                                                let layout165 = _rt::alloc::Layout::from_size_align(
                                                                                        vec165.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result165, _cleanup165) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout165,
                                                                                );
                                                                                cleanup_list.extend(_cleanup165);
                                                                                for (i, e) in vec165.into_iter().enumerate() {
                                                                                    let base = result165
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec164 = e;
                                                                                        let ptr164 = vec164.as_ptr().cast::<u8>();
                                                                                        let len164 = vec164.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len164;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr164.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len165;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result165;
                                                                            }
                                                                            V169::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec166 = e;
                                                                                let len166 = vec166.len();
                                                                                let layout166 = _rt::alloc::Layout::from_size_align(
                                                                                        vec166.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result166, _cleanup166) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout166,
                                                                                );
                                                                                cleanup_list.extend(_cleanup166);
                                                                                for (i, e) in vec166.into_iter().enumerate() {
                                                                                    let base = result166.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len166;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result166;
                                                                            }
                                                                            V169::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec167 = e;
                                                                                let ptr167 = vec167.as_ptr().cast::<u8>();
                                                                                let len167 = vec167.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len167;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr167.cast_mut();
                                                                            }
                                                                            V169::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec168 = e;
                                                                                let ptr168 = vec168.as_ptr().cast::<u8>();
                                                                                let len168 = vec168.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len168;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr168.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len170;
                                                                *base.add(0).cast::<*mut u8>() = result170;
                                                                match value160 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec185 = exemplars160;
                                                                let len185 = vec185.len();
                                                                let layout185 = _rt::alloc::Layout::from_size_align(
                                                                        vec185.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result185, _cleanup185) = wit_bindgen::rt::Cleanup::new(
                                                                    layout185,
                                                                );
                                                                cleanup_list.extend(_cleanup185);
                                                                for (i, e) in vec185.into_iter().enumerate() {
                                                                    let base = result185
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes171,
                                                                            time: time171,
                                                                            value: value171,
                                                                            span_id: span_id171,
                                                                            trace_id: trace_id171,
                                                                        } = e;
                                                                        let vec181 = filtered_attributes171;
                                                                        let len181 = vec181.len();
                                                                        let layout181 = _rt::alloc::Layout::from_size_align(
                                                                                vec181.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result181, _cleanup181) = wit_bindgen::rt::Cleanup::new(
                                                                            layout181,
                                                                        );
                                                                        cleanup_list.extend(_cleanup181);
                                                                        for (i, e) in vec181.into_iter().enumerate() {
                                                                            let base = result181
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key172,
                                                                                    value: value172,
                                                                                } = e;
                                                                                let vec173 = key172;
                                                                                let ptr173 = vec173.as_ptr().cast::<u8>();
                                                                                let len173 = vec173.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len173;
                                                                                *base.add(0).cast::<*mut u8>() = ptr173.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V180;
                                                                                match value172 {
                                                                                    V180::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec174 = e;
                                                                                        let ptr174 = vec174.as_ptr().cast::<u8>();
                                                                                        let len174 = vec174.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len174;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr174.cast_mut();
                                                                                    }
                                                                                    V180::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V180::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V180::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V180::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec176 = e;
                                                                                        let len176 = vec176.len();
                                                                                        let layout176 = _rt::alloc::Layout::from_size_align(
                                                                                                vec176.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result176, _cleanup176) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout176,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup176);
                                                                                        for (i, e) in vec176.into_iter().enumerate() {
                                                                                            let base = result176
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec175 = e;
                                                                                                let ptr175 = vec175.as_ptr().cast::<u8>();
                                                                                                let len175 = vec175.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len175;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr175.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len176;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result176;
                                                                                    }
                                                                                    V180::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec177 = e;
                                                                                        let len177 = vec177.len();
                                                                                        let layout177 = _rt::alloc::Layout::from_size_align(
                                                                                                vec177.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result177, _cleanup177) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout177,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup177);
                                                                                        for (i, e) in vec177.into_iter().enumerate() {
                                                                                            let base = result177.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len177;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result177;
                                                                                    }
                                                                                    V180::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec178 = e;
                                                                                        let ptr178 = vec178.as_ptr().cast::<u8>();
                                                                                        let len178 = vec178.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len178;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr178.cast_mut();
                                                                                    }
                                                                                    V180::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec179 = e;
                                                                                        let ptr179 = vec179.as_ptr().cast::<u8>();
                                                                                        let len179 = vec179.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len179;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr179.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len181;
                                                                        *base.add(0).cast::<*mut u8>() = result181;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds182,
                                                                            nanoseconds: nanoseconds182,
                                                                        } = time171;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds182);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds182);
                                                                        match value171 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec183 = span_id171;
                                                                        let ptr183 = vec183.as_ptr().cast::<u8>();
                                                                        let len183 = vec183.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len183;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr183.cast_mut();
                                                                        let vec184 = trace_id171;
                                                                        let ptr184 = vec184.as_ptr().cast::<u8>();
                                                                        let len184 = vec184.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len184;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr184.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len185;
                                                                *base
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result185;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len186;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result186;
                                                        match start_time159 {
                                                            Some(e) => {
                                                                *base
                                                                    .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (1i32) as u8;
                                                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: seconds187,
                                                                    nanoseconds: nanoseconds187,
                                                                } = e;
                                                                *base
                                                                    .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(seconds187);
                                                                *base
                                                                    .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(nanoseconds187);
                                                            }
                                                            None => {
                                                                *base
                                                                    .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds188,
                                                            nanoseconds: nanoseconds188,
                                                        } = time159;
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds188);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds188);
                                                    }
                                                    MetricData::Sum(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (1i32) as u8;
                                                        let Sum {
                                                            data_points: data_points189,
                                                            start_time: start_time189,
                                                            time: time189,
                                                            temporality: temporality189,
                                                            is_monotonic: is_monotonic189,
                                                        } = e;
                                                        let vec216 = data_points189;
                                                        let len216 = vec216.len();
                                                        let layout216 = _rt::alloc::Layout::from_size_align(
                                                                vec216.len()
                                                                    * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result216, _cleanup216) = wit_bindgen::rt::Cleanup::new(
                                                            layout216,
                                                        );
                                                        cleanup_list.extend(_cleanup216);
                                                        for (i, e) in vec216.into_iter().enumerate() {
                                                            let base = result216
                                                                .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let SumDataPoint {
                                                                    attributes: attributes190,
                                                                    value: value190,
                                                                    exemplars: exemplars190,
                                                                } = e;
                                                                let vec200 = attributes190;
                                                                let len200 = vec200.len();
                                                                let layout200 = _rt::alloc::Layout::from_size_align(
                                                                        vec200.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result200, _cleanup200) = wit_bindgen::rt::Cleanup::new(
                                                                    layout200,
                                                                );
                                                                cleanup_list.extend(_cleanup200);
                                                                for (i, e) in vec200.into_iter().enumerate() {
                                                                    let base = result200
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key191,
                                                                            value: value191,
                                                                        } = e;
                                                                        let vec192 = key191;
                                                                        let ptr192 = vec192.as_ptr().cast::<u8>();
                                                                        let len192 = vec192.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len192;
                                                                        *base.add(0).cast::<*mut u8>() = ptr192.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V199;
                                                                        match value191 {
                                                                            V199::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec193 = e;
                                                                                let ptr193 = vec193.as_ptr().cast::<u8>();
                                                                                let len193 = vec193.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len193;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr193.cast_mut();
                                                                            }
                                                                            V199::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V199::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V199::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V199::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec195 = e;
                                                                                let len195 = vec195.len();
                                                                                let layout195 = _rt::alloc::Layout::from_size_align(
                                                                                        vec195.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result195, _cleanup195) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout195,
                                                                                );
                                                                                cleanup_list.extend(_cleanup195);
                                                                                for (i, e) in vec195.into_iter().enumerate() {
                                                                                    let base = result195
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec194 = e;
                                                                                        let ptr194 = vec194.as_ptr().cast::<u8>();
                                                                                        let len194 = vec194.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len194;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr194.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len195;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result195;
                                                                            }
                                                                            V199::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec196 = e;
                                                                                let len196 = vec196.len();
                                                                                let layout196 = _rt::alloc::Layout::from_size_align(
                                                                                        vec196.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result196, _cleanup196) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout196,
                                                                                );
                                                                                cleanup_list.extend(_cleanup196);
                                                                                for (i, e) in vec196.into_iter().enumerate() {
                                                                                    let base = result196.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len196;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result196;
                                                                            }
                                                                            V199::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec197 = e;
                                                                                let ptr197 = vec197.as_ptr().cast::<u8>();
                                                                                let len197 = vec197.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len197;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr197.cast_mut();
                                                                            }
                                                                            V199::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec198 = e;
                                                                                let ptr198 = vec198.as_ptr().cast::<u8>();
                                                                                let len198 = vec198.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len198;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr198.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len200;
                                                                *base.add(0).cast::<*mut u8>() = result200;
                                                                match value190 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec215 = exemplars190;
                                                                let len215 = vec215.len();
                                                                let layout215 = _rt::alloc::Layout::from_size_align(
                                                                        vec215.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result215, _cleanup215) = wit_bindgen::rt::Cleanup::new(
                                                                    layout215,
                                                                );
                                                                cleanup_list.extend(_cleanup215);
                                                                for (i, e) in vec215.into_iter().enumerate() {
                                                                    let base = result215
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes201,
                                                                            time: time201,
                                                                            value: value201,
                                                                            span_id: span_id201,
                                                                            trace_id: trace_id201,
                                                                        } = e;
                                                                        let vec211 = filtered_attributes201;
                                                                        let len211 = vec211.len();
                                                                        let layout211 = _rt::alloc::Layout::from_size_align(
                                                                                vec211.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result211, _cleanup211) = wit_bindgen::rt::Cleanup::new(
                                                                            layout211,
                                                                        );
                                                                        cleanup_list.extend(_cleanup211);
                                                                        for (i, e) in vec211.into_iter().enumerate() {
                                                                            let base = result211
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key202,
                                                                                    value: value202,
                                                                                } = e;
                                                                                let vec203 = key202;
                                                                                let ptr203 = vec203.as_ptr().cast::<u8>();
                                                                                let len203 = vec203.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len203;
                                                                                *base.add(0).cast::<*mut u8>() = ptr203.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V210;
                                                                                match value202 {
                                                                                    V210::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec204 = e;
                                                                                        let ptr204 = vec204.as_ptr().cast::<u8>();
                                                                                        let len204 = vec204.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len204;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr204.cast_mut();
                                                                                    }
                                                                                    V210::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V210::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V210::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V210::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec206 = e;
                                                                                        let len206 = vec206.len();
                                                                                        let layout206 = _rt::alloc::Layout::from_size_align(
                                                                                                vec206.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result206, _cleanup206) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout206,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup206);
                                                                                        for (i, e) in vec206.into_iter().enumerate() {
                                                                                            let base = result206
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec205 = e;
                                                                                                let ptr205 = vec205.as_ptr().cast::<u8>();
                                                                                                let len205 = vec205.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len205;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr205.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len206;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result206;
                                                                                    }
                                                                                    V210::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec207 = e;
                                                                                        let len207 = vec207.len();
                                                                                        let layout207 = _rt::alloc::Layout::from_size_align(
                                                                                                vec207.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result207, _cleanup207) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout207,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup207);
                                                                                        for (i, e) in vec207.into_iter().enumerate() {
                                                                                            let base = result207.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len207;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result207;
                                                                                    }
                                                                                    V210::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec208 = e;
                                                                                        let ptr208 = vec208.as_ptr().cast::<u8>();
                                                                                        let len208 = vec208.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len208;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr208.cast_mut();
                                                                                    }
                                                                                    V210::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec209 = e;
                                                                                        let ptr209 = vec209.as_ptr().cast::<u8>();
                                                                                        let len209 = vec209.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len209;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr209.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len211;
                                                                        *base.add(0).cast::<*mut u8>() = result211;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds212,
                                                                            nanoseconds: nanoseconds212,
                                                                        } = time201;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds212);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds212);
                                                                        match value201 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec213 = span_id201;
                                                                        let ptr213 = vec213.as_ptr().cast::<u8>();
                                                                        let len213 = vec213.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len213;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr213.cast_mut();
                                                                        let vec214 = trace_id201;
                                                                        let ptr214 = vec214.as_ptr().cast::<u8>();
                                                                        let len214 = vec214.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len214;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr214.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len215;
                                                                *base
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result215;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len216;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result216;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds217,
                                                            nanoseconds: nanoseconds217,
                                                        } = start_time189;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds217);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds217);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds218,
                                                            nanoseconds: nanoseconds218,
                                                        } = time189;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds218);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds218);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality189.clone() as i32) as u8;
                                                        *base
                                                            .add(49 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (match is_monotonic189 {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    MetricData::Histogram(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (2i32) as u8;
                                                        let Histogram {
                                                            data_points: data_points219,
                                                            start_time: start_time219,
                                                            time: time219,
                                                            temporality: temporality219,
                                                        } = e;
                                                        let vec248 = data_points219;
                                                        let len248 = vec248.len();
                                                        let layout248 = _rt::alloc::Layout::from_size_align(
                                                                vec248.len()
                                                                    * (72 + 8 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result248, _cleanup248) = wit_bindgen::rt::Cleanup::new(
                                                            layout248,
                                                        );
                                                        cleanup_list.extend(_cleanup248);
                                                        for (i, e) in vec248.into_iter().enumerate() {
                                                            let base = result248
                                                                .add(i * (72 + 8 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let HistogramDataPoint {
                                                                    attributes: attributes220,
                                                                    count: count220,
                                                                    bounds: bounds220,
                                                                    bucket_counts: bucket_counts220,
                                                                    min: min220,
                                                                    max: max220,
                                                                    sum: sum220,
                                                                    exemplars: exemplars220,
                                                                } = e;
                                                                let vec230 = attributes220;
                                                                let len230 = vec230.len();
                                                                let layout230 = _rt::alloc::Layout::from_size_align(
                                                                        vec230.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result230, _cleanup230) = wit_bindgen::rt::Cleanup::new(
                                                                    layout230,
                                                                );
                                                                cleanup_list.extend(_cleanup230);
                                                                for (i, e) in vec230.into_iter().enumerate() {
                                                                    let base = result230
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key221,
                                                                            value: value221,
                                                                        } = e;
                                                                        let vec222 = key221;
                                                                        let ptr222 = vec222.as_ptr().cast::<u8>();
                                                                        let len222 = vec222.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len222;
                                                                        *base.add(0).cast::<*mut u8>() = ptr222.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V229;
                                                                        match value221 {
                                                                            V229::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec223 = e;
                                                                                let ptr223 = vec223.as_ptr().cast::<u8>();
                                                                                let len223 = vec223.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len223;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr223.cast_mut();
                                                                            }
                                                                            V229::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V229::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V229::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V229::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec225 = e;
                                                                                let len225 = vec225.len();
                                                                                let layout225 = _rt::alloc::Layout::from_size_align(
                                                                                        vec225.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result225, _cleanup225) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout225,
                                                                                );
                                                                                cleanup_list.extend(_cleanup225);
                                                                                for (i, e) in vec225.into_iter().enumerate() {
                                                                                    let base = result225
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec224 = e;
                                                                                        let ptr224 = vec224.as_ptr().cast::<u8>();
                                                                                        let len224 = vec224.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len224;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr224.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len225;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result225;
                                                                            }
                                                                            V229::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec226 = e;
                                                                                let len226 = vec226.len();
                                                                                let layout226 = _rt::alloc::Layout::from_size_align(
                                                                                        vec226.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result226, _cleanup226) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout226,
                                                                                );
                                                                                cleanup_list.extend(_cleanup226);
                                                                                for (i, e) in vec226.into_iter().enumerate() {
                                                                                    let base = result226.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len226;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result226;
                                                                            }
                                                                            V229::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec227 = e;
                                                                                let ptr227 = vec227.as_ptr().cast::<u8>();
                                                                                let len227 = vec227.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len227;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr227.cast_mut();
                                                                            }
                                                                            V229::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec228 = e;
                                                                                let ptr228 = vec228.as_ptr().cast::<u8>();
                                                                                let len228 = vec228.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len228;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr228.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len230;
                                                                *base.add(0).cast::<*mut u8>() = result230;
                                                                *base
                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(count220);
                                                                let vec231 = bounds220;
                                                                let ptr231 = vec231.as_ptr().cast::<u8>();
                                                                let len231 = vec231.len();
                                                                *base
                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len231;
                                                                *base
                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr231.cast_mut();
                                                                let vec232 = bucket_counts220;
                                                                let ptr232 = vec232.as_ptr().cast::<u8>();
                                                                let len232 = vec232.len();
                                                                *base
                                                                    .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len232;
                                                                *base
                                                                    .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr232.cast_mut();
                                                                match min220 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match max220 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match sum220 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec247 = exemplars220;
                                                                let len247 = vec247.len();
                                                                let layout247 = _rt::alloc::Layout::from_size_align(
                                                                        vec247.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result247, _cleanup247) = wit_bindgen::rt::Cleanup::new(
                                                                    layout247,
                                                                );
                                                                cleanup_list.extend(_cleanup247);
                                                                for (i, e) in vec247.into_iter().enumerate() {
                                                                    let base = result247
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes233,
                                                                            time: time233,
                                                                            value: value233,
                                                                            span_id: span_id233,
                                                                            trace_id: trace_id233,
                                                                        } = e;
                                                                        let vec243 = filtered_attributes233;
                                                                        let len243 = vec243.len();
                                                                        let layout243 = _rt::alloc::Layout::from_size_align(
                                                                                vec243.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result243, _cleanup243) = wit_bindgen::rt::Cleanup::new(
                                                                            layout243,
                                                                        );
                                                                        cleanup_list.extend(_cleanup243);
                                                                        for (i, e) in vec243.into_iter().enumerate() {
                                                                            let base = result243
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key234,
                                                                                    value: value234,
                                                                                } = e;
                                                                                let vec235 = key234;
                                                                                let ptr235 = vec235.as_ptr().cast::<u8>();
                                                                                let len235 = vec235.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len235;
                                                                                *base.add(0).cast::<*mut u8>() = ptr235.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V242;
                                                                                match value234 {
                                                                                    V242::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec236 = e;
                                                                                        let ptr236 = vec236.as_ptr().cast::<u8>();
                                                                                        let len236 = vec236.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len236;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr236.cast_mut();
                                                                                    }
                                                                                    V242::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V242::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V242::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V242::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec238 = e;
                                                                                        let len238 = vec238.len();
                                                                                        let layout238 = _rt::alloc::Layout::from_size_align(
                                                                                                vec238.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result238, _cleanup238) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout238,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup238);
                                                                                        for (i, e) in vec238.into_iter().enumerate() {
                                                                                            let base = result238
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec237 = e;
                                                                                                let ptr237 = vec237.as_ptr().cast::<u8>();
                                                                                                let len237 = vec237.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len237;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr237.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len238;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result238;
                                                                                    }
                                                                                    V242::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec239 = e;
                                                                                        let len239 = vec239.len();
                                                                                        let layout239 = _rt::alloc::Layout::from_size_align(
                                                                                                vec239.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result239, _cleanup239) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout239,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup239);
                                                                                        for (i, e) in vec239.into_iter().enumerate() {
                                                                                            let base = result239.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len239;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result239;
                                                                                    }
                                                                                    V242::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec240 = e;
                                                                                        let ptr240 = vec240.as_ptr().cast::<u8>();
                                                                                        let len240 = vec240.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len240;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr240.cast_mut();
                                                                                    }
                                                                                    V242::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec241 = e;
                                                                                        let ptr241 = vec241.as_ptr().cast::<u8>();
                                                                                        let len241 = vec241.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len241;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr241.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len243;
                                                                        *base.add(0).cast::<*mut u8>() = result243;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds244,
                                                                            nanoseconds: nanoseconds244,
                                                                        } = time233;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds244);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds244);
                                                                        match value233 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec245 = span_id233;
                                                                        let ptr245 = vec245.as_ptr().cast::<u8>();
                                                                        let len245 = vec245.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len245;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr245.cast_mut();
                                                                        let vec246 = trace_id233;
                                                                        let ptr246 = vec246.as_ptr().cast::<u8>();
                                                                        let len246 = vec246.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len246;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr246.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(72 + 7 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len247;
                                                                *base
                                                                    .add(72 + 6 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result247;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len248;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result248;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds249,
                                                            nanoseconds: nanoseconds249,
                                                        } = start_time219;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds249);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds249);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds250,
                                                            nanoseconds: nanoseconds250,
                                                        } = time219;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds250);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds250);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality219.clone() as i32) as u8;
                                                    }
                                                    MetricData::ExponentialHistogram(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (3i32) as u8;
                                                        let ExponentialHistogram {
                                                            data_points: data_points251,
                                                            start_time: start_time251,
                                                            time: time251,
                                                            temporality: temporality251,
                                                        } = e;
                                                        let vec282 = data_points251;
                                                        let len282 = vec282.len();
                                                        let layout282 = _rt::alloc::Layout::from_size_align(
                                                                vec282.len()
                                                                    * (96 + 10 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result282, _cleanup282) = wit_bindgen::rt::Cleanup::new(
                                                            layout282,
                                                        );
                                                        cleanup_list.extend(_cleanup282);
                                                        for (i, e) in vec282.into_iter().enumerate() {
                                                            let base = result282
                                                                .add(i * (96 + 10 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let ExponentialHistogramDataPoint {
                                                                    attributes: attributes252,
                                                                    count: count252,
                                                                    min: min252,
                                                                    max: max252,
                                                                    sum: sum252,
                                                                    scale: scale252,
                                                                    zero_count: zero_count252,
                                                                    positive_bucket: positive_bucket252,
                                                                    negative_bucket: negative_bucket252,
                                                                    zero_threshold: zero_threshold252,
                                                                    exemplars: exemplars252,
                                                                } = e;
                                                                let vec262 = attributes252;
                                                                let len262 = vec262.len();
                                                                let layout262 = _rt::alloc::Layout::from_size_align(
                                                                        vec262.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result262, _cleanup262) = wit_bindgen::rt::Cleanup::new(
                                                                    layout262,
                                                                );
                                                                cleanup_list.extend(_cleanup262);
                                                                for (i, e) in vec262.into_iter().enumerate() {
                                                                    let base = result262
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key253,
                                                                            value: value253,
                                                                        } = e;
                                                                        let vec254 = key253;
                                                                        let ptr254 = vec254.as_ptr().cast::<u8>();
                                                                        let len254 = vec254.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len254;
                                                                        *base.add(0).cast::<*mut u8>() = ptr254.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V261;
                                                                        match value253 {
                                                                            V261::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec255 = e;
                                                                                let ptr255 = vec255.as_ptr().cast::<u8>();
                                                                                let len255 = vec255.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len255;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr255.cast_mut();
                                                                            }
                                                                            V261::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V261::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V261::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V261::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec257 = e;
                                                                                let len257 = vec257.len();
                                                                                let layout257 = _rt::alloc::Layout::from_size_align(
                                                                                        vec257.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result257, _cleanup257) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout257,
                                                                                );
                                                                                cleanup_list.extend(_cleanup257);
                                                                                for (i, e) in vec257.into_iter().enumerate() {
                                                                                    let base = result257
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec256 = e;
                                                                                        let ptr256 = vec256.as_ptr().cast::<u8>();
                                                                                        let len256 = vec256.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len256;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr256.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len257;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result257;
                                                                            }
                                                                            V261::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec258 = e;
                                                                                let len258 = vec258.len();
                                                                                let layout258 = _rt::alloc::Layout::from_size_align(
                                                                                        vec258.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result258, _cleanup258) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout258,
                                                                                );
                                                                                cleanup_list.extend(_cleanup258);
                                                                                for (i, e) in vec258.into_iter().enumerate() {
                                                                                    let base = result258.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len258;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result258;
                                                                            }
                                                                            V261::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec259 = e;
                                                                                let ptr259 = vec259.as_ptr().cast::<u8>();
                                                                                let len259 = vec259.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len259;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr259.cast_mut();
                                                                            }
                                                                            V261::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec260 = e;
                                                                                let ptr260 = vec260.as_ptr().cast::<u8>();
                                                                                let len260 = vec260.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len260;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr260.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len262;
                                                                *base.add(0).cast::<*mut u8>() = result262;
                                                                *base
                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(count252);
                                                                match min252 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match max252 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match sum252 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                *base
                                                                    .add(72 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (_rt::as_i32(scale252)) as u8;
                                                                *base
                                                                    .add(80 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(zero_count252);
                                                                let ExponentialBucket {
                                                                    offset: offset263,
                                                                    counts: counts263,
                                                                } = positive_bucket252;
                                                                *base
                                                                    .add(88 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(offset263);
                                                                let vec264 = counts263;
                                                                let ptr264 = vec264.as_ptr().cast::<u8>();
                                                                let len264 = vec264.len();
                                                                *base
                                                                    .add(88 + 4 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len264;
                                                                *base
                                                                    .add(88 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr264.cast_mut();
                                                                let ExponentialBucket {
                                                                    offset: offset265,
                                                                    counts: counts265,
                                                                } = negative_bucket252;
                                                                *base
                                                                    .add(88 + 5 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(offset265);
                                                                let vec266 = counts265;
                                                                let ptr266 = vec266.as_ptr().cast::<u8>();
                                                                let len266 = vec266.len();
                                                                *base
                                                                    .add(88 + 7 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len266;
                                                                *base
                                                                    .add(88 + 6 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr266.cast_mut();
                                                                *base
                                                                    .add(88 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<f64>() = _rt::as_f64(zero_threshold252);
                                                                let vec281 = exemplars252;
                                                                let len281 = vec281.len();
                                                                let layout281 = _rt::alloc::Layout::from_size_align(
                                                                        vec281.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result281, _cleanup281) = wit_bindgen::rt::Cleanup::new(
                                                                    layout281,
                                                                );
                                                                cleanup_list.extend(_cleanup281);
                                                                for (i, e) in vec281.into_iter().enumerate() {
                                                                    let base = result281
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes267,
                                                                            time: time267,
                                                                            value: value267,
                                                                            span_id: span_id267,
                                                                            trace_id: trace_id267,
                                                                        } = e;
                                                                        let vec277 = filtered_attributes267;
                                                                        let len277 = vec277.len();
                                                                        let layout277 = _rt::alloc::Layout::from_size_align(
                                                                                vec277.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result277, _cleanup277) = wit_bindgen::rt::Cleanup::new(
                                                                            layout277,
                                                                        );
                                                                        cleanup_list.extend(_cleanup277);
                                                                        for (i, e) in vec277.into_iter().enumerate() {
                                                                            let base = result277
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key268,
                                                                                    value: value268,
                                                                                } = e;
                                                                                let vec269 = key268;
                                                                                let ptr269 = vec269.as_ptr().cast::<u8>();
                                                                                let len269 = vec269.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len269;
                                                                                *base.add(0).cast::<*mut u8>() = ptr269.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V276;
                                                                                match value268 {
                                                                                    V276::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec270 = e;
                                                                                        let ptr270 = vec270.as_ptr().cast::<u8>();
                                                                                        let len270 = vec270.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len270;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr270.cast_mut();
                                                                                    }
                                                                                    V276::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V276::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V276::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V276::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec272 = e;
                                                                                        let len272 = vec272.len();
                                                                                        let layout272 = _rt::alloc::Layout::from_size_align(
                                                                                                vec272.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result272, _cleanup272) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout272,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup272);
                                                                                        for (i, e) in vec272.into_iter().enumerate() {
                                                                                            let base = result272
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec271 = e;
                                                                                                let ptr271 = vec271.as_ptr().cast::<u8>();
                                                                                                let len271 = vec271.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len271;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr271.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len272;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result272;
                                                                                    }
                                                                                    V276::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec273 = e;
                                                                                        let len273 = vec273.len();
                                                                                        let layout273 = _rt::alloc::Layout::from_size_align(
                                                                                                vec273.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result273, _cleanup273) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout273,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup273);
                                                                                        for (i, e) in vec273.into_iter().enumerate() {
                                                                                            let base = result273.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len273;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result273;
                                                                                    }
                                                                                    V276::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec274 = e;
                                                                                        let ptr274 = vec274.as_ptr().cast::<u8>();
                                                                                        let len274 = vec274.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len274;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr274.cast_mut();
                                                                                    }
                                                                                    V276::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec275 = e;
                                                                                        let ptr275 = vec275.as_ptr().cast::<u8>();
                                                                                        let len275 = vec275.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len275;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr275.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len277;
                                                                        *base.add(0).cast::<*mut u8>() = result277;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds278,
                                                                            nanoseconds: nanoseconds278,
                                                                        } = time267;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds278);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds278);
                                                                        match value267 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec279 = span_id267;
                                                                        let ptr279 = vec279.as_ptr().cast::<u8>();
                                                                        let len279 = vec279.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len279;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr279.cast_mut();
                                                                        let vec280 = trace_id267;
                                                                        let ptr280 = vec280.as_ptr().cast::<u8>();
                                                                        let len280 = vec280.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len280;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr280.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(96 + 9 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len281;
                                                                *base
                                                                    .add(96 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result281;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len282;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result282;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds283,
                                                            nanoseconds: nanoseconds283,
                                                        } = start_time251;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds283);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds283);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds284,
                                                            nanoseconds: nanoseconds284,
                                                        } = time251;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds284);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds284);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality251.clone() as i32) as u8;
                                                    }
                                                }
                                            }
                                            AggregatedMetrics::S64(e) => {
                                                *base
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (2i32) as u8;
                                                match e {
                                                    MetricData::Gauge(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (0i32) as u8;
                                                        let Gauge {
                                                            data_points: data_points285,
                                                            start_time: start_time285,
                                                            time: time285,
                                                        } = e;
                                                        let vec312 = data_points285;
                                                        let len312 = vec312.len();
                                                        let layout312 = _rt::alloc::Layout::from_size_align(
                                                                vec312.len()
                                                                    * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result312, _cleanup312) = wit_bindgen::rt::Cleanup::new(
                                                            layout312,
                                                        );
                                                        cleanup_list.extend(_cleanup312);
                                                        for (i, e) in vec312.into_iter().enumerate() {
                                                            let base = result312
                                                                .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let GaugeDataPoint {
                                                                    attributes: attributes286,
                                                                    value: value286,
                                                                    exemplars: exemplars286,
                                                                } = e;
                                                                let vec296 = attributes286;
                                                                let len296 = vec296.len();
                                                                let layout296 = _rt::alloc::Layout::from_size_align(
                                                                        vec296.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result296, _cleanup296) = wit_bindgen::rt::Cleanup::new(
                                                                    layout296,
                                                                );
                                                                cleanup_list.extend(_cleanup296);
                                                                for (i, e) in vec296.into_iter().enumerate() {
                                                                    let base = result296
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key287,
                                                                            value: value287,
                                                                        } = e;
                                                                        let vec288 = key287;
                                                                        let ptr288 = vec288.as_ptr().cast::<u8>();
                                                                        let len288 = vec288.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len288;
                                                                        *base.add(0).cast::<*mut u8>() = ptr288.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V295;
                                                                        match value287 {
                                                                            V295::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec289 = e;
                                                                                let ptr289 = vec289.as_ptr().cast::<u8>();
                                                                                let len289 = vec289.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len289;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr289.cast_mut();
                                                                            }
                                                                            V295::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V295::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V295::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V295::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec291 = e;
                                                                                let len291 = vec291.len();
                                                                                let layout291 = _rt::alloc::Layout::from_size_align(
                                                                                        vec291.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result291, _cleanup291) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout291,
                                                                                );
                                                                                cleanup_list.extend(_cleanup291);
                                                                                for (i, e) in vec291.into_iter().enumerate() {
                                                                                    let base = result291
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec290 = e;
                                                                                        let ptr290 = vec290.as_ptr().cast::<u8>();
                                                                                        let len290 = vec290.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len290;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr290.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len291;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result291;
                                                                            }
                                                                            V295::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec292 = e;
                                                                                let len292 = vec292.len();
                                                                                let layout292 = _rt::alloc::Layout::from_size_align(
                                                                                        vec292.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result292, _cleanup292) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout292,
                                                                                );
                                                                                cleanup_list.extend(_cleanup292);
                                                                                for (i, e) in vec292.into_iter().enumerate() {
                                                                                    let base = result292.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len292;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result292;
                                                                            }
                                                                            V295::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec293 = e;
                                                                                let ptr293 = vec293.as_ptr().cast::<u8>();
                                                                                let len293 = vec293.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len293;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr293.cast_mut();
                                                                            }
                                                                            V295::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec294 = e;
                                                                                let ptr294 = vec294.as_ptr().cast::<u8>();
                                                                                let len294 = vec294.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len294;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr294.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len296;
                                                                *base.add(0).cast::<*mut u8>() = result296;
                                                                match value286 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec311 = exemplars286;
                                                                let len311 = vec311.len();
                                                                let layout311 = _rt::alloc::Layout::from_size_align(
                                                                        vec311.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result311, _cleanup311) = wit_bindgen::rt::Cleanup::new(
                                                                    layout311,
                                                                );
                                                                cleanup_list.extend(_cleanup311);
                                                                for (i, e) in vec311.into_iter().enumerate() {
                                                                    let base = result311
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes297,
                                                                            time: time297,
                                                                            value: value297,
                                                                            span_id: span_id297,
                                                                            trace_id: trace_id297,
                                                                        } = e;
                                                                        let vec307 = filtered_attributes297;
                                                                        let len307 = vec307.len();
                                                                        let layout307 = _rt::alloc::Layout::from_size_align(
                                                                                vec307.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result307, _cleanup307) = wit_bindgen::rt::Cleanup::new(
                                                                            layout307,
                                                                        );
                                                                        cleanup_list.extend(_cleanup307);
                                                                        for (i, e) in vec307.into_iter().enumerate() {
                                                                            let base = result307
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key298,
                                                                                    value: value298,
                                                                                } = e;
                                                                                let vec299 = key298;
                                                                                let ptr299 = vec299.as_ptr().cast::<u8>();
                                                                                let len299 = vec299.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len299;
                                                                                *base.add(0).cast::<*mut u8>() = ptr299.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V306;
                                                                                match value298 {
                                                                                    V306::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec300 = e;
                                                                                        let ptr300 = vec300.as_ptr().cast::<u8>();
                                                                                        let len300 = vec300.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len300;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr300.cast_mut();
                                                                                    }
                                                                                    V306::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V306::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V306::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V306::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec302 = e;
                                                                                        let len302 = vec302.len();
                                                                                        let layout302 = _rt::alloc::Layout::from_size_align(
                                                                                                vec302.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result302, _cleanup302) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout302,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup302);
                                                                                        for (i, e) in vec302.into_iter().enumerate() {
                                                                                            let base = result302
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec301 = e;
                                                                                                let ptr301 = vec301.as_ptr().cast::<u8>();
                                                                                                let len301 = vec301.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len301;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr301.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len302;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result302;
                                                                                    }
                                                                                    V306::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec303 = e;
                                                                                        let len303 = vec303.len();
                                                                                        let layout303 = _rt::alloc::Layout::from_size_align(
                                                                                                vec303.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result303, _cleanup303) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout303,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup303);
                                                                                        for (i, e) in vec303.into_iter().enumerate() {
                                                                                            let base = result303.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len303;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result303;
                                                                                    }
                                                                                    V306::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec304 = e;
                                                                                        let ptr304 = vec304.as_ptr().cast::<u8>();
                                                                                        let len304 = vec304.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len304;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr304.cast_mut();
                                                                                    }
                                                                                    V306::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec305 = e;
                                                                                        let ptr305 = vec305.as_ptr().cast::<u8>();
                                                                                        let len305 = vec305.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len305;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr305.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len307;
                                                                        *base.add(0).cast::<*mut u8>() = result307;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds308,
                                                                            nanoseconds: nanoseconds308,
                                                                        } = time297;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds308);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds308);
                                                                        match value297 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec309 = span_id297;
                                                                        let ptr309 = vec309.as_ptr().cast::<u8>();
                                                                        let len309 = vec309.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len309;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr309.cast_mut();
                                                                        let vec310 = trace_id297;
                                                                        let ptr310 = vec310.as_ptr().cast::<u8>();
                                                                        let len310 = vec310.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len310;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr310.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len311;
                                                                *base
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result311;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len312;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result312;
                                                        match start_time285 {
                                                            Some(e) => {
                                                                *base
                                                                    .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (1i32) as u8;
                                                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: seconds313,
                                                                    nanoseconds: nanoseconds313,
                                                                } = e;
                                                                *base
                                                                    .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(seconds313);
                                                                *base
                                                                    .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(nanoseconds313);
                                                            }
                                                            None => {
                                                                *base
                                                                    .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (0i32) as u8;
                                                            }
                                                        };
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds314,
                                                            nanoseconds: nanoseconds314,
                                                        } = time285;
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds314);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds314);
                                                    }
                                                    MetricData::Sum(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (1i32) as u8;
                                                        let Sum {
                                                            data_points: data_points315,
                                                            start_time: start_time315,
                                                            time: time315,
                                                            temporality: temporality315,
                                                            is_monotonic: is_monotonic315,
                                                        } = e;
                                                        let vec342 = data_points315;
                                                        let len342 = vec342.len();
                                                        let layout342 = _rt::alloc::Layout::from_size_align(
                                                                vec342.len()
                                                                    * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result342, _cleanup342) = wit_bindgen::rt::Cleanup::new(
                                                            layout342,
                                                        );
                                                        cleanup_list.extend(_cleanup342);
                                                        for (i, e) in vec342.into_iter().enumerate() {
                                                            let base = result342
                                                                .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let SumDataPoint {
                                                                    attributes: attributes316,
                                                                    value: value316,
                                                                    exemplars: exemplars316,
                                                                } = e;
                                                                let vec326 = attributes316;
                                                                let len326 = vec326.len();
                                                                let layout326 = _rt::alloc::Layout::from_size_align(
                                                                        vec326.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result326, _cleanup326) = wit_bindgen::rt::Cleanup::new(
                                                                    layout326,
                                                                );
                                                                cleanup_list.extend(_cleanup326);
                                                                for (i, e) in vec326.into_iter().enumerate() {
                                                                    let base = result326
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key317,
                                                                            value: value317,
                                                                        } = e;
                                                                        let vec318 = key317;
                                                                        let ptr318 = vec318.as_ptr().cast::<u8>();
                                                                        let len318 = vec318.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len318;
                                                                        *base.add(0).cast::<*mut u8>() = ptr318.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V325;
                                                                        match value317 {
                                                                            V325::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec319 = e;
                                                                                let ptr319 = vec319.as_ptr().cast::<u8>();
                                                                                let len319 = vec319.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len319;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr319.cast_mut();
                                                                            }
                                                                            V325::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V325::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V325::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V325::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec321 = e;
                                                                                let len321 = vec321.len();
                                                                                let layout321 = _rt::alloc::Layout::from_size_align(
                                                                                        vec321.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result321, _cleanup321) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout321,
                                                                                );
                                                                                cleanup_list.extend(_cleanup321);
                                                                                for (i, e) in vec321.into_iter().enumerate() {
                                                                                    let base = result321
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec320 = e;
                                                                                        let ptr320 = vec320.as_ptr().cast::<u8>();
                                                                                        let len320 = vec320.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len320;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr320.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len321;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result321;
                                                                            }
                                                                            V325::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec322 = e;
                                                                                let len322 = vec322.len();
                                                                                let layout322 = _rt::alloc::Layout::from_size_align(
                                                                                        vec322.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result322, _cleanup322) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout322,
                                                                                );
                                                                                cleanup_list.extend(_cleanup322);
                                                                                for (i, e) in vec322.into_iter().enumerate() {
                                                                                    let base = result322.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len322;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result322;
                                                                            }
                                                                            V325::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec323 = e;
                                                                                let ptr323 = vec323.as_ptr().cast::<u8>();
                                                                                let len323 = vec323.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len323;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr323.cast_mut();
                                                                            }
                                                                            V325::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec324 = e;
                                                                                let ptr324 = vec324.as_ptr().cast::<u8>();
                                                                                let len324 = vec324.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len324;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr324.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len326;
                                                                *base.add(0).cast::<*mut u8>() = result326;
                                                                match value316 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec341 = exemplars316;
                                                                let len341 = vec341.len();
                                                                let layout341 = _rt::alloc::Layout::from_size_align(
                                                                        vec341.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result341, _cleanup341) = wit_bindgen::rt::Cleanup::new(
                                                                    layout341,
                                                                );
                                                                cleanup_list.extend(_cleanup341);
                                                                for (i, e) in vec341.into_iter().enumerate() {
                                                                    let base = result341
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes327,
                                                                            time: time327,
                                                                            value: value327,
                                                                            span_id: span_id327,
                                                                            trace_id: trace_id327,
                                                                        } = e;
                                                                        let vec337 = filtered_attributes327;
                                                                        let len337 = vec337.len();
                                                                        let layout337 = _rt::alloc::Layout::from_size_align(
                                                                                vec337.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result337, _cleanup337) = wit_bindgen::rt::Cleanup::new(
                                                                            layout337,
                                                                        );
                                                                        cleanup_list.extend(_cleanup337);
                                                                        for (i, e) in vec337.into_iter().enumerate() {
                                                                            let base = result337
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key328,
                                                                                    value: value328,
                                                                                } = e;
                                                                                let vec329 = key328;
                                                                                let ptr329 = vec329.as_ptr().cast::<u8>();
                                                                                let len329 = vec329.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len329;
                                                                                *base.add(0).cast::<*mut u8>() = ptr329.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V336;
                                                                                match value328 {
                                                                                    V336::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec330 = e;
                                                                                        let ptr330 = vec330.as_ptr().cast::<u8>();
                                                                                        let len330 = vec330.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len330;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr330.cast_mut();
                                                                                    }
                                                                                    V336::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V336::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V336::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V336::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec332 = e;
                                                                                        let len332 = vec332.len();
                                                                                        let layout332 = _rt::alloc::Layout::from_size_align(
                                                                                                vec332.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result332, _cleanup332) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout332,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup332);
                                                                                        for (i, e) in vec332.into_iter().enumerate() {
                                                                                            let base = result332
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec331 = e;
                                                                                                let ptr331 = vec331.as_ptr().cast::<u8>();
                                                                                                let len331 = vec331.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len331;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr331.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len332;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result332;
                                                                                    }
                                                                                    V336::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec333 = e;
                                                                                        let len333 = vec333.len();
                                                                                        let layout333 = _rt::alloc::Layout::from_size_align(
                                                                                                vec333.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result333, _cleanup333) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout333,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup333);
                                                                                        for (i, e) in vec333.into_iter().enumerate() {
                                                                                            let base = result333.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len333;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result333;
                                                                                    }
                                                                                    V336::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec334 = e;
                                                                                        let ptr334 = vec334.as_ptr().cast::<u8>();
                                                                                        let len334 = vec334.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len334;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr334.cast_mut();
                                                                                    }
                                                                                    V336::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec335 = e;
                                                                                        let ptr335 = vec335.as_ptr().cast::<u8>();
                                                                                        let len335 = vec335.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len335;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr335.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len337;
                                                                        *base.add(0).cast::<*mut u8>() = result337;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds338,
                                                                            nanoseconds: nanoseconds338,
                                                                        } = time327;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds338);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds338);
                                                                        match value327 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec339 = span_id327;
                                                                        let ptr339 = vec339.as_ptr().cast::<u8>();
                                                                        let len339 = vec339.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len339;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr339.cast_mut();
                                                                        let vec340 = trace_id327;
                                                                        let ptr340 = vec340.as_ptr().cast::<u8>();
                                                                        let len340 = vec340.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len340;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr340.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len341;
                                                                *base
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result341;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len342;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result342;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds343,
                                                            nanoseconds: nanoseconds343,
                                                        } = start_time315;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds343);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds343);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds344,
                                                            nanoseconds: nanoseconds344,
                                                        } = time315;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds344);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds344);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality315.clone() as i32) as u8;
                                                        *base
                                                            .add(49 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (match is_monotonic315 {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    MetricData::Histogram(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (2i32) as u8;
                                                        let Histogram {
                                                            data_points: data_points345,
                                                            start_time: start_time345,
                                                            time: time345,
                                                            temporality: temporality345,
                                                        } = e;
                                                        let vec374 = data_points345;
                                                        let len374 = vec374.len();
                                                        let layout374 = _rt::alloc::Layout::from_size_align(
                                                                vec374.len()
                                                                    * (72 + 8 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result374, _cleanup374) = wit_bindgen::rt::Cleanup::new(
                                                            layout374,
                                                        );
                                                        cleanup_list.extend(_cleanup374);
                                                        for (i, e) in vec374.into_iter().enumerate() {
                                                            let base = result374
                                                                .add(i * (72 + 8 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let HistogramDataPoint {
                                                                    attributes: attributes346,
                                                                    count: count346,
                                                                    bounds: bounds346,
                                                                    bucket_counts: bucket_counts346,
                                                                    min: min346,
                                                                    max: max346,
                                                                    sum: sum346,
                                                                    exemplars: exemplars346,
                                                                } = e;
                                                                let vec356 = attributes346;
                                                                let len356 = vec356.len();
                                                                let layout356 = _rt::alloc::Layout::from_size_align(
                                                                        vec356.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result356, _cleanup356) = wit_bindgen::rt::Cleanup::new(
                                                                    layout356,
                                                                );
                                                                cleanup_list.extend(_cleanup356);
                                                                for (i, e) in vec356.into_iter().enumerate() {
                                                                    let base = result356
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key347,
                                                                            value: value347,
                                                                        } = e;
                                                                        let vec348 = key347;
                                                                        let ptr348 = vec348.as_ptr().cast::<u8>();
                                                                        let len348 = vec348.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len348;
                                                                        *base.add(0).cast::<*mut u8>() = ptr348.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V355;
                                                                        match value347 {
                                                                            V355::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec349 = e;
                                                                                let ptr349 = vec349.as_ptr().cast::<u8>();
                                                                                let len349 = vec349.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len349;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr349.cast_mut();
                                                                            }
                                                                            V355::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V355::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V355::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V355::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec351 = e;
                                                                                let len351 = vec351.len();
                                                                                let layout351 = _rt::alloc::Layout::from_size_align(
                                                                                        vec351.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result351, _cleanup351) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout351,
                                                                                );
                                                                                cleanup_list.extend(_cleanup351);
                                                                                for (i, e) in vec351.into_iter().enumerate() {
                                                                                    let base = result351
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec350 = e;
                                                                                        let ptr350 = vec350.as_ptr().cast::<u8>();
                                                                                        let len350 = vec350.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len350;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr350.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len351;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result351;
                                                                            }
                                                                            V355::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec352 = e;
                                                                                let len352 = vec352.len();
                                                                                let layout352 = _rt::alloc::Layout::from_size_align(
                                                                                        vec352.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result352, _cleanup352) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout352,
                                                                                );
                                                                                cleanup_list.extend(_cleanup352);
                                                                                for (i, e) in vec352.into_iter().enumerate() {
                                                                                    let base = result352.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len352;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result352;
                                                                            }
                                                                            V355::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec353 = e;
                                                                                let ptr353 = vec353.as_ptr().cast::<u8>();
                                                                                let len353 = vec353.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len353;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr353.cast_mut();
                                                                            }
                                                                            V355::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec354 = e;
                                                                                let ptr354 = vec354.as_ptr().cast::<u8>();
                                                                                let len354 = vec354.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len354;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr354.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len356;
                                                                *base.add(0).cast::<*mut u8>() = result356;
                                                                *base
                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(count346);
                                                                let vec357 = bounds346;
                                                                let ptr357 = vec357.as_ptr().cast::<u8>();
                                                                let len357 = vec357.len();
                                                                *base
                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len357;
                                                                *base
                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr357.cast_mut();
                                                                let vec358 = bucket_counts346;
                                                                let ptr358 = vec358.as_ptr().cast::<u8>();
                                                                let len358 = vec358.len();
                                                                *base
                                                                    .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len358;
                                                                *base
                                                                    .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr358.cast_mut();
                                                                match min346 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match max346 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match sum346 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                let vec373 = exemplars346;
                                                                let len373 = vec373.len();
                                                                let layout373 = _rt::alloc::Layout::from_size_align(
                                                                        vec373.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result373, _cleanup373) = wit_bindgen::rt::Cleanup::new(
                                                                    layout373,
                                                                );
                                                                cleanup_list.extend(_cleanup373);
                                                                for (i, e) in vec373.into_iter().enumerate() {
                                                                    let base = result373
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes359,
                                                                            time: time359,
                                                                            value: value359,
                                                                            span_id: span_id359,
                                                                            trace_id: trace_id359,
                                                                        } = e;
                                                                        let vec369 = filtered_attributes359;
                                                                        let len369 = vec369.len();
                                                                        let layout369 = _rt::alloc::Layout::from_size_align(
                                                                                vec369.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result369, _cleanup369) = wit_bindgen::rt::Cleanup::new(
                                                                            layout369,
                                                                        );
                                                                        cleanup_list.extend(_cleanup369);
                                                                        for (i, e) in vec369.into_iter().enumerate() {
                                                                            let base = result369
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key360,
                                                                                    value: value360,
                                                                                } = e;
                                                                                let vec361 = key360;
                                                                                let ptr361 = vec361.as_ptr().cast::<u8>();
                                                                                let len361 = vec361.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len361;
                                                                                *base.add(0).cast::<*mut u8>() = ptr361.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V368;
                                                                                match value360 {
                                                                                    V368::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec362 = e;
                                                                                        let ptr362 = vec362.as_ptr().cast::<u8>();
                                                                                        let len362 = vec362.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len362;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr362.cast_mut();
                                                                                    }
                                                                                    V368::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V368::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V368::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V368::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec364 = e;
                                                                                        let len364 = vec364.len();
                                                                                        let layout364 = _rt::alloc::Layout::from_size_align(
                                                                                                vec364.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result364, _cleanup364) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout364,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup364);
                                                                                        for (i, e) in vec364.into_iter().enumerate() {
                                                                                            let base = result364
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec363 = e;
                                                                                                let ptr363 = vec363.as_ptr().cast::<u8>();
                                                                                                let len363 = vec363.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len363;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr363.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len364;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result364;
                                                                                    }
                                                                                    V368::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec365 = e;
                                                                                        let len365 = vec365.len();
                                                                                        let layout365 = _rt::alloc::Layout::from_size_align(
                                                                                                vec365.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result365, _cleanup365) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout365,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup365);
                                                                                        for (i, e) in vec365.into_iter().enumerate() {
                                                                                            let base = result365.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len365;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result365;
                                                                                    }
                                                                                    V368::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec366 = e;
                                                                                        let ptr366 = vec366.as_ptr().cast::<u8>();
                                                                                        let len366 = vec366.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len366;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr366.cast_mut();
                                                                                    }
                                                                                    V368::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec367 = e;
                                                                                        let ptr367 = vec367.as_ptr().cast::<u8>();
                                                                                        let len367 = vec367.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len367;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr367.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len369;
                                                                        *base.add(0).cast::<*mut u8>() = result369;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds370,
                                                                            nanoseconds: nanoseconds370,
                                                                        } = time359;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds370);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds370);
                                                                        match value359 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec371 = span_id359;
                                                                        let ptr371 = vec371.as_ptr().cast::<u8>();
                                                                        let len371 = vec371.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len371;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr371.cast_mut();
                                                                        let vec372 = trace_id359;
                                                                        let ptr372 = vec372.as_ptr().cast::<u8>();
                                                                        let len372 = vec372.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len372;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr372.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(72 + 7 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len373;
                                                                *base
                                                                    .add(72 + 6 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result373;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len374;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result374;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds375,
                                                            nanoseconds: nanoseconds375,
                                                        } = start_time345;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds375);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds375);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds376,
                                                            nanoseconds: nanoseconds376,
                                                        } = time345;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds376);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds376);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality345.clone() as i32) as u8;
                                                    }
                                                    MetricData::ExponentialHistogram(e) => {
                                                        *base
                                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (3i32) as u8;
                                                        let ExponentialHistogram {
                                                            data_points: data_points377,
                                                            start_time: start_time377,
                                                            time: time377,
                                                            temporality: temporality377,
                                                        } = e;
                                                        let vec408 = data_points377;
                                                        let len408 = vec408.len();
                                                        let layout408 = _rt::alloc::Layout::from_size_align(
                                                                vec408.len()
                                                                    * (96 + 10 * ::core::mem::size_of::<*const u8>()),
                                                                8,
                                                            )
                                                            .unwrap();
                                                        let (result408, _cleanup408) = wit_bindgen::rt::Cleanup::new(
                                                            layout408,
                                                        );
                                                        cleanup_list.extend(_cleanup408);
                                                        for (i, e) in vec408.into_iter().enumerate() {
                                                            let base = result408
                                                                .add(i * (96 + 10 * ::core::mem::size_of::<*const u8>()));
                                                            {
                                                                let ExponentialHistogramDataPoint {
                                                                    attributes: attributes378,
                                                                    count: count378,
                                                                    min: min378,
                                                                    max: max378,
                                                                    sum: sum378,
                                                                    scale: scale378,
                                                                    zero_count: zero_count378,
                                                                    positive_bucket: positive_bucket378,
                                                                    negative_bucket: negative_bucket378,
                                                                    zero_threshold: zero_threshold378,
                                                                    exemplars: exemplars378,
                                                                } = e;
                                                                let vec388 = attributes378;
                                                                let len388 = vec388.len();
                                                                let layout388 = _rt::alloc::Layout::from_size_align(
                                                                        vec388.len()
                                                                            * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result388, _cleanup388) = wit_bindgen::rt::Cleanup::new(
                                                                    layout388,
                                                                );
                                                                cleanup_list.extend(_cleanup388);
                                                                for (i, e) in vec388.into_iter().enumerate() {
                                                                    let base = result388
                                                                        .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let super::super::super::wasi::otel::types::KeyValue {
                                                                            key: key379,
                                                                            value: value379,
                                                                        } = e;
                                                                        let vec380 = key379;
                                                                        let ptr380 = vec380.as_ptr().cast::<u8>();
                                                                        let len380 = vec380.len();
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len380;
                                                                        *base.add(0).cast::<*mut u8>() = ptr380.cast_mut();
                                                                        use super::super::super::wasi::otel::types::Value as V387;
                                                                        match value379 {
                                                                            V387::String(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                let vec381 = e;
                                                                                let ptr381 = vec381.as_ptr().cast::<u8>();
                                                                                let len381 = vec381.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len381;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr381.cast_mut();
                                                                            }
                                                                            V387::Bool(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V387::F64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            V387::S64(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (3i32) as u8;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            V387::StringArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (4i32) as u8;
                                                                                let vec383 = e;
                                                                                let len383 = vec383.len();
                                                                                let layout383 = _rt::alloc::Layout::from_size_align(
                                                                                        vec383.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                        ::core::mem::size_of::<*const u8>(),
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result383, _cleanup383) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout383,
                                                                                );
                                                                                cleanup_list.extend(_cleanup383);
                                                                                for (i, e) in vec383.into_iter().enumerate() {
                                                                                    let base = result383
                                                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                        let vec382 = e;
                                                                                        let ptr382 = vec382.as_ptr().cast::<u8>();
                                                                                        let len382 = vec382.len();
                                                                                        *base
                                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len382;
                                                                                        *base.add(0).cast::<*mut u8>() = ptr382.cast_mut();
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len383;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result383;
                                                                            }
                                                                            V387::BoolArray(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (5i32) as u8;
                                                                                let vec384 = e;
                                                                                let len384 = vec384.len();
                                                                                let layout384 = _rt::alloc::Layout::from_size_align(
                                                                                        vec384.len() * 1,
                                                                                        1,
                                                                                    )
                                                                                    .unwrap();
                                                                                let (result384, _cleanup384) = wit_bindgen::rt::Cleanup::new(
                                                                                    layout384,
                                                                                );
                                                                                cleanup_list.extend(_cleanup384);
                                                                                for (i, e) in vec384.into_iter().enumerate() {
                                                                                    let base = result384.add(i * 1);
                                                                                    {
                                                                                        *base.add(0).cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                }
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len384;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = result384;
                                                                            }
                                                                            V387::F64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (6i32) as u8;
                                                                                let vec385 = e;
                                                                                let ptr385 = vec385.as_ptr().cast::<u8>();
                                                                                let len385 = vec385.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len385;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr385.cast_mut();
                                                                            }
                                                                            V387::S64Array(e) => {
                                                                                *base
                                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (7i32) as u8;
                                                                                let vec386 = e;
                                                                                let ptr386 = vec386.as_ptr().cast::<u8>();
                                                                                let len386 = vec386.len();
                                                                                *base
                                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len386;
                                                                                *base
                                                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<*mut u8>() = ptr386.cast_mut();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *base
                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len388;
                                                                *base.add(0).cast::<*mut u8>() = result388;
                                                                *base
                                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(count378);
                                                                match min378 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match max378 {
                                                                    Some(e) => {
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        match e {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                    }
                                                                    None => {
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                };
                                                                match sum378 {
                                                                    DataValue::F64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (0i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                    }
                                                                    DataValue::U64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (1i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                    DataValue::S64(e) => {
                                                                        *base
                                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>() = (2i32) as u8;
                                                                        *base
                                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                    }
                                                                }
                                                                *base
                                                                    .add(72 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>() = (_rt::as_i32(scale378)) as u8;
                                                                *base
                                                                    .add(80 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i64>() = _rt::as_i64(zero_count378);
                                                                let ExponentialBucket {
                                                                    offset: offset389,
                                                                    counts: counts389,
                                                                } = positive_bucket378;
                                                                *base
                                                                    .add(88 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(offset389);
                                                                let vec390 = counts389;
                                                                let ptr390 = vec390.as_ptr().cast::<u8>();
                                                                let len390 = vec390.len();
                                                                *base
                                                                    .add(88 + 4 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len390;
                                                                *base
                                                                    .add(88 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr390.cast_mut();
                                                                let ExponentialBucket {
                                                                    offset: offset391,
                                                                    counts: counts391,
                                                                } = negative_bucket378;
                                                                *base
                                                                    .add(88 + 5 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>() = _rt::as_i32(offset391);
                                                                let vec392 = counts391;
                                                                let ptr392 = vec392.as_ptr().cast::<u8>();
                                                                let len392 = vec392.len();
                                                                *base
                                                                    .add(88 + 7 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len392;
                                                                *base
                                                                    .add(88 + 6 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = ptr392.cast_mut();
                                                                *base
                                                                    .add(88 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<f64>() = _rt::as_f64(zero_threshold378);
                                                                let vec407 = exemplars378;
                                                                let len407 = vec407.len();
                                                                let layout407 = _rt::alloc::Layout::from_size_align(
                                                                        vec407.len()
                                                                            * (32 + 6 * ::core::mem::size_of::<*const u8>()),
                                                                        8,
                                                                    )
                                                                    .unwrap();
                                                                let (result407, _cleanup407) = wit_bindgen::rt::Cleanup::new(
                                                                    layout407,
                                                                );
                                                                cleanup_list.extend(_cleanup407);
                                                                for (i, e) in vec407.into_iter().enumerate() {
                                                                    let base = result407
                                                                        .add(i * (32 + 6 * ::core::mem::size_of::<*const u8>()));
                                                                    {
                                                                        let Exemplar {
                                                                            filtered_attributes: filtered_attributes393,
                                                                            time: time393,
                                                                            value: value393,
                                                                            span_id: span_id393,
                                                                            trace_id: trace_id393,
                                                                        } = e;
                                                                        let vec403 = filtered_attributes393;
                                                                        let len403 = vec403.len();
                                                                        let layout403 = _rt::alloc::Layout::from_size_align(
                                                                                vec403.len()
                                                                                    * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                                                                8,
                                                                            )
                                                                            .unwrap();
                                                                        let (result403, _cleanup403) = wit_bindgen::rt::Cleanup::new(
                                                                            layout403,
                                                                        );
                                                                        cleanup_list.extend(_cleanup403);
                                                                        for (i, e) in vec403.into_iter().enumerate() {
                                                                            let base = result403
                                                                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                                                            {
                                                                                let super::super::super::wasi::otel::types::KeyValue {
                                                                                    key: key394,
                                                                                    value: value394,
                                                                                } = e;
                                                                                let vec395 = key394;
                                                                                let ptr395 = vec395.as_ptr().cast::<u8>();
                                                                                let len395 = vec395.len();
                                                                                *base
                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                    .cast::<usize>() = len395;
                                                                                *base.add(0).cast::<*mut u8>() = ptr395.cast_mut();
                                                                                use super::super::super::wasi::otel::types::Value as V402;
                                                                                match value394 {
                                                                                    V402::String(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (0i32) as u8;
                                                                                        let vec396 = e;
                                                                                        let ptr396 = vec396.as_ptr().cast::<u8>();
                                                                                        let len396 = vec396.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len396;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr396.cast_mut();
                                                                                    }
                                                                                    V402::Bool(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (1i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (match e {
                                                                                            true => 1,
                                                                                            false => 0,
                                                                                        }) as u8;
                                                                                    }
                                                                                    V402::F64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (2i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<f64>() = _rt::as_f64(e);
                                                                                    }
                                                                                    V402::S64(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (3i32) as u8;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i64>() = _rt::as_i64(e);
                                                                                    }
                                                                                    V402::StringArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (4i32) as u8;
                                                                                        let vec398 = e;
                                                                                        let len398 = vec398.len();
                                                                                        let layout398 = _rt::alloc::Layout::from_size_align(
                                                                                                vec398.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                                                                ::core::mem::size_of::<*const u8>(),
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result398, _cleanup398) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout398,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup398);
                                                                                        for (i, e) in vec398.into_iter().enumerate() {
                                                                                            let base = result398
                                                                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                                                            {
                                                                                                let vec397 = e;
                                                                                                let ptr397 = vec397.as_ptr().cast::<u8>();
                                                                                                let len397 = vec397.len();
                                                                                                *base
                                                                                                    .add(::core::mem::size_of::<*const u8>())
                                                                                                    .cast::<usize>() = len397;
                                                                                                *base.add(0).cast::<*mut u8>() = ptr397.cast_mut();
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len398;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result398;
                                                                                    }
                                                                                    V402::BoolArray(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (5i32) as u8;
                                                                                        let vec399 = e;
                                                                                        let len399 = vec399.len();
                                                                                        let layout399 = _rt::alloc::Layout::from_size_align(
                                                                                                vec399.len() * 1,
                                                                                                1,
                                                                                            )
                                                                                            .unwrap();
                                                                                        let (result399, _cleanup399) = wit_bindgen::rt::Cleanup::new(
                                                                                            layout399,
                                                                                        );
                                                                                        cleanup_list.extend(_cleanup399);
                                                                                        for (i, e) in vec399.into_iter().enumerate() {
                                                                                            let base = result399.add(i * 1);
                                                                                            {
                                                                                                *base.add(0).cast::<u8>() = (match e {
                                                                                                    true => 1,
                                                                                                    false => 0,
                                                                                                }) as u8;
                                                                                            }
                                                                                        }
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len399;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = result399;
                                                                                    }
                                                                                    V402::F64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (6i32) as u8;
                                                                                        let vec400 = e;
                                                                                        let ptr400 = vec400.as_ptr().cast::<u8>();
                                                                                        let len400 = vec400.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len400;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr400.cast_mut();
                                                                                    }
                                                                                    V402::S64Array(e) => {
                                                                                        *base
                                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>() = (7i32) as u8;
                                                                                        let vec401 = e;
                                                                                        let ptr401 = vec401.as_ptr().cast::<u8>();
                                                                                        let len401 = vec401.len();
                                                                                        *base
                                                                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>() = len401;
                                                                                        *base
                                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>() = ptr401.cast_mut();
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        *base
                                                                            .add(::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len403;
                                                                        *base.add(0).cast::<*mut u8>() = result403;
                                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                            seconds: seconds404,
                                                                            nanoseconds: nanoseconds404,
                                                                        } = time393;
                                                                        *base
                                                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i64>() = _rt::as_i64(seconds404);
                                                                        *base
                                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>() = _rt::as_i32(nanoseconds404);
                                                                        match value393 {
                                                                            DataValue::F64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (0i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<f64>() = _rt::as_f64(e);
                                                                            }
                                                                            DataValue::U64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (1i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                            DataValue::S64(e) => {
                                                                                *base
                                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<u8>() = (2i32) as u8;
                                                                                *base
                                                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                    .cast::<i64>() = _rt::as_i64(e);
                                                                            }
                                                                        }
                                                                        let vec405 = span_id393;
                                                                        let ptr405 = vec405.as_ptr().cast::<u8>();
                                                                        let len405 = vec405.len();
                                                                        *base
                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len405;
                                                                        *base
                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr405.cast_mut();
                                                                        let vec406 = trace_id393;
                                                                        let ptr406 = vec406.as_ptr().cast::<u8>();
                                                                        let len406 = vec406.len();
                                                                        *base
                                                                            .add(32 + 5 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>() = len406;
                                                                        *base
                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>() = ptr406.cast_mut();
                                                                    }
                                                                }
                                                                *base
                                                                    .add(96 + 9 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>() = len407;
                                                                *base
                                                                    .add(96 + 8 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>() = result407;
                                                            }
                                                        }
                                                        *base
                                                            .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>() = len408;
                                                        *base
                                                            .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>() = result408;
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds409,
                                                            nanoseconds: nanoseconds409,
                                                        } = start_time377;
                                                        *base
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds409);
                                                        *base
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds409);
                                                        let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                            seconds: seconds410,
                                                            nanoseconds: nanoseconds410,
                                                        } = time377;
                                                        *base
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i64>() = _rt::as_i64(seconds410);
                                                        *base
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>() = _rt::as_i32(nanoseconds410);
                                                        *base
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>() = (temporality377.clone() as i32) as u8;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                *base
                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len411;
                                *base
                                    .add(10 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = result411;
                            }
                        }
                        let ptr413 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import414(
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import414(
                            result11,
                            len11,
                            result13_0,
                            result13_1,
                            result13_2,
                            result412,
                            len412,
                            ptr413,
                        );
                        let l415 = i32::from(*ptr413.add(0).cast::<u8>());
                        let result422 = match l415 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l416 = i32::from(*ptr413.add(8).cast::<u8>());
                                    use super::super::super::wasi::otel::types::Error as V421;
                                    let v421 = match l416 {
                                        0 => V421::AlreadyShutdown,
                                        1 => {
                                            let e421 = {
                                                let l417 = *ptr413.add(16).cast::<i64>();
                                                l417 as u64
                                            };
                                            V421::Timeout(e421)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &2) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e421 = {
                                                let l418 = *ptr413.add(16).cast::<*mut u8>();
                                                let l419 = *ptr413
                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len420 = l419;
                                                let bytes420 = _rt::Vec::from_raw_parts(
                                                    l418.cast(),
                                                    len420,
                                                    len420,
                                                );
                                                _rt::string_lift(bytes420)
                                            };
                                            V421::InternalFailure(e421)
                                        }
                                    };
                                    v421
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result422
                    }
                }
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod resource {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                pub type TelemetryResource = super::super::super::wasi::otel::types::Resource;
                #[allow(unused_unsafe, clippy::all)]
                /// Returns the telemetry resource used by the host.
                #[allow(async_fn_in_trait)]
                pub fn resource() -> TelemetryResource {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 5 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 5
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import1(_: *mut u8) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import1(ptr0);
                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                        let l3 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let base31 = l2;
                        let len31 = l3;
                        let mut result31 = _rt::Vec::with_capacity(len31);
                        for i in 0..len31 {
                            let base = base31
                                .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                            let e31 = {
                                let l4 = *base.add(0).cast::<*mut u8>();
                                let l5 = *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len6 = l5;
                                let bytes6 = _rt::Vec::from_raw_parts(
                                    l4.cast(),
                                    len6,
                                    len6,
                                );
                                let l7 = i32::from(
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                use super::super::super::wasi::otel::types::Value as V30;
                                let v30 = match l7 {
                                    0 => {
                                        let e30 = {
                                            let l8 = *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l9 = *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                l8.cast(),
                                                len10,
                                                len10,
                                            );
                                            _rt::string_lift(bytes10)
                                        };
                                        V30::String(e30)
                                    }
                                    1 => {
                                        let e30 = {
                                            let l11 = i32::from(
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            _rt::bool_lift(l11 as u8)
                                        };
                                        V30::Bool(e30)
                                    }
                                    2 => {
                                        let e30 = {
                                            let l12 = *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<f64>();
                                            l12
                                        };
                                        V30::F64(e30)
                                    }
                                    3 => {
                                        let e30 = {
                                            let l13 = *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i64>();
                                            l13
                                        };
                                        V30::S64(e30)
                                    }
                                    4 => {
                                        let e30 = {
                                            let l14 = *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l15 = *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base19 = l14;
                                            let len19 = l15;
                                            let mut result19 = _rt::Vec::with_capacity(len19);
                                            for i in 0..len19 {
                                                let base = base19
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                let e19 = {
                                                    let l16 = *base.add(0).cast::<*mut u8>();
                                                    let l17 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len18 = l17;
                                                    let bytes18 = _rt::Vec::from_raw_parts(
                                                        l16.cast(),
                                                        len18,
                                                        len18,
                                                    );
                                                    _rt::string_lift(bytes18)
                                                };
                                                result19.push(e19);
                                            }
                                            _rt::cabi_dealloc(
                                                base19,
                                                len19 * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            result19
                                        };
                                        V30::StringArray(e30)
                                    }
                                    5 => {
                                        let e30 = {
                                            let l20 = *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l21 = *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base23 = l20;
                                            let len23 = l21;
                                            let mut result23 = _rt::Vec::with_capacity(len23);
                                            for i in 0..len23 {
                                                let base = base23.add(i * 1);
                                                let e23 = {
                                                    let l22 = i32::from(*base.add(0).cast::<u8>());
                                                    _rt::bool_lift(l22 as u8)
                                                };
                                                result23.push(e23);
                                            }
                                            _rt::cabi_dealloc(base23, len23 * 1, 1);
                                            result23
                                        };
                                        V30::BoolArray(e30)
                                    }
                                    6 => {
                                        let e30 = {
                                            let l24 = *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l25 = *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len26 = l25;
                                            _rt::Vec::from_raw_parts(l24.cast(), len26, len26)
                                        };
                                        V30::F64Array(e30)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &7) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e30 = {
                                            let l27 = *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l28 = *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len29 = l28;
                                            _rt::Vec::from_raw_parts(l27.cast(), len29, len29)
                                        };
                                        V30::S64Array(e30)
                                    }
                                };
                                super::super::super::wasi::otel::types::KeyValue {
                                    key: _rt::string_lift(bytes6),
                                    value: v30,
                                }
                            };
                            result31.push(e31);
                        }
                        _rt::cabi_dealloc(
                            base31,
                            len31 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                            8,
                        );
                        let l32 = i32::from(
                            *ptr0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>(),
                        );
                        let result36 = super::super::super::wasi::otel::types::Resource {
                            attributes: result31,
                            schema_url: match l32 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l33 = *ptr0
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l34 = *ptr0
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len35 = l34;
                                        let bytes35 = _rt::Vec::from_raw_parts(
                                            l33.cast(),
                                            len35,
                                            len35,
                                        );
                                        _rt::string_lift(bytes35)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        };
                        result36
                    }
                }
            }
        }
    }
    mod _rt {
        #![allow(dead_code, clippy::all)]
        pub use alloc_crate::string::String;
        pub use alloc_crate::vec::Vec;
        pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
            if true {
                String::from_utf8(bytes).unwrap()
            } else {
                unsafe { String::from_utf8_unchecked(bytes) }
            }
        }
        pub unsafe fn bool_lift(val: u8) -> bool {
            if true {
                match val {
                    0 => false,
                    1 => true,
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!("invalid bool discriminant"),
                        );
                    }
                }
            } else {
                val != 0
            }
        }
        pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
            if size == 0 {
                return;
            }
            unsafe {
                let layout = alloc::Layout::from_size_align_unchecked(size, align);
                alloc::dealloc(ptr, layout);
            }
        }
        pub use alloc_crate::alloc;
        pub fn as_i64<T: AsI64>(t: T) -> i64 {
            t.as_i64()
        }
        pub trait AsI64 {
            fn as_i64(self) -> i64;
        }
        impl<'a, T: Copy + AsI64> AsI64 for &'a T {
            fn as_i64(self) -> i64 {
                (*self).as_i64()
            }
        }
        impl AsI64 for i64 {
            #[inline]
            fn as_i64(self) -> i64 {
                self as i64
            }
        }
        impl AsI64 for u64 {
            #[inline]
            fn as_i64(self) -> i64 {
                self as i64
            }
        }
        pub fn as_i32<T: AsI32>(t: T) -> i32 {
            t.as_i32()
        }
        pub trait AsI32 {
            fn as_i32(self) -> i32;
        }
        impl<'a, T: Copy + AsI32> AsI32 for &'a T {
            fn as_i32(self) -> i32 {
                (*self).as_i32()
            }
        }
        impl AsI32 for i32 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for u32 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for i16 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for u16 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for i8 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for u8 {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for char {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        impl AsI32 for usize {
            #[inline]
            fn as_i32(self) -> i32 {
                self as i32
            }
        }
        pub fn as_f64<T: AsF64>(t: T) -> f64 {
            t.as_f64()
        }
        pub trait AsF64 {
            fn as_f64(self) -> f64;
        }
        impl<'a, T: Copy + AsF64> AsF64 for &'a T {
            fn as_f64(self) -> f64 {
                (*self).as_f64()
            }
        }
        impl AsF64 for f64 {
            #[inline]
            fn as_f64(self) -> f64 {
                self as f64
            }
        }
        pub unsafe fn invalid_enum_discriminant<T>() -> T {
            if true {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid enum discriminant"),
                    );
                }
            } else {
                unsafe { core::hint::unreachable_unchecked() }
            }
        }
        extern crate alloc as alloc_crate;
    }
    #[inline(never)]
    #[doc(hidden)]
    pub fn __link_custom_section_describing_imports() {
        wit_bindgen::rt::maybe_link_cabi_realloc();
    }
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import streams;\n\n    @since(version = 0.2.0)\n    import poll;\n}\n";
    const _: &[u8] = b"interface types {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n\n    /// A key-value pair describing an attribute.\n    record key-value {\n        /// The attribute name.\n        key: key,\n        /// The attribute value.\n        value: value,\n    }\n\n    /// The key part of attribute `key-value` pairs.\n    type key = string;\n\n    /// The value part of attribute `key-value` pairs.\n    variant value {\n        /// A string value.\n        %string(string),\n        /// A boolean value.\n        %bool(bool),\n        /// A double precision floating point value.\n        %f64(f64),\n        /// A signed 64 bit integer value.\n        %s64(s64),\n        /// A homogeneous array of string values.\n        string-array(list<string>),\n        /// A homogeneous array of boolean values.\n        bool-array(list<bool>),\n        /// A homogeneous array of double precision floating point values.\n        f64-array(list<f64>),\n        /// A homogeneous array of 64 bit integer values.\n        s64-array(list<s64>),\n    }\n\n    /// The host resource describing the entity producing telemetry.\n    record %resource {\n        /// Specifies the resource attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n    }\n\n    /// Describes the instrumentation scope that produced a span.\n    record instrumentation-scope {\n        /// Name of the instrumentation scope.\n        name: string,\n\n        /// The library version.\n        version: option<string>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n\n        /// Specifies the instrumentation scope attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n    }\n\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// Shutdown has already been invoked.\n        already-shutdown,\n\n        /// Operation timed out before completing.\n        timeout(u64),\n\n        /// Operation failed due to an internal error.\n        internal-failure(string)\n    }\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides atomic operations.\n/// \n/// Atomic operations are single, indivisible operations. When a fault causes an atomic operation to\n/// fail, it will appear to the invoker of the atomic operation that the action either completed\n/// successfully or did nothing at all.\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface atomics {\n  \tuse store.{bucket, error};\n\n\t/// The error returned by a CAS operation\n\tvariant cas-error {\n\t\t/// A store error occurred when performing the operation\n\t\tstore-error(error),\n\t\t/// The CAS operation failed because the value was too old. This returns a new CAS handle\n\t\t/// for easy retries. Implementors MUST return a CAS handle that has been updated to the\n\t\t/// latest version or transaction.\n\t\tcas-failed(cas),\n\t}\n\n\t/// A handle to a CAS (compare-and-swap) operation.\n\tresource cas {\n\t\t/// Construct a new CAS operation. Implementors can map the underlying functionality\n\t\t/// (transactions, versions, etc) as desired.\n\t\tnew: static func(bucket: borrow<bucket>, key: string) -> result<cas, error>;\n\t\t/// Get the current value of the key (if it exists). This allows for avoiding reads if all\n\t\t/// that is needed to ensure the atomicity of the operation\n\t\tcurrent: func() -> result<option<list<u8>>, error>;\n\t}\n\n  \t/// Atomically increment the value associated with the key in the store by the given delta. It\n\t/// returns the new value.\n\t///\n\t/// If the key does not exist in the store, it creates a new key-value pair with the value set\n\t/// to the given delta. \n\t///\n\t/// If any other error occurs, it returns an `Err(error)`.\n\tincrement: func(bucket: borrow<bucket>, key: string, delta: s64) -> result<s64, error>;\n\n\t/// Perform the swap on a CAS operation. This consumes the CAS handle and returns an error if\n\t/// the CAS operation failed.\n\tswap: func(cas: cas, value: list<u8>) -> result<_, cas-error>;\n}";
    const _: &[u8] = b"/// The request-reply interface allows a guest to send a message and await a response. This\n/// interface is considered optional as not all message services support the concept of\n/// request/reply. However, request/reply is a very common pattern in messaging and as such, we have\n/// included it as a core interface.\ninterface request-reply {\n    use types.{client, message, error, topic};\n\n    /// Options for a request/reply operation. This is a resource to allow for future expansion of\n    /// options.\n    resource request-options {\n        /// Creates a new request options resource with no options set.\n        constructor();\n\n        /// The maximum amount of time to wait for a response. If the timeout value is not set, then\n        /// the request/reply operation will block until a message is received in response.\n        set-timeout-ms: func(timeout-ms: u32);\n\n        /// The maximum number of replies to expect before returning.\n        set-expected-replies: func(expected-replies: u32);\n    }\n\n    /// Performs a blocking request/reply operation with an optional set of request options. \n    /// \n    /// The behavior of this function is largely dependent on the options given to the function.\n    /// If no options are provided, then the request/reply operation will block until a single \n    /// message is received in response. If a timeout is provided, then the request/reply operation\n    /// will block for the specified amount of time before returning an error if no messages were\n    /// received (or the list of messages that were received). If both a timeout and an expected\n    /// number of replies are provided, the function should return when either condition is met\n    /// (whichever comes first)\xe2\x80\x94e.g., (1) if no replies were received within the timeout return an\n    /// error, (2) if the maximum expected number of replies were received before timeout, return\n    /// the list of messages, or (3) if the timeout is reached before the expected number of replies,\n    /// return the list of messages received up to that point.\n    request: func(c: borrow<client>, topic: topic, message: borrow<message>, options: option<request-options>) -> result<list<message>, error>;\n\n    /// Replies to the given message with the given response message. The details of which topic\n    /// the message is sent to is up to the implementation. This allows for reply-to details to be\n    /// handled in the best way possible for the underlying messaging system.\n    /// \n    /// Please note that this reply functionality is different than something like HTTP because there\n    /// are several use cases in which a reply might not be required for every message (so this would\n    /// be a noop). There are also cases when you might want to reply and then continue processing.\n    /// Additionally, you might want to reply to a message several times (such as providing an\n    /// update). So this function is allowed to be called multiple times, unlike something like HTTP\n    /// where the reply is sent and the connection is closed.\n    reply: func(reply-to: borrow<message>, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"package wasi:sql@0.2.0-draft;\n\nworld imports {\n\timport readwrite;\n}";
    const _: &[u8] = b"package wasi:otel@0.2.0-draft;\n\nworld imports {\n    import tracing;\n    import metrics;\n    import %resource;\n}\n";
    const _: &[u8] = b"package wasi:messaging@0.2.0-draft;\n\n/// The `imports` world defines the interfaces that the component will import from the host.\n/// It includes the `producer` interface for sending messages.\nworld imports {\n  import producer;\n}\n\n/// The `imports-request-reply` world extends `imports` by including the `request-reply` interface.\n/// This allows the component to perform request/reply messaging patterns.\nworld imports-request-reply {\n  include imports;\n  import request-reply;\n}\n\n/// The `messaging-request-reply` world combines `imports-request-reply` with the `incoming-handler`\n/// export. This setup allows the host to interact with the component for both sending messages and\n/// handling incoming messages with request/reply capabilities.\nworld messaging-request-reply {\n  include imports-request-reply;\n  export incoming-handler;\n}\n\n/// The `messaging-core` world includes the basic `imports` and exports the `incoming-handler`,\n/// enabling the component to handle incoming messages without request/reply capabilities.\nworld messaging-core {\n  include imports;\n  export incoming-handler;\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// WASI I/O is an I/O abstraction API which is currently focused on providing\n/// stream types.\n///\n/// In the future, the component model is expected to add built-in stream types;\n/// when it does, they are expected to subsume this API.\n@since(version = 0.2.0)\ninterface streams {\n    @since(version = 0.2.0)\n    use error.{error};\n    @since(version = 0.2.0)\n    use poll.{pollable};\n\n    /// An error for input-stream and output-stream operations.\n    @since(version = 0.2.0)\n    variant stream-error {\n        /// The last operation (a write or flush) failed before completion.\n        ///\n        /// More information is available in the `error` payload.\n        ///\n        /// After this, the stream will be closed. All future operations return\n        /// `stream-error::closed`.\n        last-operation-failed(error),\n        /// The stream is closed: no more input will be accepted by the\n        /// stream. A closed output-stream will return this error on all\n        /// future operations.\n        closed\n    }\n\n    /// An input bytestream.\n    ///\n    /// `input-stream`s are *non-blocking* to the extent practical on underlying\n    /// platforms. I/O operations always return promptly; if fewer bytes are\n    /// promptly available than requested, they return the number of bytes promptly\n    /// available, which could even be zero. To wait for data to be available,\n    /// use the `subscribe` function to obtain a `pollable` which can be polled\n    /// for using `wasi:io/poll`.\n    @since(version = 0.2.0)\n    resource input-stream {\n        /// Perform a non-blocking read from the stream.\n        ///\n        /// When the source of a `read` is binary data, the bytes from the source\n        /// are returned verbatim. When the source of a `read` is known to the\n        /// implementation to be text, bytes containing the UTF-8 encoding of the\n        /// text are returned.\n        ///\n        /// This function returns a list of bytes containing the read data,\n        /// when successful. The returned list will contain up to `len` bytes;\n        /// it may return fewer than requested, but not more. The list is\n        /// empty when no bytes are available for reading at this time. The\n        /// pollable given by `subscribe` will be ready when more bytes are\n        /// available.\n        ///\n        /// This function fails with a `stream-error` when the operation\n        /// encounters an error, giving `last-operation-failed`, or when the\n        /// stream is closed, giving `closed`.\n        ///\n        /// When the caller gives a `len` of 0, it represents a request to\n        /// read 0 bytes. If the stream is still open, this call should\n        /// succeed and return an empty list, or otherwise fail with `closed`.\n        ///\n        /// The `len` parameter is a `u64`, which could represent a list of u8 which\n        /// is not possible to allocate in wasm32, or not desirable to allocate as\n        /// as a return value by the callee. The callee may return a list of bytes\n        /// less than `len` in size while more bytes are available for reading.\n        @since(version = 0.2.0)\n        read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Read bytes from a stream, after blocking until at least one byte can\n        /// be read. Except for blocking, behavior is identical to `read`.\n        @since(version = 0.2.0)\n        blocking-read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Skip bytes from a stream. Returns number of bytes skipped.\n        ///\n        /// Behaves identical to `read`, except instead of returning a list\n        /// of bytes, returns the number of bytes consumed from the stream.\n        @since(version = 0.2.0)\n        skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Skip bytes from a stream, after blocking until at least one byte\n        /// can be skipped. Except for blocking behavior, identical to `skip`.\n        @since(version = 0.2.0)\n        blocking-skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Create a `pollable` which will resolve once either the specified stream\n        /// has bytes available to read or the other end of the stream has been\n        /// closed.\n        /// The created `pollable` is a child resource of the `input-stream`.\n        /// Implementations may trap if the `input-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n    }\n\n\n    /// An output bytestream.\n    ///\n    /// `output-stream`s are *non-blocking* to the extent practical on\n    /// underlying platforms. Except where specified otherwise, I/O operations also\n    /// always return promptly, after the number of bytes that can be written\n    /// promptly, which could even be zero. To wait for the stream to be ready to\n    /// accept data, the `subscribe` function to obtain a `pollable` which can be\n    /// polled for using `wasi:io/poll`.\n    ///\n    /// Dropping an `output-stream` while there\'s still an active write in\n    /// progress may result in the data being lost. Before dropping the stream,\n    /// be sure to fully flush your writes.\n    @since(version = 0.2.0)\n    resource output-stream {\n        /// Check readiness for writing. This function never blocks.\n        ///\n        /// Returns the number of bytes permitted for the next call to `write`,\n        /// or an error. Calling `write` with more bytes than this function has\n        /// permitted will trap.\n        ///\n        /// When this function returns 0 bytes, the `subscribe` pollable will\n        /// become ready when this function will report at least 1 byte, or an\n        /// error.\n        @since(version = 0.2.0)\n        check-write: func() -> result<u64, stream-error>;\n\n        /// Perform a write. This function never blocks.\n        ///\n        /// When the destination of a `write` is binary data, the bytes from\n        /// `contents` are written verbatim. When the destination of a `write` is\n        /// known to the implementation to be text, the bytes of `contents` are\n        /// transcoded from UTF-8 into the encoding of the destination and then\n        /// written.\n        ///\n        /// Precondition: check-write gave permit of Ok(n) and contents has a\n        /// length of less than or equal to n. Otherwise, this function will trap.\n        ///\n        /// returns Err(closed) without writing if the stream has closed since\n        /// the last call to check-write provided a permit.\n        @since(version = 0.2.0)\n        write: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 bytes, and then flush the stream. Block\n        /// until all of these operations are complete, or an error occurs.\n        ///\n        /// Returns success when all of the contents written are successfully\n        /// flushed to output. If an error occurs at any point before all\n        /// contents are successfully flushed, that error is returned as soon as\n        /// possible. If writing and flushing the complete contents causes the\n        /// stream to become closed, this call should return success, and\n        /// subsequent calls to check-write or other interfaces should return\n        /// stream-error::closed.\n        @since(version = 0.2.0)\n        blocking-write-and-flush: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Request to flush buffered output. This function never blocks.\n        ///\n        /// This tells the output-stream that the caller intends any buffered\n        /// output to be flushed. the output which is expected to be flushed\n        /// is all that has been passed to `write` prior to this call.\n        ///\n        /// Upon calling this function, the `output-stream` will not accept any\n        /// writes (`check-write` will return `ok(0)`) until the flush has\n        /// completed. The `subscribe` pollable will become ready when the\n        /// flush has completed and the stream can accept more writes.\n        @since(version = 0.2.0)\n        flush: func() -> result<_, stream-error>;\n\n        /// Request to flush buffered output, and block until flush completes\n        /// and stream is ready for writing again.\n        @since(version = 0.2.0)\n        blocking-flush: func() -> result<_, stream-error>;\n\n        /// Create a `pollable` which will resolve once the output-stream\n        /// is ready for more writing, or an error has occurred. When this\n        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an\n        /// error.\n        ///\n        /// If the stream is closed, this pollable is always ready immediately.\n        ///\n        /// The created `pollable` is a child resource of the `output-stream`.\n        /// Implementations may trap if the `output-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n\n        /// Write zeroes to a stream.\n        ///\n        /// This should be used precisely like `write` with the exact same\n        /// preconditions (must use check-write first), but instead of\n        /// passing a list of bytes, you simply pass the number of zero-bytes\n        /// that should be written.\n        @since(version = 0.2.0)\n        write-zeroes: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 zeroes, and then flush the stream.\n        /// Block until all of these operations are complete, or an error\n        /// occurs.\n        ///\n        /// Functionality is equivelant to `blocking-write-and-flush` with\n        /// contents given as a list of len containing only zeroes.\n        @since(version = 0.2.0)\n        blocking-write-zeroes-and-flush: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Read from one stream and write to another.\n        ///\n        /// The behavior of splice is equivalent to:\n        /// 1. calling `check-write` on the `output-stream`\n        /// 2. calling `read` on the `input-stream` with the smaller of the\n        /// `check-write` permitted length and the `len` provided to `splice`\n        /// 3. calling `write` on the `output-stream` with that read data.\n        ///\n        /// Any error reported by the call to `check-write`, `read`, or\n        /// `write` ends the splice and reports that error.\n        ///\n        /// This function returns the number of bytes transferred; it may be less\n        /// than `len`.\n        @since(version = 0.2.0)\n        splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Read from one stream and write to another, with blocking.\n        ///\n        /// This is similar to `splice`, except that it blocks until the\n        /// `output-stream` is ready for writing, and the `input-stream`\n        /// is ready for reading, before performing the `splice`.\n        @since(version = 0.2.0)\n        blocking-splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n    }\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Monotonic Clock is a clock API intended to let users measure elapsed\n/// time.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A monotonic clock is a clock which has an unspecified initial value, and\n/// successive reads of the clock will produce non-decreasing values.\n@since(version = 0.2.0)\ninterface monotonic-clock {\n    @since(version = 0.2.0)\n    use wasi:io/poll@0.2.6.{pollable};\n\n    /// An instant in time, in nanoseconds. An instant is relative to an\n    /// unspecified initial value, and can only be compared to instances from\n    /// the same monotonic-clock.\n    @since(version = 0.2.0)\n    type instant = u64;\n\n    /// A duration of time, in nanoseconds.\n    @since(version = 0.2.0)\n    type duration = u64;\n\n    /// Read the current value of the clock.\n    ///\n    /// The clock is monotonic, therefore calling this function repeatedly will\n    /// produce a sequence of non-decreasing values.\n    @since(version = 0.2.0)\n    now: func() -> instant;\n\n    /// Query the resolution of the clock. Returns the duration of time\n    /// corresponding to a clock tick.\n    @since(version = 0.2.0)\n    resolution: func() -> duration;\n\n    /// Create a `pollable` which will resolve once the specified instant\n    /// has occurred.\n    @since(version = 0.2.0)\n    subscribe-instant: func(\n        when: instant,\n    ) -> pollable;\n\n    /// Create a `pollable` that will resolve after the specified duration has\n    /// elapsed from the time this function is invoked.\n    @since(version = 0.2.0)\n    subscribe-duration: func(\n        when: duration,\n    ) -> pollable;\n}\n";
    const _: &[u8] = b"interface types {\n    /// A type alias for list<tuple<string, string>> to represent metadata attached to a message\n    type metadata = list<tuple<string, string>>;\n\n    /// A type alias for string to represent a message topic\n    type topic = string;\n\n    /// A connection to a message-exchange service (e.g., buffer, broker, etc.).\n    resource client {\n        connect: static func(name: string) -> result<client, error>;\n        disconnect: func() -> result<_, error>;\n    }\n\n    /// Errors that can occur when using the messaging interface.\n    variant error {\n        /// The request or operation timed out.\n        timeout,\n        /// An error occurred with the connection. Includes a message for additional context\n        connection(string),\n        /// A permission error occurred. Includes a message for additional context\n        permission-denied(string),\n        /// A catch all for other types of errors\n        other(string),\n    }\n\n    /// A message with a binary payload and additional information\n    resource message {\n        constructor(data: list<u8>);\n        // new: static func(data: stream<u8>) -> message;\n\n        /// The topic/subject/channel this message was received on, if any\n        topic: func() -> option<topic>;\n        /// An optional content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        content-type: func() -> option<string>;\n        /// Set the content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        set-content-type: func(content-type: string);\n        /// An opaque blob of data\n        data: func() -> list<u8>;\n        /// Set the opaque blob of data for this message, discarding the old value\n        set-data: func(data: list<u8>);\n        /// Optional metadata (also called headers or attributes in some systems) attached to the\n        /// message. This metadata is simply decoration and should not be interpreted by a host\n        /// to ensure portability across different implementors (e.g., Kafka -> NATS, etc.).\n        metadata: func() -> option<metadata>;\n        /// Add a new key-value pair to the metadata, overwriting any existing value for the same key\n        add-metadata: func(key: string, value: string);\n        /// Set the metadata\n        set-metadata: func(meta: metadata);\n        /// Remove a key-value pair from the metadata\n        remove-metadata: func(key: string);\n    }\n}\n";
    const _: &[u8] = b"package wasi:blobstore@0.2.0-draft;\n\nworld imports {\n\timport blobstore;\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import monotonic-clock;\n    @since(version = 0.2.0)\n    import wall-clock;\n    @unstable(feature = clocks-timezone)\n    import timezone;\n}\n";
    const _: &[u8] = b"interface tracing {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, error};\n\n    /// Returns the current span context of the host.\n    context: func() -> span-context;\n\n    /// Called by the guest to export spans.\n    %export: func(span: list<span-data>) -> result<_, error>;\n\n    /// The data associated with a span.\n    record span-data {\n        /// Span context.\n        span-context: span-context,\n        /// Span parent id.\n        parent-span-id: string,\n        /// Span kind.\n        span-kind: span-kind,\n        // Span name.\n        name: string,\n        /// Span start time.\n        start-time: datetime,\n        /// Span end time.\n        end-time: datetime,\n        /// Span attributes.\n        attributes: list<key-value>,\n        /// Span events.\n        events: list<event>,\n        /// Span Links.\n        links: list<link>,\n        /// Span status.\n        status: status,\n        /// Instrumentation scope that produced this span.\n        instrumentation-scope: instrumentation-scope,\n        /// Number of attributes dropped by the span due to limits being reached.\n        dropped-attributes: u32,\n        /// Number of events dropped by the span due to limits being reached.\n        dropped-events: u32,\n        /// Number of links dropped by the span due to limits being reached.\n        dropped-links: u32,\n    }\n\n    /// Identifying trace information about a span that can be serialized and propagated.\n    record span-context {\n        /// The `trace-id` for this `span-context`.\n        trace-id: trace-id,\n        /// The `span-id` for this `span-context`.\n        span-id: span-id,\n        /// The `trace-flags` for this `span-context`.\n        trace-flags: trace-flags,\n        /// Whether this `span-context` was propagated from a remote parent.\n        is-remote: bool,\n        /// The `trace-state` for this `span-context`.\n        trace-state: trace-state,\n    }\n\n    /// The trace that this `span-context` belongs to.\n    ///\n    /// 16 bytes encoded as a hexadecimal string.\n    type trace-id = string;\n\n    /// The id of this `span-context`.\n    ///\n    /// 8 bytes encoded as a hexadecimal string.\n    type span-id = string;\n\n    /// Flags that can be set on a `span-context`.\n    flags trace-flags {\n        /// Whether the `span` should be sampled or not.\n        sampled,\n    }\n\n    /// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.\n    ///\n    /// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.\n    type trace-state = list<tuple<string, string>>;\n\n    /// Describes the relationship between the Span, its parents, and its children in a trace.\n    enum span-kind {\n        /// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.\n        client,\n        /// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.\n        server,\n        /// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.\n        producer,\n        /// Indicates that the span describes a child of an asynchronous consumer request.\n        consumer,\n        /// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.\n        internal\n    }\n\n    /// An event describing a specific moment in time on a span and associated attributes.\n    record event {\n        /// Event name.\n        name: string,\n        /// Event time.\n        time: datetime,\n        /// Event attributes.\n        attributes: list<key-value>,\n    }\n\n    /// Describes a relationship to another `span`.\n    record link {\n        /// Denotes which `span` to link to.\n        span-context: span-context,\n        /// Attributes describing the link.\n        attributes: list<key-value>,\n    }\n\n    /// The `status` of a `span`.\n    variant status {\n        /// The default status.\n        unset,\n        /// The operation has been validated by an Application developer or Operator to have completed successfully.\n        ok,\n        /// The operation contains an error with a description.\n        error(string),\n    }\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// A poll API intended to let users wait for I/O events on multiple handles\n/// at once.\n@since(version = 0.2.0)\ninterface poll {\n    /// `pollable` represents a single I/O event which may be ready, or not.\n    @since(version = 0.2.0)\n    resource pollable {\n\n        /// Return the readiness of a pollable. This function never blocks.\n        ///\n        /// Returns `true` when the pollable is ready, and `false` otherwise.\n        @since(version = 0.2.0)\n        ready: func() -> bool;\n\n        /// `block` returns immediately if the pollable is ready, and otherwise\n        /// blocks until ready.\n        ///\n        /// This function is equivalent to calling `poll.poll` on a list\n        /// containing only this pollable.\n        @since(version = 0.2.0)\n        block: func();\n    }\n\n    /// Poll for completion on a set of pollables.\n    ///\n    /// This function takes a list of pollables, which identify I/O sources of\n    /// interest, and waits until one or more of the events is ready for I/O.\n    ///\n    /// The result `list<u32>` contains one or more indices of handles in the\n    /// argument list that is ready for I/O.\n    ///\n    /// This function traps if either:\n    /// - the list is empty, or:\n    /// - the list contains more elements than can be indexed with a `u32` value.\n    ///\n    /// A timeout can be implemented by adding a pollable from the\n    /// wasi-clocks API to the list.\n    ///\n    /// This function does not return a `result`; polling in itself does not\n    /// do any I/O so it doesn\'t fail. If any of the I/O sources identified by\n    /// the pollables has an error, it is indicated by marking the source as\n    /// being ready for I/O.\n    @since(version = 0.2.0)\n    poll: func(in: list<borrow<pollable>>) -> list<u32>;\n}\n";
    const _: &[u8] = b"interface metrics {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, %resource, error};\n\n    /// Gathers and returns all metric data related to the [MetricReader] from the\n    /// SDK and stores it in the provided [ResourceMetrics] reference.\n    ///\n    /// An error is returned if this is called after shutdown.\n    %export: func(rm: resource-metrics) -> result<_, error>;\n\n    /// A collection of scope metrics and the associated resource that created them.\n    record resource-metrics {\n        /// The entity that collected the metrics.\n        %resource: %resource,\n\n        /// The collection of metrics with unique [InstrumentationScope]s.\n        scope-metrics: list<scope-metrics>,\n    }\n\n    record scope-metrics {\n        /// The instrumentation scope that the meter was created with.\n        scope: instrumentation-scope,\n\n        /// The list of aggregations created by the meter.\n        metrics: list<metric>,\n    }\n\n    /// A collection of one or more aggregated time series from an [Instrument].\n    ///\n    /// [Instrument]: crate::metrics::Instrument\n    record metric {\n        /// The name of the instrument that created this data.\n        name: string,\n\n        /// The description of the instrument, which can be used in documentation.\n        description: string,\n\n        /// The unit in which the instrument reports.\n        unit: string,\n\n        /// The aggregated data from an instrument.\n        data: aggregated-metrics,\n    }\n\n    /// Aggregated metrics data from an instrument\n    variant aggregated-metrics {\n        /// All metric data with `f64` value type\n        %f64(metric-data),\n\n        /// All metric data with `u64` value type\n        %u64(metric-data),\n\n        /// All metric data with `i64` value type\n        %s64(metric-data),\n    }\n\n    /// Metric data for all types\n    variant metric-data {\n        /// Metric data for Gauge\n        gauge(gauge),\n\n        /// Metric data for Sum\n        sum(sum),\n\n        /// Metric data for Histogram\n        histogram(histogram),\n\n        /// Metric data for ExponentialHistogram\n        exponential-histogram(exponential-histogram),\n    }\n\n    /// A measurement of the current value of an instrument.\n    record gauge {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<gauge-data-point>,\n\n        /// The time when the time series was started.\n        start-time: option<datetime>,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record gauge-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the sum of all measurements of values from an instrument.\n    record sum {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<sum-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n\n        /// Whether this aggregation only increases or decreases.\n        is-monotonic: bool,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record sum-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the histogram of all measurements of values from an instrument.\n    record histogram {\n        /// Individual aggregated measurements with unique attributes.\n        data-points: list<histogram-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single histogram data point in a time series.\n    record histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The upper bounds of the buckets of the histogram.\n        ///\n        /// Because the last boundary is +infinity this one is implied.\n        bounds: list<f64>,\n\n        /// The count of each of the buckets.\n        bucket-counts: list<u64>,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// The histogram of all measurements of values from an instrument.\n    record exponential-histogram {\n        /// The individual aggregated measurements with unique attributes.\n        data-points: list<exponential-histogram-data-point>,\n\n        /// When the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single exponential histogram data point in a time series.\n    record exponential-histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// Describes the resolution of the histogram.\n        ///\n        /// Boundaries are located at powers of the base, where:\n        ///\n        ///   base = 2 ^ (2 ^ -scale)\n        scale: s8,\n\n        /// The number of values whose absolute value is less than or equal to\n        /// `zero_threshold`.\n        ///\n        /// When `zero_threshold` is `0`, this is the number of values that cannot be\n        /// expressed using the standard exponential formula as well as values that have\n        /// been rounded to zero.\n        zero-count: u64,\n\n        /// The range of positive value bucket counts.\n        positive-bucket: exponential-bucket,\n\n        /// The range of negative value bucket counts.\n        negative-bucket: exponential-bucket,\n\n        /// The width of the zero region.\n        ///\n        /// Where the zero region is defined as the closed interval\n        /// [-zero_threshold, zero_threshold].\n        zero-threshold: f64,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// A set of bucket counts, encoded in a contiguous array of counts.\n    record exponential-bucket {\n        /// The bucket index of the first entry in the `counts` vec.\n        offset: s32,\n\n        /// A vec where `counts[i]` carries the count of the bucket at index `offset + i`.\n        ///\n        /// `counts[i]` is the count of values greater than base^(offset+i) and less than\n        /// or equal to base^(offset+i+1).\n        counts: list<u64>,\n    }\n\n    /// Defines the window that an aggregation was calculated over.\n    enum temporality {\n        /// A measurement interval that continues to expand forward in time from a\n        /// starting point.\n        ///\n        /// New measurements are added to all previous measurements since a start time.\n        cumulative,\n\n        /// A measurement interval that resets each cycle.\n        ///\n        /// Measurements from one cycle are recorded independently, measurements from\n        /// other cycles do not affect them.\n        delta,\n\n        /// Configures Synchronous Counter and Histogram instruments to use\n        /// Delta aggregation temporality, which allows them to shed memory\n        /// following a cardinality explosion, thus use less memory.\n        low-memory,\n    }\n\n    /// A measurement sampled from a time series providing a typical example.\n    record exemplar {\n        /// The attributes recorded with the measurement but filtered out of the\n        /// time series\' aggregated data.\n        filtered-attributes: list<key-value>,\n\n        /// The time when the measurement was recorded.\n        time: datetime,\n\n        /// The measured value.\n        value: data-value,\n\n        /// The ID of the span that was active during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        span-id: string,\n\n        /// The ID of the trace the active span belonged to during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        trace-id: string,\n    }\n\n    variant data-value {\n        /// All metric data with `f64` value type\n        %f64(f64),\n\n        /// All metric data with `u64` value type\n        %u64(u64),\n\n        /// All metric data with `s64` value type\n        %s64(s64),\n    }\n\n\n    /// The identifier of a group of instruments that all perform the same function.\n    enum instrument-kind {\n        /// Identifies a group of instruments that record increasing values synchronously\n        /// with the code path they are measuring.\n        counter,\n\n        /// A group of instruments that record increasing and decreasing values\n        /// synchronously with the code path they are measuring.\n        up-down-counter,\n\n        /// A group of instruments that record a distribution of values synchronously with\n        /// the code path they are measuring.\n        histogram,\n\n        /// A group of instruments that record increasing values in an asynchronous\n        /// callback.\n        observable-counter,\n\n        /// A group of instruments that record increasing and decreasing values in an\n        /// asynchronous callback.\n        observable-up-down-counter,\n\n        /// a group of instruments that record current value synchronously with\n        /// the code path they are measuring.\n        gauge,\n\n        /// a group of instruments that record current values in an asynchronous callback.\n        observable-gauge,\n    }\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides eventually consistent key-value operations.\n/// \n/// Each of these operations acts on a single key-value pair.\n/// \n/// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is\n/// the common denominator for all data types defined by different key-value stores to handle data,\n/// ensuring compatibility between different key-value stores. Note: the clients will be expecting\n/// serialization/deserialization overhead to be handled by the key-value store. The value could be\n/// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.\n/// \n/// Data consistency in a key value store refers to the guarantee that once a write operation\n/// completes, all subsequent read operations will return the value that was written.\n/// \n/// Any implementation of this interface must have enough consistency to guarantee \"reading your\n/// writes.\" In particular, this means that the client should never get a value that is older than\n/// the one it wrote, but it MAY get a newer value if one was written around the same time. These\n/// guarantees only apply to the same client (which will likely be provided by the host or an\n/// external capability of some kind). In this context a \"client\" is referring to the caller or\n/// guest that is consuming this interface. Once a write request is committed by a specific client,\n/// all subsequent read requests by the same client will reflect that write or any subsequent\n/// writes. Another client running in a different context may or may not immediately see the result\n/// due to the replication lag. As an example of all of this, if a value at a given key is A, and\n/// the client writes B, then immediately reads, it should get B. If something else writes C in\n/// quick succession, then the client may get C. However, a client running in a separate context may\n/// still see A or B\ninterface store {\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// A response to a `list-keys` operation.\n    record key-response {\n        /// The list of keys returned by the query.\n        keys: list<string>,\n        /// The continuation token to use to fetch the next page of keys. If this is `null`, then\n        /// there are no more keys to fetch.\n        cursor: option<string>\n    }\n\n    /// Get the bucket with the specified identifier.\n    ///\n    /// `identifier` must refer to a bucket provided by the host.\n    ///\n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(identifier: string) -> result<bucket, error>;\n\n    /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the\n    /// bucket, and the bucket itself acts as a collection of all these entries.\n    ///\n    /// It is worth noting that the exact terminology for bucket in key-value stores can very\n    /// depending on the specific implementation. For example:\n    ///\n    /// 1. Amazon DynamoDB calls a collection of key-value pairs a table\n    /// 2. Redis has hashes, sets, and sorted sets as different types of collections\n    /// 3. Cassandra calls a collection of key-value pairs a column family\n    /// 4. MongoDB calls a collection of key-value pairs a collection\n    /// 5. Riak calls a collection of key-value pairs a bucket\n    /// 6. Memcached calls a collection of key-value pairs a slab\n    /// 7. Azure Cosmos DB calls a collection of key-value pairs a container\n    ///\n    /// In this interface, we use the term `bucket` to refer to a collection of key-value pairs\n    resource bucket {\n        /// Get the value associated with the specified `key`\n        ///\n        /// The value is returned as an option. If the key-value pair exists in the\n        /// store, it returns `Ok(value)`. If the key does not exist in the\n        /// store, it returns `Ok(none)`. \n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        get: func(key: string) -> result<option<list<u8>>, error>;\n\n        /// Set the value associated with the key in the store. If the key already\n        /// exists in the store, it overwrites the value.\n        ///\n        /// If the key does not exist in the store, it creates a new key-value pair.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        set: func(key: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the key-value pair associated with the key in the store.\n        /// \n        /// If the key does not exist in the store, it does nothing.\n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        delete: func(key: string) -> result<_, error>;\n\n        /// Check if the key exists in the store.\n        /// \n        /// If the key exists in the store, it returns `Ok(true)`. If the key does\n        /// not exist in the store, it returns `Ok(false)`.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        exists: func(key: string) -> result<bool, error>;\n\n        /// Get all the keys in the store with an optional cursor (for use in pagination). It\n        /// returns a list of keys. Please note that for most KeyValue implementations, this is a\n        /// can be a very expensive operation and so it should be used judiciously. Implementations\n        /// can return any number of keys in a single response, but they should never attempt to\n        /// send more data than is reasonable (i.e. on a small edge device, this may only be a few\n        /// KB, while on a large machine this could be several MB). Any response should also return\n        /// a cursor that can be used to fetch the next page of keys. See the `key-response` record\n        /// for more information.\n        /// \n        /// Note that the keys are not guaranteed to be returned in any particular order.\n        /// \n        /// If the store is empty, it returns an empty list.\n        /// \n        /// MAY show an out-of-date list of keys if there are concurrent writes to the store.\n        /// \n        /// If any error occurs, it returns an `Err(error)`.\n        list-keys: func(cursor: option<string>) -> result<key-response, error>;\n    }\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\ninterface error {\n    /// A resource which represents some error information.\n    ///\n    /// The only method provided by this resource is `to-debug-string`,\n    /// which provides some human-readable information about the error.\n    ///\n    /// In the `wasi:io` package, this resource is returned through the\n    /// `wasi:io/streams/stream-error` type.\n    ///\n    /// To provide more specific error information, other interfaces may\n    /// offer functions to \"downcast\" this error into more specific types. For example,\n    /// errors returned from streams derived from filesystem types can be described using\n    /// the filesystem\'s own error-code type. This is done using the function\n    /// `wasi:filesystem/types/filesystem-error-code`, which takes a `borrow<error>`\n    /// parameter and returns an `option<wasi:filesystem/types/error-code>`.\n    ///\n    /// The set of functions which can \"downcast\" an `error` into a more\n    /// concrete type is open.\n    @since(version = 0.2.0)\n    resource error {\n        /// Returns a string that is suitable to assist humans in debugging\n        /// this error.\n        ///\n        /// WARNING: The returned string should not be consumed mechanically!\n        /// It may change across platforms, hosts, or other implementation\n        /// details. Parsing this string is a major platform-compatibility\n        /// hazard.\n        @since(version = 0.2.0)\n        to-debug-string: func() -> string;\n    }\n}\n";
    const _: &[u8] = b"// a Container is a collection of objects\ninterface container {\n  use wasi:io/streams@0.2.6.{\n    input-stream,\n    output-stream,\n  };\n\n  use types.{\n    container-metadata,\n    error,\n    incoming-value,\n    object-metadata,\n    object-name,\n    outgoing-value,\n  };\n\n  // this defines the `container` resource\n  resource container {\n    // returns container name\n    name: func() -> result<string, error>;\n\n    // returns container metadata\n    info: func() -> result<container-metadata, error>;\n\n    // retrieves an object or portion of an object, as a resource.\n    // Start and end offsets are inclusive.\n    // Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime\n    // of the data-blob resource, even if the object they came from is later deleted.\n    get-data: func(name: object-name, start: u64, end: u64) -> result<incoming-value, error>;\n\n    // creates or replaces an object with the data blob.\n    write-data: func(name: object-name, data: borrow<outgoing-value>) -> result<_, error>;\n\n    // returns list of objects in the container. Order is undefined.\n    list-objects: func() -> result<stream-object-names, error>;\n\n    // deletes object.\n    // does not return error if object did not exist.\n    delete-object: func(name: object-name) -> result<_, error>;\n\n    // deletes multiple objects in the container\n    delete-objects: func(names: list<object-name>) -> result<_, error>;\n\n    // returns true if the object exists in this container\n    has-object: func(name: object-name) -> result<bool, error>;\n\n    // returns metadata for the object\n    object-info: func(name: object-name) -> result<object-metadata, error>;\n\n    // removes all objects within the container, leaving the container empty.\n    clear: func() -> result<_, error>;\n  }\n\n  // this defines the `stream-object-names` resource which is a representation of stream<object-name>\n  resource stream-object-names {\n    // reads the next number of objects from the stream\n    //\n    // This function returns the list of objects read, and a boolean indicating if the end of the stream was reached.\n    read-stream-object-names: func(len: u64) -> result<tuple<list<object-name>, bool>, error>;\n\n    // skip the next number of objects in the stream\n    //\n    // This function returns the number of objects skipped, and a boolean indicating if the end of the stream was reached.\n    skip-stream-object-names: func(num: u64) -> result<tuple<u64, bool>, error>;\n  }\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides watch operations.\n/// \n/// This interface is used to provide event-driven mechanisms to handle\n/// keyvalue changes.\ninterface watcher {\n\t/// A keyvalue interface that provides handle-watch operations.\n\tuse store.{bucket};\n\n\t/// Handle the `set` event for the given bucket and key. It includes a reference to the `bucket`\n\t/// that can be used to interact with the store.\n\ton-set: func(bucket: bucket, key: string, value: list<u8>);\n\n\t/// Handle the `delete` event for the given bucket and key. It includes a reference to the\n\t/// `bucket` that can be used to interact with the store.\n\ton-delete: func(bucket: bucket, key: string);\n}";
    const _: &[u8] = b"interface %resource {\n    use types.{key, value, key-value, %resource as telemetry-resource};\n\n    /// Returns the telemetry resource used by the host.\n    %resource: func() -> telemetry-resource;\n}\n";
    const _: &[u8] = b"// Types used by blobstore\ninterface types {\n  use wasi:io/streams@0.2.6.{input-stream, output-stream};\n\n  // name of a container, a collection of objects.\n  // The container name may be any valid UTF-8 string.\n  type container-name = string;\n\n  // name of an object within a container\n  // The object name may be any valid UTF-8 string.\n  type object-name = string;\n\n  // TODO: define timestamp to include seconds since\n  // Unix epoch and nanoseconds\n  // https://github.com/WebAssembly/wasi-blob-store/issues/7\n  type timestamp = u64;\n\n  // size of an object, in bytes\n  type object-size = u64;\n\n  type error = string;\n\n  // information about a container\n  record container-metadata {\n    // the container\'s name\n    name: container-name,\n    // date and time container was created\n    created-at: timestamp,\n  }\n\n  // information about an object\n  record object-metadata {\n    // the object\'s name\n    name: object-name,\n    // the object\'s parent container\n    container: container-name,\n    // date and time the object was created\n    created-at: timestamp,\n    // size of the object, in bytes\n    size: object-size,\n  }\n\n  // identifier for an object that includes its container name\n  record object-id {\n    container: container-name,\n    object: object-name\n  }\n\n  /// A data is the data stored in a data blob. The value can be of any type\n  /// that can be represented in a byte array. It provides a way to write the value\n  /// to the output-stream defined in the `wasi-io` interface.\n  // Soon: switch to `resource value { ... }`\n  resource outgoing-value {\n    new-outgoing-value: static func() -> outgoing-value;\n\n    /// Returns a stream for writing the value contents.\n    ///\n    /// The returned `output-stream` is a child resource: it must be dropped\n    /// before the parent `outgoing-value` resource is dropped (or finished),\n    /// otherwise the `outgoing-value` drop or `finish` will trap.\n    ///\n    /// Returns success on the first call: the `output-stream` resource for\n    /// this `outgoing-value` may be retrieved at most once. Subsequent calls\n    /// will return error.\n    outgoing-value-write-body: func() -> result<output-stream, error>;\n\n    /// Finalize an outgoing value. This must be\n    /// called to signal that the outgoing value is complete. If the `outgoing-value`\n    /// is dropped without calling `outgoing-value.finalize`, the implementation\n    /// should treat the value as corrupted.\n    finish: static func(this: outgoing-value) -> result<_, error>;\n  }\n\n  /// A incoming-value is a wrapper around a value. It provides a way to read the value\n  /// from the input-stream defined in the `wasi-io` interface.\n  ///\n  /// The incoming-value provides two ways to consume the value:\n  /// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the\n  ///    value as a list of bytes.\n  /// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the\n  ///    value as an input-stream.\n  // Soon: switch to `resource incoming-value { ... }`\n  resource incoming-value {\n      incoming-value-consume-sync: static func(this: incoming-value) -> result<incoming-value-sync-body, error>;\n      incoming-value-consume-async: static func(this: incoming-value) -> result<incoming-value-async-body, error>;\n      size: func() -> u64;\n  }\n\n  type incoming-value-async-body = input-stream;\n  type incoming-value-sync-body = list<u8>;\n}\n";
    const _: &[u8] = b"package wasmgrid:service;\n\nworld blobstore {\n\tinclude wasi:blobstore/imports@0.2.0-draft;\n}\n\nworld keyvalue {\n\tinclude wasi:keyvalue/watch-service@0.2.0-draft2;\n}\n\nworld messaging {\n\tinclude wasi:messaging/messaging-request-reply@0.2.0-draft;\n}\n\nworld otel {\n\tinclude wasi:otel/imports@0.2.0-draft;\n}\n\nworld sql {\n\tinclude wasi:sql/imports@0.2.0-draft;\n}\n\nworld vault {\n\tinclude wasi:vault/imports@0.1.0-draft;\n}";
    const _: &[u8] = b"interface incoming-handler {\n    use types.{message, error, topic};\n\n    /// Whenever this guest receives a message in one of the subscribed topics, the message is\n    /// sent to this handler. The guest is responsible for matching on the topic and handling the\n    /// message accordingly. Implementors (such as hosts) calling this interface should make their\n    /// own decisions on how to handle errors returned from this function.\n    handle: async func(message: message) -> result<_, error>;\n\n\n    /// Server configuration.\n    ///\n    /// This can be extended to include other configuration options in the\n    /// future.\n    record configuration {\n        /// Subscription topics\n        topics: list<topic>,\n    }\n\n    /// Configure is called by the runtime to get the server\'s runtime\n    /// configuration.\n    configure: async func() -> result<configuration, error>;\n\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@unstable(feature = clocks-timezone)\ninterface timezone {\n    @unstable(feature = clocks-timezone)\n    use wall-clock.{datetime};\n\n    /// Return information needed to display the given `datetime`. This includes\n    /// the UTC offset, the time zone name, and a flag indicating whether\n    /// daylight saving time is active.\n    ///\n    /// If the timezone cannot be determined for the given `datetime`, return a\n    /// `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight\n    /// saving time.\n    @unstable(feature = clocks-timezone)\n    display: func(when: datetime) -> timezone-display;\n\n    /// The same as `display`, but only return the UTC offset.\n    @unstable(feature = clocks-timezone)\n    utc-offset: func(when: datetime) -> s32;\n\n    /// Information useful for displaying the timezone of a specific `datetime`.\n    ///\n    /// This information may vary within a single `timezone` to reflect daylight\n    /// saving time adjustments.\n    @unstable(feature = clocks-timezone)\n    record timezone-display {\n        /// The number of seconds difference between UTC time and the local\n        /// time of the timezone.\n        ///\n        /// The returned value will always be less than 86400 which is the\n        /// number of seconds in a day (24*60*60).\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return 0.\n        utc-offset: s32,\n\n        /// The abbreviated name of the timezone to display to a user. The name\n        /// `UTC` indicates Coordinated Universal Time. Otherwise, this should\n        /// reference local standards for the name of the time zone.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should be the string `UTC`.\n        ///\n        /// In time zones that do not have an applicable name, a formatted\n        /// representation of the UTC offset may be returned, such as `-04:00`.\n        name: string,\n\n        /// Whether daylight saving time is active.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return false.\n        in-daylight-saving-time: bool,\n    }\n}\n";
    const _: &[u8] = b"package wasi:keyvalue@0.2.0-draft2;\n\n/// The `wasi:keyvalue/imports` world provides common APIs for interacting with key-value stores.\n/// Components targeting this world will be able to do:\n/// \n/// 1. CRUD (create, read, update, delete) operations on key-value stores.\n/// 2. Atomic `increment` and CAS (compare-and-swap) operations.\n/// 3. Batch operations that can reduce the number of round trips to the network.\nworld imports {\n\t/// The `store` capability allows the component to perform eventually consistent operations on\n\t/// the key-value store.\n\timport store;\n\n\t/// The `atomic` capability allows the component to perform atomic / `increment` and CAS\n\t/// (compare-and-swap) operations.\n\timport atomics;\n\n\t/// The `batch` capability allows the component to perform eventually consistent batch\n\t/// operations that can reduce the number of round trips to the network.\n\timport batch;\n}\n\nworld watch-service {\n\tinclude imports;\n\texport watcher;\n}";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Wall Clock is a clock API intended to let users query the current\n/// time. The name \"wall\" makes an analogy to a \"clock on the wall\", which\n/// is not necessarily monotonic as it may be reset.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A wall clock is a clock which measures the date and time according to\n/// some external reference.\n///\n/// External references may be reset, so this clock is not necessarily\n/// monotonic, making it unsuitable for measuring elapsed time.\n///\n/// It is intended for reporting the current date and time for humans.\n@since(version = 0.2.0)\ninterface wall-clock {\n    /// A time and date in seconds plus nanoseconds.\n    @since(version = 0.2.0)\n    record datetime {\n        seconds: u64,\n        nanoseconds: u32,\n    }\n\n    /// Read the current value of the clock.\n    ///\n    /// This clock is not monotonic, therefore calling this function repeatedly\n    /// will not necessarily produce a sequence of non-decreasing values.\n    ///\n    /// The returned timestamps represent the number of seconds since\n    /// 1970-01-01T00:00:00Z, also known as [POSIX\'s Seconds Since the Epoch],\n    /// also known as [Unix Time].\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    ///\n    /// [POSIX\'s Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16\n    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time\n    @since(version = 0.2.0)\n    now: func() -> datetime;\n\n    /// Query the resolution of the clock.\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    @since(version = 0.2.0)\n    resolution: func() -> datetime;\n}\n";
    const _: &[u8] = b"interface types {\n    /// one single row item\n    record row {\n        field-name: string,\n        value: data-type,\n    }\n    \n    /// common data types\n    variant data-type {\n        int32(s32),\n        int64(s64),\n        uint32(u32),\n        uint64(u64),\n        float(f64),\n        double(f64),\n        str(string),\n        boolean(bool),\n        date(string),\n        time(string),\n        timestamp(string),\n        binary(list<u8>),\n        null\n    }\n\n    /// allows parameterized queries\n    /// e.g., prepare(\"SELECT * FROM users WHERE name = ? AND age = ?\", vec![\"John Doe\", \"32\"])\n    resource statement {\n        prepare: static func(query: string, params: list<string>) -> result<statement, error>;\n    }\n    /// An error resource type.\n    /// Currently, this provides only one function to return a string representation\n    /// of the error. In the future, this will be extended to provide more information.\n    resource error {\n\t\ttrace: func() -> string;\n  \t}\n    \n    /// A connection to a sql store.\n    resource connection {\n        open: static func(name: string) -> result<connection, error>;\n    }\n}";
    const _: &[u8] = b"package wasi:vault@0.1.0-draft;\n\nworld imports {\n  import vault;\n}\n";
    const _: &[u8] = b"interface readwrite {\n    use types.{statement, row, error, connection};\n    \n    /// query is optimized for querying data, and \n    /// implementors can make use of that fact to optimize \n    /// the performance of query execution (e.g., using\n    /// indexes).\n    query: func(c: borrow<connection>, q: borrow<statement>) -> result<list<row>, error>;\n    \n    /// exec is for modifying data in the database.\n    exec: func(c: borrow<connection>, q: borrow<statement>) -> result<u32, error>;\n}";
    const _: &[u8] = b"interface vault {\n    /// An error type that encapsulates the different errors that can occur fetching secrets\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// Open the specified locker.\n    /// \n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(locker-id: string) -> result<locker, error>;\n\n    /// A locker contains collection of related secrets.\n    resource locker {\n        /// Get the specified secret.\n        ///\n        /// Returns `none` if the specified secret does not exist.\n        get: func(secret-id: string) -> result<option<list<u8>>, error>;\n\n        /// Store a secret in the vault. If the `id` already exists, the\n        /// secret will be overwritten.\n        set: func(secret-id: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the specified secret.\n        /// \n        /// Will do nothing if the secret does not exist.\n        delete: func(secret-id: string) -> result<_, error>;\n\n        /// Check if the specified secret exists.\n        exists: func(secret-id: string) -> result<bool, error>;\n\n        /// List all `secret-id`s in the locker.\n        list-ids: func() -> result<list<string>, error>;\n    }\n}";
    const _: &[u8] = b"/// The producer interface is used to send messages to a channel/topic.\ninterface producer {\n    use types.{client, message, error, topic};\n\n    /// Sends the message using the given client.\n    send: async func(c: client, topic: topic, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"// wasi-cloud Blobstore service definition\ninterface blobstore {\n  use container.{container};\n  use types.{error, container-name, object-id};\n\n  // creates a new empty container\n  create-container: func(name: container-name) -> result<container, error>;\n\n  // retrieves a container by name\n  get-container: func(name: container-name) -> result<container, error>;\n\n  // deletes a container and all objects within it\n  delete-container: func(name: container-name) -> result<_, error>;\n\n  // returns true if the container exists\n  container-exists: func(name: container-name) -> result<bool, error>;\n\n  // copies (duplicates) an object, to the same or a different container.\n  // returns an error if the target container does not exist.\n  // overwrites destination object if it already existed.\n  copy-object: func(src: object-id, dest: object-id) -> result<_, error>;\n\n  // moves or renames an object, to the same or a different container\n  // returns an error if the destination container does not exist.\n  // overwrites destination object if it already existed.\n  move-object: func(src:object-id, dest: object-id) -> result<_, error>;\n}";
    const _: &[u8] = b"/// A keyvalue interface that provides batch operations.\n/// \n/// A batch operation is an operation that operates on multiple keys at once.\n/// \n/// Batch operations are useful for reducing network round-trip time. For example, if you want to\n/// get the values associated with 100 keys, you can either do 100 get operations or you can do 1\n/// batch get operation. The batch operation is faster because it only needs to make 1 network call\n/// instead of 100.\n/// \n/// A batch operation does not guarantee atomicity, meaning that if the batch operation fails, some\n/// of the keys may have been modified and some may not. \n/// \n/// This interface does has the same consistency guarantees as the `store` interface, meaning that\n/// you should be able to \"read your writes.\"\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface batch {\n    use store.{bucket, error};\n\n    /// Get the key-value pairs associated with the keys in the store. It returns a list of\n    /// key-value pairs.\n    ///\n    /// If any of the keys do not exist in the store, it returns a `none` value for that pair in the\n    /// list.\n    /// \n    /// MAY show an out-of-date value if there are concurrent writes to the store.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`.\n    get-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<list<option<tuple<string, list<u8>>>>, error>;\n\n    /// Set the values associated with the keys in the store. If the key already exists in the\n    /// store, it overwrites the value. \n    /// \n    /// Note that the key-value pairs are not guaranteed to be set in the order they are provided. \n    ///\n    /// If any of the keys do not exist in the store, it creates a new key-value pair.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already set. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be set while others might\n    /// fail. \n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    set-many: func(bucket: borrow<bucket>, key-values: list<tuple<string, list<u8>>>) -> result<_, error>;\n\n    /// Delete the key-value pairs associated with the keys in the store.\n    /// \n    /// Note that the key-value pairs are not guaranteed to be deleted in the order they are\n    /// provided.\n    /// \n    /// If any of the keys do not exist in the store, it skips the key.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already deleted. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be deleted while others might\n    /// fail.\n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    delete-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<_, error>;\n}\n";
}
/// Bindings for the `wasi:vault` world.
pub mod vault {
    pub use self::wasi::vault::*;
    #[allow(dead_code, clippy::all)]
    pub mod wasi {
        pub mod vault {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vault {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
                use super::super::super::_rt;
                /// An error type that encapsulates the different errors that can occur fetching secrets
                pub enum Error {
                    /// The host does not recognize the store identifier requested.
                    NoSuchStore,
                    /// The requesting component does not have access to the specified store
                    /// (which may or may not exist).
                    AccessDenied,
                    /// Some implementation-specific error has occurred (e.g. I/O)
                    Other(_rt::String),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Error {
                    #[inline]
                    fn clone(&self) -> Error {
                        match self {
                            Error::NoSuchStore => Error::NoSuchStore,
                            Error::AccessDenied => Error::AccessDenied,
                            Error::Other(__self_0) => {
                                Error::Other(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Error::NoSuchStore => {
                                f.debug_tuple("Error::NoSuchStore").finish()
                            }
                            Error::AccessDenied => {
                                f.debug_tuple("Error::AccessDenied").finish()
                            }
                            Error::Other(e) => {
                                f.debug_tuple("Error::Other").field(e).finish()
                            }
                        }
                    }
                }
                impl ::core::fmt::Display for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for Error {}
                /// A locker contains collection of related secrets.
                #[repr(transparent)]
                pub struct Locker {
                    handle: _rt::Resource<Locker>,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Locker {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Locker",
                            "handle",
                            &&self.handle,
                        )
                    }
                }
                impl Locker {
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                }
                unsafe impl _rt::WasmResource for Locker {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        unsafe extern "C" fn drop(_: i32) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        unsafe {
                            drop(_handle as i32);
                        }
                    }
                }
                #[allow(unused_unsafe, clippy::all)]
                /// Open the specified locker.
                ///
                /// `error::no-such-store` will be raised if the `identifier` is not recognized.
                #[allow(async_fn_in_trait)]
                pub fn open(locker_id: &str) -> Result<Locker, Error> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = locker_id;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        unsafe extern "C" fn wit_import2(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        wit_import2(ptr0.cast_mut(), len0, ptr1);
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result10 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>();
                                    Locker::from_handle(l4 as u32)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v9 = match l5 {
                                        0 => Error::NoSuchStore,
                                        1 => Error::AccessDenied,
                                        n => {
                                            if true {
                                                match (&n, &2) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e9 = {
                                                let l6 = *ptr1
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l7 = *ptr1
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len8 = l7;
                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                    l6.cast(),
                                                    len8,
                                                    len8,
                                                );
                                                _rt::string_lift(bytes8)
                                            };
                                            Error::Other(e9)
                                        }
                                    };
                                    v9
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
                impl Locker {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Get the specified secret.
                    ///
                    /// Returns `none` if the specified secret does not exist.
                    #[allow(async_fn_in_trait)]
                    pub fn get(
                        &self,
                        secret_id: &str,
                    ) -> Result<Option<_rt::Vec<u8>>, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = secret_id;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result13 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        match l4 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l5 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l6 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len7 = l6;
                                                    _rt::Vec::from_raw_parts(l5.cast(), len7, len7)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        }
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l8 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v12 = match l8 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e12 = {
                                                    let l9 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l10 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len11 = l10;
                                                    let bytes11 = _rt::Vec::from_raw_parts(
                                                        l9.cast(),
                                                        len11,
                                                        len11,
                                                    );
                                                    _rt::string_lift(bytes11)
                                                };
                                                Error::Other(e12)
                                            }
                                        };
                                        v12
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result13
                        }
                    }
                }
                impl Locker {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Store a secret in the vault. If the `id` already exists, the
                    /// secret will be overwritten.
                    #[allow(async_fn_in_trait)]
                    pub fn set(
                        &self,
                        secret_id: &str,
                        value: &[u8],
                    ) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = secret_id;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let vec1 = value;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();
                            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import3(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import3(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1.cast_mut(),
                                len1,
                                ptr2,
                            );
                            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                            let result10 = match l4 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = i32::from(
                                            *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v9 = match l5 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e9 = {
                                                    let l6 = *ptr2
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l7 = *ptr2
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len8 = l7;
                                                    let bytes8 = _rt::Vec::from_raw_parts(
                                                        l6.cast(),
                                                        len8,
                                                        len8,
                                                    );
                                                    _rt::string_lift(bytes8)
                                                };
                                                Error::Other(e9)
                                            }
                                        };
                                        v9
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result10
                        }
                    }
                }
                impl Locker {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Delete the specified secret.
                    ///
                    /// Will do nothing if the secret does not exist.
                    #[allow(async_fn_in_trait)]
                    pub fn delete(&self, secret_id: &str) -> Result<(), Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = secret_id;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result9 = match l3 {
                                0 => {
                                    let e = ();
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l4 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v8 = match l4 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e8 = {
                                                    let l5 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l6 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len7 = l6;
                                                    let bytes7 = _rt::Vec::from_raw_parts(
                                                        l5.cast(),
                                                        len7,
                                                        len7,
                                                    );
                                                    _rt::string_lift(bytes7)
                                                };
                                                Error::Other(e8)
                                            }
                                        };
                                        v8
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result9
                        }
                    }
                }
                impl Locker {
                    #[allow(unused_unsafe, clippy::all)]
                    /// Check if the specified secret exists.
                    #[allow(async_fn_in_trait)]
                    pub fn exists(&self, secret_id: &str) -> Result<bool, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let vec0 = secret_id;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            );
                            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                            let result10 = match l3 {
                                0 => {
                                    let e = {
                                        let l4 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        _rt::bool_lift(l4 as u8)
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l5 = i32::from(
                                            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v9 = match l5 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e9 = {
                                                    let l6 = *ptr1
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l7 = *ptr1
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len8 = l7;
                                                    let bytes8 = _rt::Vec::from_raw_parts(
                                                        l6.cast(),
                                                        len8,
                                                        len8,
                                                    );
                                                    _rt::string_lift(bytes8)
                                                };
                                                Error::Other(e9)
                                            }
                                        };
                                        v9
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result10
                        }
                    }
                }
                impl Locker {
                    #[allow(unused_unsafe, clippy::all)]
                    /// List all `secret-id`s in the locker.
                    #[allow(async_fn_in_trait)]
                    pub fn list_ids(&self) -> Result<_rt::Vec<_rt::String>, Error> {
                        unsafe {
                            #[repr(align(8))]
                            struct RetArea(
                                [::core::mem::MaybeUninit<
                                    u8,
                                >; 4 * ::core::mem::size_of::<*const u8>()],
                            );
                            let mut ret_area = RetArea(
                                [::core::mem::MaybeUninit::uninit(); 4
                                    * ::core::mem::size_of::<*const u8>()],
                            );
                            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                            wit_import1((self).handle() as i32, ptr0);
                            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                            let result14 = match l2 {
                                0 => {
                                    let e = {
                                        let l3 = *ptr0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *ptr0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base8 = l3;
                                        let len8 = l4;
                                        let mut result8 = _rt::Vec::with_capacity(len8);
                                        for i in 0..len8 {
                                            let base = base8
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e8 = {
                                                let l5 = *base.add(0).cast::<*mut u8>();
                                                let l6 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len7 = l6;
                                                let bytes7 = _rt::Vec::from_raw_parts(
                                                    l5.cast(),
                                                    len7,
                                                    len7,
                                                );
                                                _rt::string_lift(bytes7)
                                            };
                                            result8.push(e8);
                                        }
                                        _rt::cabi_dealloc(
                                            base8,
                                            len8 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result8
                                    };
                                    Ok(e)
                                }
                                1 => {
                                    let e = {
                                        let l9 = i32::from(
                                            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                        );
                                        let v13 = match l9 {
                                            0 => Error::NoSuchStore,
                                            1 => Error::AccessDenied,
                                            n => {
                                                if true {
                                                    match (&n, &2) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e13 = {
                                                    let l10 = *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l11 = *ptr0
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len12 = l11;
                                                    let bytes12 = _rt::Vec::from_raw_parts(
                                                        l10.cast(),
                                                        len12,
                                                        len12,
                                                    );
                                                    _rt::string_lift(bytes12)
                                                };
                                                Error::Other(e13)
                                            }
                                        };
                                        v13
                                    };
                                    Err(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            };
                            result14
                        }
                    }
                }
            }
        }
    }
    mod _rt {
        #![allow(dead_code, clippy::all)]
        pub use alloc_crate::string::String;
        use core::fmt;
        use core::marker;
        use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
        /// A type which represents a component model resource, either imported or
        /// exported into this component.
        ///
        /// This is a low-level wrapper which handles the lifetime of the resource
        /// (namely this has a destructor). The `T` provided defines the component model
        /// intrinsics that this wrapper uses.
        ///
        /// One of the chief purposes of this type is to provide `Deref` implementations
        /// to access the underlying data when it is owned.
        ///
        /// This type is primarily used in generated code for exported and imported
        /// resources.
        #[repr(transparent)]
        pub struct Resource<T: WasmResource> {
            handle: AtomicU32,
            _marker: marker::PhantomData<T>,
        }
        /// A trait which all wasm resources implement, namely providing the ability to
        /// drop a resource.
        ///
        /// This generally is implemented by generated code, not user-facing code.
        #[allow(clippy::missing_safety_doc)]
        pub unsafe trait WasmResource {
            /// Invokes the `[resource-drop]...` intrinsic.
            unsafe fn drop(handle: u32);
        }
        impl<T: WasmResource> Resource<T> {
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
                if true {
                    if !(handle != 0 && handle != u32::MAX) {
                        ::core::panicking::panic(
                            "assertion failed: handle != 0 && handle != u32::MAX",
                        )
                    }
                }
                Self {
                    handle: AtomicU32::new(handle),
                    _marker: marker::PhantomData,
                }
            }
            /// Takes ownership of the handle owned by `resource`.
            ///
            /// Note that this ideally would be `into_handle` taking `Resource<T>` by
            /// ownership. The code generator does not enable that in all situations,
            /// unfortunately, so this is provided instead.
            ///
            /// Also note that `take_handle` is in theory only ever called on values
            /// owned by a generated function. For example a generated function might
            /// take `Resource<T>` as an argument but then call `take_handle` on a
            /// reference to that argument. In that sense the dynamic nature of
            /// `take_handle` should only be exposed internally to generated code, not
            /// to user code.
            #[doc(hidden)]
            pub fn take_handle(resource: &Resource<T>) -> u32 {
                resource.handle.swap(u32::MAX, Relaxed)
            }
            #[doc(hidden)]
            pub fn handle(resource: &Resource<T>) -> u32 {
                resource.handle.load(Relaxed)
            }
        }
        impl<T: WasmResource> fmt::Debug for Resource<T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("Resource").field("handle", &self.handle).finish()
            }
        }
        impl<T: WasmResource> Drop for Resource<T> {
            fn drop(&mut self) {
                unsafe {
                    match self.handle.load(Relaxed) {
                        u32::MAX => {}
                        other => T::drop(other),
                    }
                }
            }
        }
        pub use alloc_crate::vec::Vec;
        pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
            if true {
                String::from_utf8(bytes).unwrap()
            } else {
                unsafe { String::from_utf8_unchecked(bytes) }
            }
        }
        pub unsafe fn invalid_enum_discriminant<T>() -> T {
            if true {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid enum discriminant"),
                    );
                }
            } else {
                unsafe { core::hint::unreachable_unchecked() }
            }
        }
        pub unsafe fn bool_lift(val: u8) -> bool {
            if true {
                match val {
                    0 => false,
                    1 => true,
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!("invalid bool discriminant"),
                        );
                    }
                }
            } else {
                val != 0
            }
        }
        pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
            if size == 0 {
                return;
            }
            unsafe {
                let layout = alloc::Layout::from_size_align_unchecked(size, align);
                alloc::dealloc(ptr, layout);
            }
        }
        extern crate alloc as alloc_crate;
        pub use alloc_crate::alloc;
    }
    #[inline(never)]
    #[doc(hidden)]
    pub fn __link_custom_section_describing_imports() {
        wit_bindgen::rt::maybe_link_cabi_realloc();
    }
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import streams;\n\n    @since(version = 0.2.0)\n    import poll;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides eventually consistent key-value operations.\n/// \n/// Each of these operations acts on a single key-value pair.\n/// \n/// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is\n/// the common denominator for all data types defined by different key-value stores to handle data,\n/// ensuring compatibility between different key-value stores. Note: the clients will be expecting\n/// serialization/deserialization overhead to be handled by the key-value store. The value could be\n/// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.\n/// \n/// Data consistency in a key value store refers to the guarantee that once a write operation\n/// completes, all subsequent read operations will return the value that was written.\n/// \n/// Any implementation of this interface must have enough consistency to guarantee \"reading your\n/// writes.\" In particular, this means that the client should never get a value that is older than\n/// the one it wrote, but it MAY get a newer value if one was written around the same time. These\n/// guarantees only apply to the same client (which will likely be provided by the host or an\n/// external capability of some kind). In this context a \"client\" is referring to the caller or\n/// guest that is consuming this interface. Once a write request is committed by a specific client,\n/// all subsequent read requests by the same client will reflect that write or any subsequent\n/// writes. Another client running in a different context may or may not immediately see the result\n/// due to the replication lag. As an example of all of this, if a value at a given key is A, and\n/// the client writes B, then immediately reads, it should get B. If something else writes C in\n/// quick succession, then the client may get C. However, a client running in a separate context may\n/// still see A or B\ninterface store {\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// A response to a `list-keys` operation.\n    record key-response {\n        /// The list of keys returned by the query.\n        keys: list<string>,\n        /// The continuation token to use to fetch the next page of keys. If this is `null`, then\n        /// there are no more keys to fetch.\n        cursor: option<string>\n    }\n\n    /// Get the bucket with the specified identifier.\n    ///\n    /// `identifier` must refer to a bucket provided by the host.\n    ///\n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(identifier: string) -> result<bucket, error>;\n\n    /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the\n    /// bucket, and the bucket itself acts as a collection of all these entries.\n    ///\n    /// It is worth noting that the exact terminology for bucket in key-value stores can very\n    /// depending on the specific implementation. For example:\n    ///\n    /// 1. Amazon DynamoDB calls a collection of key-value pairs a table\n    /// 2. Redis has hashes, sets, and sorted sets as different types of collections\n    /// 3. Cassandra calls a collection of key-value pairs a column family\n    /// 4. MongoDB calls a collection of key-value pairs a collection\n    /// 5. Riak calls a collection of key-value pairs a bucket\n    /// 6. Memcached calls a collection of key-value pairs a slab\n    /// 7. Azure Cosmos DB calls a collection of key-value pairs a container\n    ///\n    /// In this interface, we use the term `bucket` to refer to a collection of key-value pairs\n    resource bucket {\n        /// Get the value associated with the specified `key`\n        ///\n        /// The value is returned as an option. If the key-value pair exists in the\n        /// store, it returns `Ok(value)`. If the key does not exist in the\n        /// store, it returns `Ok(none)`. \n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        get: func(key: string) -> result<option<list<u8>>, error>;\n\n        /// Set the value associated with the key in the store. If the key already\n        /// exists in the store, it overwrites the value.\n        ///\n        /// If the key does not exist in the store, it creates a new key-value pair.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        set: func(key: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the key-value pair associated with the key in the store.\n        /// \n        /// If the key does not exist in the store, it does nothing.\n        ///\n        /// If any other error occurs, it returns an `Err(error)`.\n        delete: func(key: string) -> result<_, error>;\n\n        /// Check if the key exists in the store.\n        /// \n        /// If the key exists in the store, it returns `Ok(true)`. If the key does\n        /// not exist in the store, it returns `Ok(false)`.\n        /// \n        /// If any other error occurs, it returns an `Err(error)`.\n        exists: func(key: string) -> result<bool, error>;\n\n        /// Get all the keys in the store with an optional cursor (for use in pagination). It\n        /// returns a list of keys. Please note that for most KeyValue implementations, this is a\n        /// can be a very expensive operation and so it should be used judiciously. Implementations\n        /// can return any number of keys in a single response, but they should never attempt to\n        /// send more data than is reasonable (i.e. on a small edge device, this may only be a few\n        /// KB, while on a large machine this could be several MB). Any response should also return\n        /// a cursor that can be used to fetch the next page of keys. See the `key-response` record\n        /// for more information.\n        /// \n        /// Note that the keys are not guaranteed to be returned in any particular order.\n        /// \n        /// If the store is empty, it returns an empty list.\n        /// \n        /// MAY show an out-of-date list of keys if there are concurrent writes to the store.\n        /// \n        /// If any error occurs, it returns an `Err(error)`.\n        list-keys: func(cursor: option<string>) -> result<key-response, error>;\n    }\n}\n";
    const _: &[u8] = b"interface %resource {\n    use types.{key, value, key-value, %resource as telemetry-resource};\n\n    /// Returns the telemetry resource used by the host.\n    %resource: func() -> telemetry-resource;\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Wall Clock is a clock API intended to let users query the current\n/// time. The name \"wall\" makes an analogy to a \"clock on the wall\", which\n/// is not necessarily monotonic as it may be reset.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A wall clock is a clock which measures the date and time according to\n/// some external reference.\n///\n/// External references may be reset, so this clock is not necessarily\n/// monotonic, making it unsuitable for measuring elapsed time.\n///\n/// It is intended for reporting the current date and time for humans.\n@since(version = 0.2.0)\ninterface wall-clock {\n    /// A time and date in seconds plus nanoseconds.\n    @since(version = 0.2.0)\n    record datetime {\n        seconds: u64,\n        nanoseconds: u32,\n    }\n\n    /// Read the current value of the clock.\n    ///\n    /// This clock is not monotonic, therefore calling this function repeatedly\n    /// will not necessarily produce a sequence of non-decreasing values.\n    ///\n    /// The returned timestamps represent the number of seconds since\n    /// 1970-01-01T00:00:00Z, also known as [POSIX\'s Seconds Since the Epoch],\n    /// also known as [Unix Time].\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    ///\n    /// [POSIX\'s Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16\n    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time\n    @since(version = 0.2.0)\n    now: func() -> datetime;\n\n    /// Query the resolution of the clock.\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    @since(version = 0.2.0)\n    resolution: func() -> datetime;\n}\n";
    const _: &[u8] = b"package wasi:keyvalue@0.2.0-draft2;\n\n/// The `wasi:keyvalue/imports` world provides common APIs for interacting with key-value stores.\n/// Components targeting this world will be able to do:\n/// \n/// 1. CRUD (create, read, update, delete) operations on key-value stores.\n/// 2. Atomic `increment` and CAS (compare-and-swap) operations.\n/// 3. Batch operations that can reduce the number of round trips to the network.\nworld imports {\n\t/// The `store` capability allows the component to perform eventually consistent operations on\n\t/// the key-value store.\n\timport store;\n\n\t/// The `atomic` capability allows the component to perform atomic / `increment` and CAS\n\t/// (compare-and-swap) operations.\n\timport atomics;\n\n\t/// The `batch` capability allows the component to perform eventually consistent batch\n\t/// operations that can reduce the number of round trips to the network.\n\timport batch;\n}\n\nworld watch-service {\n\tinclude imports;\n\texport watcher;\n}";
    const _: &[u8] = b"/// The request-reply interface allows a guest to send a message and await a response. This\n/// interface is considered optional as not all message services support the concept of\n/// request/reply. However, request/reply is a very common pattern in messaging and as such, we have\n/// included it as a core interface.\ninterface request-reply {\n    use types.{client, message, error, topic};\n\n    /// Options for a request/reply operation. This is a resource to allow for future expansion of\n    /// options.\n    resource request-options {\n        /// Creates a new request options resource with no options set.\n        constructor();\n\n        /// The maximum amount of time to wait for a response. If the timeout value is not set, then\n        /// the request/reply operation will block until a message is received in response.\n        set-timeout-ms: func(timeout-ms: u32);\n\n        /// The maximum number of replies to expect before returning.\n        set-expected-replies: func(expected-replies: u32);\n    }\n\n    /// Performs a blocking request/reply operation with an optional set of request options. \n    /// \n    /// The behavior of this function is largely dependent on the options given to the function.\n    /// If no options are provided, then the request/reply operation will block until a single \n    /// message is received in response. If a timeout is provided, then the request/reply operation\n    /// will block for the specified amount of time before returning an error if no messages were\n    /// received (or the list of messages that were received). If both a timeout and an expected\n    /// number of replies are provided, the function should return when either condition is met\n    /// (whichever comes first)\xe2\x80\x94e.g., (1) if no replies were received within the timeout return an\n    /// error, (2) if the maximum expected number of replies were received before timeout, return\n    /// the list of messages, or (3) if the timeout is reached before the expected number of replies,\n    /// return the list of messages received up to that point.\n    request: func(c: borrow<client>, topic: topic, message: borrow<message>, options: option<request-options>) -> result<list<message>, error>;\n\n    /// Replies to the given message with the given response message. The details of which topic\n    /// the message is sent to is up to the implementation. This allows for reply-to details to be\n    /// handled in the best way possible for the underlying messaging system.\n    /// \n    /// Please note that this reply functionality is different than something like HTTP because there\n    /// are several use cases in which a reply might not be required for every message (so this would\n    /// be a noop). There are also cases when you might want to reply and then continue processing.\n    /// Additionally, you might want to reply to a message several times (such as providing an\n    /// update). So this function is allowed to be called multiple times, unlike something like HTTP\n    /// where the reply is sent and the connection is closed.\n    reply: func(reply-to: borrow<message>, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"interface readwrite {\n    use types.{statement, row, error, connection};\n    \n    /// query is optimized for querying data, and \n    /// implementors can make use of that fact to optimize \n    /// the performance of query execution (e.g., using\n    /// indexes).\n    query: func(c: borrow<connection>, q: borrow<statement>) -> result<list<row>, error>;\n    \n    /// exec is for modifying data in the database.\n    exec: func(c: borrow<connection>, q: borrow<statement>) -> result<u32, error>;\n}";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// A poll API intended to let users wait for I/O events on multiple handles\n/// at once.\n@since(version = 0.2.0)\ninterface poll {\n    /// `pollable` represents a single I/O event which may be ready, or not.\n    @since(version = 0.2.0)\n    resource pollable {\n\n        /// Return the readiness of a pollable. This function never blocks.\n        ///\n        /// Returns `true` when the pollable is ready, and `false` otherwise.\n        @since(version = 0.2.0)\n        ready: func() -> bool;\n\n        /// `block` returns immediately if the pollable is ready, and otherwise\n        /// blocks until ready.\n        ///\n        /// This function is equivalent to calling `poll.poll` on a list\n        /// containing only this pollable.\n        @since(version = 0.2.0)\n        block: func();\n    }\n\n    /// Poll for completion on a set of pollables.\n    ///\n    /// This function takes a list of pollables, which identify I/O sources of\n    /// interest, and waits until one or more of the events is ready for I/O.\n    ///\n    /// The result `list<u32>` contains one or more indices of handles in the\n    /// argument list that is ready for I/O.\n    ///\n    /// This function traps if either:\n    /// - the list is empty, or:\n    /// - the list contains more elements than can be indexed with a `u32` value.\n    ///\n    /// A timeout can be implemented by adding a pollable from the\n    /// wasi-clocks API to the list.\n    ///\n    /// This function does not return a `result`; polling in itself does not\n    /// do any I/O so it doesn\'t fail. If any of the I/O sources identified by\n    /// the pollables has an error, it is indicated by marking the source as\n    /// being ready for I/O.\n    @since(version = 0.2.0)\n    poll: func(in: list<borrow<pollable>>) -> list<u32>;\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n@since(version = 0.2.0)\ninterface error {\n    /// A resource which represents some error information.\n    ///\n    /// The only method provided by this resource is `to-debug-string`,\n    /// which provides some human-readable information about the error.\n    ///\n    /// In the `wasi:io` package, this resource is returned through the\n    /// `wasi:io/streams/stream-error` type.\n    ///\n    /// To provide more specific error information, other interfaces may\n    /// offer functions to \"downcast\" this error into more specific types. For example,\n    /// errors returned from streams derived from filesystem types can be described using\n    /// the filesystem\'s own error-code type. This is done using the function\n    /// `wasi:filesystem/types/filesystem-error-code`, which takes a `borrow<error>`\n    /// parameter and returns an `option<wasi:filesystem/types/error-code>`.\n    ///\n    /// The set of functions which can \"downcast\" an `error` into a more\n    /// concrete type is open.\n    @since(version = 0.2.0)\n    resource error {\n        /// Returns a string that is suitable to assist humans in debugging\n        /// this error.\n        ///\n        /// WARNING: The returned string should not be consumed mechanically!\n        /// It may change across platforms, hosts, or other implementation\n        /// details. Parsing this string is a major platform-compatibility\n        /// hazard.\n        @since(version = 0.2.0)\n        to-debug-string: func() -> string;\n    }\n}\n";
    const _: &[u8] = b"// Types used by blobstore\ninterface types {\n  use wasi:io/streams@0.2.6.{input-stream, output-stream};\n\n  // name of a container, a collection of objects.\n  // The container name may be any valid UTF-8 string.\n  type container-name = string;\n\n  // name of an object within a container\n  // The object name may be any valid UTF-8 string.\n  type object-name = string;\n\n  // TODO: define timestamp to include seconds since\n  // Unix epoch and nanoseconds\n  // https://github.com/WebAssembly/wasi-blob-store/issues/7\n  type timestamp = u64;\n\n  // size of an object, in bytes\n  type object-size = u64;\n\n  type error = string;\n\n  // information about a container\n  record container-metadata {\n    // the container\'s name\n    name: container-name,\n    // date and time container was created\n    created-at: timestamp,\n  }\n\n  // information about an object\n  record object-metadata {\n    // the object\'s name\n    name: object-name,\n    // the object\'s parent container\n    container: container-name,\n    // date and time the object was created\n    created-at: timestamp,\n    // size of the object, in bytes\n    size: object-size,\n  }\n\n  // identifier for an object that includes its container name\n  record object-id {\n    container: container-name,\n    object: object-name\n  }\n\n  /// A data is the data stored in a data blob. The value can be of any type\n  /// that can be represented in a byte array. It provides a way to write the value\n  /// to the output-stream defined in the `wasi-io` interface.\n  // Soon: switch to `resource value { ... }`\n  resource outgoing-value {\n    new-outgoing-value: static func() -> outgoing-value;\n\n    /// Returns a stream for writing the value contents.\n    ///\n    /// The returned `output-stream` is a child resource: it must be dropped\n    /// before the parent `outgoing-value` resource is dropped (or finished),\n    /// otherwise the `outgoing-value` drop or `finish` will trap.\n    ///\n    /// Returns success on the first call: the `output-stream` resource for\n    /// this `outgoing-value` may be retrieved at most once. Subsequent calls\n    /// will return error.\n    outgoing-value-write-body: func() -> result<output-stream, error>;\n\n    /// Finalize an outgoing value. This must be\n    /// called to signal that the outgoing value is complete. If the `outgoing-value`\n    /// is dropped without calling `outgoing-value.finalize`, the implementation\n    /// should treat the value as corrupted.\n    finish: static func(this: outgoing-value) -> result<_, error>;\n  }\n\n  /// A incoming-value is a wrapper around a value. It provides a way to read the value\n  /// from the input-stream defined in the `wasi-io` interface.\n  ///\n  /// The incoming-value provides two ways to consume the value:\n  /// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the\n  ///    value as a list of bytes.\n  /// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the\n  ///    value as an input-stream.\n  // Soon: switch to `resource incoming-value { ... }`\n  resource incoming-value {\n      incoming-value-consume-sync: static func(this: incoming-value) -> result<incoming-value-sync-body, error>;\n      incoming-value-consume-async: static func(this: incoming-value) -> result<incoming-value-async-body, error>;\n      size: func() -> u64;\n  }\n\n  type incoming-value-async-body = input-stream;\n  type incoming-value-sync-body = list<u8>;\n}\n";
    const _: &[u8] = b"package wasi:messaging@0.2.0-draft;\n\n/// The `imports` world defines the interfaces that the component will import from the host.\n/// It includes the `producer` interface for sending messages.\nworld imports {\n  import producer;\n}\n\n/// The `imports-request-reply` world extends `imports` by including the `request-reply` interface.\n/// This allows the component to perform request/reply messaging patterns.\nworld imports-request-reply {\n  include imports;\n  import request-reply;\n}\n\n/// The `messaging-request-reply` world combines `imports-request-reply` with the `incoming-handler`\n/// export. This setup allows the host to interact with the component for both sending messages and\n/// handling incoming messages with request/reply capabilities.\nworld messaging-request-reply {\n  include imports-request-reply;\n  export incoming-handler;\n}\n\n/// The `messaging-core` world includes the basic `imports` and exports the `incoming-handler`,\n/// enabling the component to handle incoming messages without request/reply capabilities.\nworld messaging-core {\n  include imports;\n  export incoming-handler;\n}\n";
    const _: &[u8] = b"interface vault {\n    /// An error type that encapsulates the different errors that can occur fetching secrets\n    variant error {\n        /// The host does not recognize the store identifier requested.\n        no-such-store,\n\n        /// The requesting component does not have access to the specified store\n        /// (which may or may not exist).\n        access-denied,\n\n        /// Some implementation-specific error has occurred (e.g. I/O)\n        other(string)\n    }\n\n    /// Open the specified locker.\n    /// \n    /// `error::no-such-store` will be raised if the `identifier` is not recognized.\n    open: func(locker-id: string) -> result<locker, error>;\n\n    /// A locker contains collection of related secrets.\n    resource locker {\n        /// Get the specified secret.\n        ///\n        /// Returns `none` if the specified secret does not exist.\n        get: func(secret-id: string) -> result<option<list<u8>>, error>;\n\n        /// Store a secret in the vault. If the `id` already exists, the\n        /// secret will be overwritten.\n        set: func(secret-id: string, value: list<u8>) -> result<_, error>;\n\n        /// Delete the specified secret.\n        /// \n        /// Will do nothing if the secret does not exist.\n        delete: func(secret-id: string) -> result<_, error>;\n\n        /// Check if the specified secret exists.\n        exists: func(secret-id: string) -> result<bool, error>;\n\n        /// List all `secret-id`s in the locker.\n        list-ids: func() -> result<list<string>, error>;\n    }\n}";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@unstable(feature = clocks-timezone)\ninterface timezone {\n    @unstable(feature = clocks-timezone)\n    use wall-clock.{datetime};\n\n    /// Return information needed to display the given `datetime`. This includes\n    /// the UTC offset, the time zone name, and a flag indicating whether\n    /// daylight saving time is active.\n    ///\n    /// If the timezone cannot be determined for the given `datetime`, return a\n    /// `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight\n    /// saving time.\n    @unstable(feature = clocks-timezone)\n    display: func(when: datetime) -> timezone-display;\n\n    /// The same as `display`, but only return the UTC offset.\n    @unstable(feature = clocks-timezone)\n    utc-offset: func(when: datetime) -> s32;\n\n    /// Information useful for displaying the timezone of a specific `datetime`.\n    ///\n    /// This information may vary within a single `timezone` to reflect daylight\n    /// saving time adjustments.\n    @unstable(feature = clocks-timezone)\n    record timezone-display {\n        /// The number of seconds difference between UTC time and the local\n        /// time of the timezone.\n        ///\n        /// The returned value will always be less than 86400 which is the\n        /// number of seconds in a day (24*60*60).\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return 0.\n        utc-offset: s32,\n\n        /// The abbreviated name of the timezone to display to a user. The name\n        /// `UTC` indicates Coordinated Universal Time. Otherwise, this should\n        /// reference local standards for the name of the time zone.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should be the string `UTC`.\n        ///\n        /// In time zones that do not have an applicable name, a formatted\n        /// representation of the UTC offset may be returned, such as `-04:00`.\n        name: string,\n\n        /// Whether daylight saving time is active.\n        ///\n        /// In implementations that do not expose an actual time zone, this\n        /// should return false.\n        in-daylight-saving-time: bool,\n    }\n}\n";
    const _: &[u8] = b"interface tracing {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, error};\n\n    /// Returns the current span context of the host.\n    context: func() -> span-context;\n\n    /// Called by the guest to export spans.\n    %export: func(span: list<span-data>) -> result<_, error>;\n\n    /// The data associated with a span.\n    record span-data {\n        /// Span context.\n        span-context: span-context,\n        /// Span parent id.\n        parent-span-id: string,\n        /// Span kind.\n        span-kind: span-kind,\n        // Span name.\n        name: string,\n        /// Span start time.\n        start-time: datetime,\n        /// Span end time.\n        end-time: datetime,\n        /// Span attributes.\n        attributes: list<key-value>,\n        /// Span events.\n        events: list<event>,\n        /// Span Links.\n        links: list<link>,\n        /// Span status.\n        status: status,\n        /// Instrumentation scope that produced this span.\n        instrumentation-scope: instrumentation-scope,\n        /// Number of attributes dropped by the span due to limits being reached.\n        dropped-attributes: u32,\n        /// Number of events dropped by the span due to limits being reached.\n        dropped-events: u32,\n        /// Number of links dropped by the span due to limits being reached.\n        dropped-links: u32,\n    }\n\n    /// Identifying trace information about a span that can be serialized and propagated.\n    record span-context {\n        /// The `trace-id` for this `span-context`.\n        trace-id: trace-id,\n        /// The `span-id` for this `span-context`.\n        span-id: span-id,\n        /// The `trace-flags` for this `span-context`.\n        trace-flags: trace-flags,\n        /// Whether this `span-context` was propagated from a remote parent.\n        is-remote: bool,\n        /// The `trace-state` for this `span-context`.\n        trace-state: trace-state,\n    }\n\n    /// The trace that this `span-context` belongs to.\n    ///\n    /// 16 bytes encoded as a hexadecimal string.\n    type trace-id = string;\n\n    /// The id of this `span-context`.\n    ///\n    /// 8 bytes encoded as a hexadecimal string.\n    type span-id = string;\n\n    /// Flags that can be set on a `span-context`.\n    flags trace-flags {\n        /// Whether the `span` should be sampled or not.\n        sampled,\n    }\n\n    /// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.\n    ///\n    /// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.\n    type trace-state = list<tuple<string, string>>;\n\n    /// Describes the relationship between the Span, its parents, and its children in a trace.\n    enum span-kind {\n        /// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.\n        client,\n        /// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.\n        server,\n        /// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.\n        producer,\n        /// Indicates that the span describes a child of an asynchronous consumer request.\n        consumer,\n        /// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.\n        internal\n    }\n\n    /// An event describing a specific moment in time on a span and associated attributes.\n    record event {\n        /// Event name.\n        name: string,\n        /// Event time.\n        time: datetime,\n        /// Event attributes.\n        attributes: list<key-value>,\n    }\n\n    /// Describes a relationship to another `span`.\n    record link {\n        /// Denotes which `span` to link to.\n        span-context: span-context,\n        /// Attributes describing the link.\n        attributes: list<key-value>,\n    }\n\n    /// The `status` of a `span`.\n    variant status {\n        /// The default status.\n        unset,\n        /// The operation has been validated by an Application developer or Operator to have completed successfully.\n        ok,\n        /// The operation contains an error with a description.\n        error(string),\n    }\n}\n";
    const _: &[u8] = b"package wasi:blobstore@0.2.0-draft;\n\nworld imports {\n\timport blobstore;\n}\n";
    const _: &[u8] = b"interface incoming-handler {\n    use types.{message, error, topic};\n\n    /// Whenever this guest receives a message in one of the subscribed topics, the message is\n    /// sent to this handler. The guest is responsible for matching on the topic and handling the\n    /// message accordingly. Implementors (such as hosts) calling this interface should make their\n    /// own decisions on how to handle errors returned from this function.\n    handle: async func(message: message) -> result<_, error>;\n\n\n    /// Server configuration.\n    ///\n    /// This can be extended to include other configuration options in the\n    /// future.\n    record configuration {\n        /// Subscription topics\n        topics: list<topic>,\n    }\n\n    /// Configure is called by the runtime to get the server\'s runtime\n    /// configuration.\n    configure: async func() -> result<configuration, error>;\n\n}\n";
    const _: &[u8] = b"interface types {\n    /// A type alias for list<tuple<string, string>> to represent metadata attached to a message\n    type metadata = list<tuple<string, string>>;\n\n    /// A type alias for string to represent a message topic\n    type topic = string;\n\n    /// A connection to a message-exchange service (e.g., buffer, broker, etc.).\n    resource client {\n        connect: static func(name: string) -> result<client, error>;\n        disconnect: func() -> result<_, error>;\n    }\n\n    /// Errors that can occur when using the messaging interface.\n    variant error {\n        /// The request or operation timed out.\n        timeout,\n        /// An error occurred with the connection. Includes a message for additional context\n        connection(string),\n        /// A permission error occurred. Includes a message for additional context\n        permission-denied(string),\n        /// A catch all for other types of errors\n        other(string),\n    }\n\n    /// A message with a binary payload and additional information\n    resource message {\n        constructor(data: list<u8>);\n        // new: static func(data: stream<u8>) -> message;\n\n        /// The topic/subject/channel this message was received on, if any\n        topic: func() -> option<topic>;\n        /// An optional content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        content-type: func() -> option<string>;\n        /// Set the content-type describing the format of the data in the message. This is\n        /// sometimes described as the \"format\" type\n        set-content-type: func(content-type: string);\n        /// An opaque blob of data\n        data: func() -> list<u8>;\n        /// Set the opaque blob of data for this message, discarding the old value\n        set-data: func(data: list<u8>);\n        /// Optional metadata (also called headers or attributes in some systems) attached to the\n        /// message. This metadata is simply decoration and should not be interpreted by a host\n        /// to ensure portability across different implementors (e.g., Kafka -> NATS, etc.).\n        metadata: func() -> option<metadata>;\n        /// Add a new key-value pair to the metadata, overwriting any existing value for the same key\n        add-metadata: func(key: string, value: string);\n        /// Set the metadata\n        set-metadata: func(meta: metadata);\n        /// Remove a key-value pair from the metadata\n        remove-metadata: func(key: string);\n    }\n}\n";
    const _: &[u8] = b"package wasi:io@0.2.6;\n\n/// WASI I/O is an I/O abstraction API which is currently focused on providing\n/// stream types.\n///\n/// In the future, the component model is expected to add built-in stream types;\n/// when it does, they are expected to subsume this API.\n@since(version = 0.2.0)\ninterface streams {\n    @since(version = 0.2.0)\n    use error.{error};\n    @since(version = 0.2.0)\n    use poll.{pollable};\n\n    /// An error for input-stream and output-stream operations.\n    @since(version = 0.2.0)\n    variant stream-error {\n        /// The last operation (a write or flush) failed before completion.\n        ///\n        /// More information is available in the `error` payload.\n        ///\n        /// After this, the stream will be closed. All future operations return\n        /// `stream-error::closed`.\n        last-operation-failed(error),\n        /// The stream is closed: no more input will be accepted by the\n        /// stream. A closed output-stream will return this error on all\n        /// future operations.\n        closed\n    }\n\n    /// An input bytestream.\n    ///\n    /// `input-stream`s are *non-blocking* to the extent practical on underlying\n    /// platforms. I/O operations always return promptly; if fewer bytes are\n    /// promptly available than requested, they return the number of bytes promptly\n    /// available, which could even be zero. To wait for data to be available,\n    /// use the `subscribe` function to obtain a `pollable` which can be polled\n    /// for using `wasi:io/poll`.\n    @since(version = 0.2.0)\n    resource input-stream {\n        /// Perform a non-blocking read from the stream.\n        ///\n        /// When the source of a `read` is binary data, the bytes from the source\n        /// are returned verbatim. When the source of a `read` is known to the\n        /// implementation to be text, bytes containing the UTF-8 encoding of the\n        /// text are returned.\n        ///\n        /// This function returns a list of bytes containing the read data,\n        /// when successful. The returned list will contain up to `len` bytes;\n        /// it may return fewer than requested, but not more. The list is\n        /// empty when no bytes are available for reading at this time. The\n        /// pollable given by `subscribe` will be ready when more bytes are\n        /// available.\n        ///\n        /// This function fails with a `stream-error` when the operation\n        /// encounters an error, giving `last-operation-failed`, or when the\n        /// stream is closed, giving `closed`.\n        ///\n        /// When the caller gives a `len` of 0, it represents a request to\n        /// read 0 bytes. If the stream is still open, this call should\n        /// succeed and return an empty list, or otherwise fail with `closed`.\n        ///\n        /// The `len` parameter is a `u64`, which could represent a list of u8 which\n        /// is not possible to allocate in wasm32, or not desirable to allocate as\n        /// as a return value by the callee. The callee may return a list of bytes\n        /// less than `len` in size while more bytes are available for reading.\n        @since(version = 0.2.0)\n        read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Read bytes from a stream, after blocking until at least one byte can\n        /// be read. Except for blocking, behavior is identical to `read`.\n        @since(version = 0.2.0)\n        blocking-read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Skip bytes from a stream. Returns number of bytes skipped.\n        ///\n        /// Behaves identical to `read`, except instead of returning a list\n        /// of bytes, returns the number of bytes consumed from the stream.\n        @since(version = 0.2.0)\n        skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Skip bytes from a stream, after blocking until at least one byte\n        /// can be skipped. Except for blocking behavior, identical to `skip`.\n        @since(version = 0.2.0)\n        blocking-skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Create a `pollable` which will resolve once either the specified stream\n        /// has bytes available to read or the other end of the stream has been\n        /// closed.\n        /// The created `pollable` is a child resource of the `input-stream`.\n        /// Implementations may trap if the `input-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n    }\n\n\n    /// An output bytestream.\n    ///\n    /// `output-stream`s are *non-blocking* to the extent practical on\n    /// underlying platforms. Except where specified otherwise, I/O operations also\n    /// always return promptly, after the number of bytes that can be written\n    /// promptly, which could even be zero. To wait for the stream to be ready to\n    /// accept data, the `subscribe` function to obtain a `pollable` which can be\n    /// polled for using `wasi:io/poll`.\n    ///\n    /// Dropping an `output-stream` while there\'s still an active write in\n    /// progress may result in the data being lost. Before dropping the stream,\n    /// be sure to fully flush your writes.\n    @since(version = 0.2.0)\n    resource output-stream {\n        /// Check readiness for writing. This function never blocks.\n        ///\n        /// Returns the number of bytes permitted for the next call to `write`,\n        /// or an error. Calling `write` with more bytes than this function has\n        /// permitted will trap.\n        ///\n        /// When this function returns 0 bytes, the `subscribe` pollable will\n        /// become ready when this function will report at least 1 byte, or an\n        /// error.\n        @since(version = 0.2.0)\n        check-write: func() -> result<u64, stream-error>;\n\n        /// Perform a write. This function never blocks.\n        ///\n        /// When the destination of a `write` is binary data, the bytes from\n        /// `contents` are written verbatim. When the destination of a `write` is\n        /// known to the implementation to be text, the bytes of `contents` are\n        /// transcoded from UTF-8 into the encoding of the destination and then\n        /// written.\n        ///\n        /// Precondition: check-write gave permit of Ok(n) and contents has a\n        /// length of less than or equal to n. Otherwise, this function will trap.\n        ///\n        /// returns Err(closed) without writing if the stream has closed since\n        /// the last call to check-write provided a permit.\n        @since(version = 0.2.0)\n        write: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 bytes, and then flush the stream. Block\n        /// until all of these operations are complete, or an error occurs.\n        ///\n        /// Returns success when all of the contents written are successfully\n        /// flushed to output. If an error occurs at any point before all\n        /// contents are successfully flushed, that error is returned as soon as\n        /// possible. If writing and flushing the complete contents causes the\n        /// stream to become closed, this call should return success, and\n        /// subsequent calls to check-write or other interfaces should return\n        /// stream-error::closed.\n        @since(version = 0.2.0)\n        blocking-write-and-flush: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Request to flush buffered output. This function never blocks.\n        ///\n        /// This tells the output-stream that the caller intends any buffered\n        /// output to be flushed. the output which is expected to be flushed\n        /// is all that has been passed to `write` prior to this call.\n        ///\n        /// Upon calling this function, the `output-stream` will not accept any\n        /// writes (`check-write` will return `ok(0)`) until the flush has\n        /// completed. The `subscribe` pollable will become ready when the\n        /// flush has completed and the stream can accept more writes.\n        @since(version = 0.2.0)\n        flush: func() -> result<_, stream-error>;\n\n        /// Request to flush buffered output, and block until flush completes\n        /// and stream is ready for writing again.\n        @since(version = 0.2.0)\n        blocking-flush: func() -> result<_, stream-error>;\n\n        /// Create a `pollable` which will resolve once the output-stream\n        /// is ready for more writing, or an error has occurred. When this\n        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an\n        /// error.\n        ///\n        /// If the stream is closed, this pollable is always ready immediately.\n        ///\n        /// The created `pollable` is a child resource of the `output-stream`.\n        /// Implementations may trap if the `output-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        @since(version = 0.2.0)\n        subscribe: func() -> pollable;\n\n        /// Write zeroes to a stream.\n        ///\n        /// This should be used precisely like `write` with the exact same\n        /// preconditions (must use check-write first), but instead of\n        /// passing a list of bytes, you simply pass the number of zero-bytes\n        /// that should be written.\n        @since(version = 0.2.0)\n        write-zeroes: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 zeroes, and then flush the stream.\n        /// Block until all of these operations are complete, or an error\n        /// occurs.\n        ///\n        /// Functionality is equivelant to `blocking-write-and-flush` with\n        /// contents given as a list of len containing only zeroes.\n        @since(version = 0.2.0)\n        blocking-write-zeroes-and-flush: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Read from one stream and write to another.\n        ///\n        /// The behavior of splice is equivalent to:\n        /// 1. calling `check-write` on the `output-stream`\n        /// 2. calling `read` on the `input-stream` with the smaller of the\n        /// `check-write` permitted length and the `len` provided to `splice`\n        /// 3. calling `write` on the `output-stream` with that read data.\n        ///\n        /// Any error reported by the call to `check-write`, `read`, or\n        /// `write` ends the splice and reports that error.\n        ///\n        /// This function returns the number of bytes transferred; it may be less\n        /// than `len`.\n        @since(version = 0.2.0)\n        splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Read from one stream and write to another, with blocking.\n        ///\n        /// This is similar to `splice`, except that it blocks until the\n        /// `output-stream` is ready for writing, and the `input-stream`\n        /// is ready for reading, before performing the `splice`.\n        @since(version = 0.2.0)\n        blocking-splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n    }\n}\n";
    const _: &[u8] = b"interface types {\n    /// one single row item\n    record row {\n        field-name: string,\n        value: data-type,\n    }\n    \n    /// common data types\n    variant data-type {\n        int32(s32),\n        int64(s64),\n        uint32(u32),\n        uint64(u64),\n        float(f64),\n        double(f64),\n        str(string),\n        boolean(bool),\n        date(string),\n        time(string),\n        timestamp(string),\n        binary(list<u8>),\n        null\n    }\n\n    /// allows parameterized queries\n    /// e.g., prepare(\"SELECT * FROM users WHERE name = ? AND age = ?\", vec![\"John Doe\", \"32\"])\n    resource statement {\n        prepare: static func(query: string, params: list<string>) -> result<statement, error>;\n    }\n    /// An error resource type.\n    /// Currently, this provides only one function to return a string representation\n    /// of the error. In the future, this will be extended to provide more information.\n    resource error {\n\t\ttrace: func() -> string;\n  \t}\n    \n    /// A connection to a sql store.\n    resource connection {\n        open: static func(name: string) -> result<connection, error>;\n    }\n}";
    const _: &[u8] = b"// wasi-cloud Blobstore service definition\ninterface blobstore {\n  use container.{container};\n  use types.{error, container-name, object-id};\n\n  // creates a new empty container\n  create-container: func(name: container-name) -> result<container, error>;\n\n  // retrieves a container by name\n  get-container: func(name: container-name) -> result<container, error>;\n\n  // deletes a container and all objects within it\n  delete-container: func(name: container-name) -> result<_, error>;\n\n  // returns true if the container exists\n  container-exists: func(name: container-name) -> result<bool, error>;\n\n  // copies (duplicates) an object, to the same or a different container.\n  // returns an error if the target container does not exist.\n  // overwrites destination object if it already existed.\n  copy-object: func(src: object-id, dest: object-id) -> result<_, error>;\n\n  // moves or renames an object, to the same or a different container\n  // returns an error if the destination container does not exist.\n  // overwrites destination object if it already existed.\n  move-object: func(src:object-id, dest: object-id) -> result<_, error>;\n}";
    const _: &[u8] = b"/// The producer interface is used to send messages to a channel/topic.\ninterface producer {\n    use types.{client, message, error, topic};\n\n    /// Sends the message using the given client.\n    send: async func(c: client, topic: topic, message: message) -> result<_, error>;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides batch operations.\n/// \n/// A batch operation is an operation that operates on multiple keys at once.\n/// \n/// Batch operations are useful for reducing network round-trip time. For example, if you want to\n/// get the values associated with 100 keys, you can either do 100 get operations or you can do 1\n/// batch get operation. The batch operation is faster because it only needs to make 1 network call\n/// instead of 100.\n/// \n/// A batch operation does not guarantee atomicity, meaning that if the batch operation fails, some\n/// of the keys may have been modified and some may not. \n/// \n/// This interface does has the same consistency guarantees as the `store` interface, meaning that\n/// you should be able to \"read your writes.\"\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface batch {\n    use store.{bucket, error};\n\n    /// Get the key-value pairs associated with the keys in the store. It returns a list of\n    /// key-value pairs.\n    ///\n    /// If any of the keys do not exist in the store, it returns a `none` value for that pair in the\n    /// list.\n    /// \n    /// MAY show an out-of-date value if there are concurrent writes to the store.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`.\n    get-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<list<option<tuple<string, list<u8>>>>, error>;\n\n    /// Set the values associated with the keys in the store. If the key already exists in the\n    /// store, it overwrites the value. \n    /// \n    /// Note that the key-value pairs are not guaranteed to be set in the order they are provided. \n    ///\n    /// If any of the keys do not exist in the store, it creates a new key-value pair.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already set. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be set while others might\n    /// fail. \n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    set-many: func(bucket: borrow<bucket>, key-values: list<tuple<string, list<u8>>>) -> result<_, error>;\n\n    /// Delete the key-value pairs associated with the keys in the store.\n    /// \n    /// Note that the key-value pairs are not guaranteed to be deleted in the order they are\n    /// provided.\n    /// \n    /// If any of the keys do not exist in the store, it skips the key.\n    /// \n    /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not\n    /// rollback the key-value pairs that were already deleted. Thus, this batch operation does not\n    /// guarantee atomicity, implying that some key-value pairs could be deleted while others might\n    /// fail.\n    /// \n    /// Other concurrent operations may also be able to see the partial results.\n    delete-many: func(bucket: borrow<bucket>, keys: list<string>) -> result<_, error>;\n}\n";
    const _: &[u8] = b"/// A keyvalue interface that provides atomic operations.\n/// \n/// Atomic operations are single, indivisible operations. When a fault causes an atomic operation to\n/// fail, it will appear to the invoker of the atomic operation that the action either completed\n/// successfully or did nothing at all.\n/// \n/// Please note that this interface is bare functions that take a reference to a bucket. This is to\n/// get around the current lack of a way to \"extend\" a resource with additional methods inside of\n/// wit. Future version of the interface will instead extend these methods on the base `bucket`\n/// resource.\ninterface atomics {\n  \tuse store.{bucket, error};\n\n\t/// The error returned by a CAS operation\n\tvariant cas-error {\n\t\t/// A store error occurred when performing the operation\n\t\tstore-error(error),\n\t\t/// The CAS operation failed because the value was too old. This returns a new CAS handle\n\t\t/// for easy retries. Implementors MUST return a CAS handle that has been updated to the\n\t\t/// latest version or transaction.\n\t\tcas-failed(cas),\n\t}\n\n\t/// A handle to a CAS (compare-and-swap) operation.\n\tresource cas {\n\t\t/// Construct a new CAS operation. Implementors can map the underlying functionality\n\t\t/// (transactions, versions, etc) as desired.\n\t\tnew: static func(bucket: borrow<bucket>, key: string) -> result<cas, error>;\n\t\t/// Get the current value of the key (if it exists). This allows for avoiding reads if all\n\t\t/// that is needed to ensure the atomicity of the operation\n\t\tcurrent: func() -> result<option<list<u8>>, error>;\n\t}\n\n  \t/// Atomically increment the value associated with the key in the store by the given delta. It\n\t/// returns the new value.\n\t///\n\t/// If the key does not exist in the store, it creates a new key-value pair with the value set\n\t/// to the given delta. \n\t///\n\t/// If any other error occurs, it returns an `Err(error)`.\n\tincrement: func(bucket: borrow<bucket>, key: string, delta: s64) -> result<s64, error>;\n\n\t/// Perform the swap on a CAS operation. This consumes the CAS handle and returns an error if\n\t/// the CAS operation failed.\n\tswap: func(cas: cas, value: list<u8>) -> result<_, cas-error>;\n}";
    const _: &[u8] = b"/// A keyvalue interface that provides watch operations.\n/// \n/// This interface is used to provide event-driven mechanisms to handle\n/// keyvalue changes.\ninterface watcher {\n\t/// A keyvalue interface that provides handle-watch operations.\n\tuse store.{bucket};\n\n\t/// Handle the `set` event for the given bucket and key. It includes a reference to the `bucket`\n\t/// that can be used to interact with the store.\n\ton-set: func(bucket: bucket, key: string, value: list<u8>);\n\n\t/// Handle the `delete` event for the given bucket and key. It includes a reference to the\n\t/// `bucket` that can be used to interact with the store.\n\ton-delete: func(bucket: bucket, key: string);\n}";
    const _: &[u8] = b"package wasmgrid:service;\n\nworld blobstore {\n\tinclude wasi:blobstore/imports@0.2.0-draft;\n}\n\nworld keyvalue {\n\tinclude wasi:keyvalue/watch-service@0.2.0-draft2;\n}\n\nworld messaging {\n\tinclude wasi:messaging/messaging-request-reply@0.2.0-draft;\n}\n\nworld otel {\n\tinclude wasi:otel/imports@0.2.0-draft;\n}\n\nworld sql {\n\tinclude wasi:sql/imports@0.2.0-draft;\n}\n\nworld vault {\n\tinclude wasi:vault/imports@0.1.0-draft;\n}";
    const _: &[u8] = b"package wasi:vault@0.1.0-draft;\n\nworld imports {\n  import vault;\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n/// WASI Monotonic Clock is a clock API intended to let users measure elapsed\n/// time.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A monotonic clock is a clock which has an unspecified initial value, and\n/// successive reads of the clock will produce non-decreasing values.\n@since(version = 0.2.0)\ninterface monotonic-clock {\n    @since(version = 0.2.0)\n    use wasi:io/poll@0.2.6.{pollable};\n\n    /// An instant in time, in nanoseconds. An instant is relative to an\n    /// unspecified initial value, and can only be compared to instances from\n    /// the same monotonic-clock.\n    @since(version = 0.2.0)\n    type instant = u64;\n\n    /// A duration of time, in nanoseconds.\n    @since(version = 0.2.0)\n    type duration = u64;\n\n    /// Read the current value of the clock.\n    ///\n    /// The clock is monotonic, therefore calling this function repeatedly will\n    /// produce a sequence of non-decreasing values.\n    @since(version = 0.2.0)\n    now: func() -> instant;\n\n    /// Query the resolution of the clock. Returns the duration of time\n    /// corresponding to a clock tick.\n    @since(version = 0.2.0)\n    resolution: func() -> duration;\n\n    /// Create a `pollable` which will resolve once the specified instant\n    /// has occurred.\n    @since(version = 0.2.0)\n    subscribe-instant: func(\n        when: instant,\n    ) -> pollable;\n\n    /// Create a `pollable` that will resolve after the specified duration has\n    /// elapsed from the time this function is invoked.\n    @since(version = 0.2.0)\n    subscribe-duration: func(\n        when: duration,\n    ) -> pollable;\n}\n";
    const _: &[u8] = b"package wasi:sql@0.2.0-draft;\n\nworld imports {\n\timport readwrite;\n}";
    const _: &[u8] = b"package wasi:otel@0.2.0-draft;\n\nworld imports {\n    import tracing;\n    import metrics;\n    import %resource;\n}\n";
    const _: &[u8] = b"interface metrics {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n    use types.{key, value, key-value, instrumentation-scope, %resource, error};\n\n    /// Gathers and returns all metric data related to the [MetricReader] from the\n    /// SDK and stores it in the provided [ResourceMetrics] reference.\n    ///\n    /// An error is returned if this is called after shutdown.\n    %export: func(rm: resource-metrics) -> result<_, error>;\n\n    /// A collection of scope metrics and the associated resource that created them.\n    record resource-metrics {\n        /// The entity that collected the metrics.\n        %resource: %resource,\n\n        /// The collection of metrics with unique [InstrumentationScope]s.\n        scope-metrics: list<scope-metrics>,\n    }\n\n    record scope-metrics {\n        /// The instrumentation scope that the meter was created with.\n        scope: instrumentation-scope,\n\n        /// The list of aggregations created by the meter.\n        metrics: list<metric>,\n    }\n\n    /// A collection of one or more aggregated time series from an [Instrument].\n    ///\n    /// [Instrument]: crate::metrics::Instrument\n    record metric {\n        /// The name of the instrument that created this data.\n        name: string,\n\n        /// The description of the instrument, which can be used in documentation.\n        description: string,\n\n        /// The unit in which the instrument reports.\n        unit: string,\n\n        /// The aggregated data from an instrument.\n        data: aggregated-metrics,\n    }\n\n    /// Aggregated metrics data from an instrument\n    variant aggregated-metrics {\n        /// All metric data with `f64` value type\n        %f64(metric-data),\n\n        /// All metric data with `u64` value type\n        %u64(metric-data),\n\n        /// All metric data with `i64` value type\n        %s64(metric-data),\n    }\n\n    /// Metric data for all types\n    variant metric-data {\n        /// Metric data for Gauge\n        gauge(gauge),\n\n        /// Metric data for Sum\n        sum(sum),\n\n        /// Metric data for Histogram\n        histogram(histogram),\n\n        /// Metric data for ExponentialHistogram\n        exponential-histogram(exponential-histogram),\n    }\n\n    /// A measurement of the current value of an instrument.\n    record gauge {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<gauge-data-point>,\n\n        /// The time when the time series was started.\n        start-time: option<datetime>,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record gauge-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the sum of all measurements of values from an instrument.\n    record sum {\n        /// Represents individual aggregated measurements with unique attributes.\n        data-points: list<sum-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n\n        /// Whether this aggregation only increases or decreases.\n        is-monotonic: bool,\n    }\n\n    /// DataPoint is a single data point in a time series.\n    record sum-data-point {\n        /// Attributes is the set of key value pairs that uniquely identify the\n        /// time series.\n        attributes: list<key-value>,\n\n        /// The value of this data point.\n        value: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// Represents the histogram of all measurements of values from an instrument.\n    record histogram {\n        /// Individual aggregated measurements with unique attributes.\n        data-points: list<histogram-data-point>,\n\n        /// The time when the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single histogram data point in a time series.\n    record histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The upper bounds of the buckets of the histogram.\n        ///\n        /// Because the last boundary is +infinity this one is implied.\n        bounds: list<f64>,\n\n        /// The count of each of the buckets.\n        bucket-counts: list<u64>,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// The histogram of all measurements of values from an instrument.\n    record exponential-histogram {\n        /// The individual aggregated measurements with unique attributes.\n        data-points: list<exponential-histogram-data-point>,\n\n        /// When the time series was started.\n        start-time: datetime,\n\n        /// The time when the time series was recorded.\n        time: datetime,\n\n        /// Describes if the aggregation is reported as the change from the last report\n        /// time, or the cumulative changes since a fixed start time.\n        temporality: temporality,\n    }\n\n    /// A single exponential histogram data point in a time series.\n    record exponential-histogram-data-point {\n        /// The set of key value pairs that uniquely identify the time series.\n        attributes: list<key-value>,\n\n        /// The number of updates this histogram has been calculated with.\n        count: u64,\n\n        /// The minimum value recorded.\n        min: option<data-value>,\n\n        /// The maximum value recorded.\n        max: option<data-value>,\n\n        /// The sum of the values recorded.\n        sum: data-value,\n\n        /// Describes the resolution of the histogram.\n        ///\n        /// Boundaries are located at powers of the base, where:\n        ///\n        ///   base = 2 ^ (2 ^ -scale)\n        scale: s8,\n\n        /// The number of values whose absolute value is less than or equal to\n        /// `zero_threshold`.\n        ///\n        /// When `zero_threshold` is `0`, this is the number of values that cannot be\n        /// expressed using the standard exponential formula as well as values that have\n        /// been rounded to zero.\n        zero-count: u64,\n\n        /// The range of positive value bucket counts.\n        positive-bucket: exponential-bucket,\n\n        /// The range of negative value bucket counts.\n        negative-bucket: exponential-bucket,\n\n        /// The width of the zero region.\n        ///\n        /// Where the zero region is defined as the closed interval\n        /// [-zero_threshold, zero_threshold].\n        zero-threshold: f64,\n\n        /// The sampled exemplars collected during the time series.\n        exemplars: list<exemplar>,\n    }\n\n    /// A set of bucket counts, encoded in a contiguous array of counts.\n    record exponential-bucket {\n        /// The bucket index of the first entry in the `counts` vec.\n        offset: s32,\n\n        /// A vec where `counts[i]` carries the count of the bucket at index `offset + i`.\n        ///\n        /// `counts[i]` is the count of values greater than base^(offset+i) and less than\n        /// or equal to base^(offset+i+1).\n        counts: list<u64>,\n    }\n\n    /// Defines the window that an aggregation was calculated over.\n    enum temporality {\n        /// A measurement interval that continues to expand forward in time from a\n        /// starting point.\n        ///\n        /// New measurements are added to all previous measurements since a start time.\n        cumulative,\n\n        /// A measurement interval that resets each cycle.\n        ///\n        /// Measurements from one cycle are recorded independently, measurements from\n        /// other cycles do not affect them.\n        delta,\n\n        /// Configures Synchronous Counter and Histogram instruments to use\n        /// Delta aggregation temporality, which allows them to shed memory\n        /// following a cardinality explosion, thus use less memory.\n        low-memory,\n    }\n\n    /// A measurement sampled from a time series providing a typical example.\n    record exemplar {\n        /// The attributes recorded with the measurement but filtered out of the\n        /// time series\' aggregated data.\n        filtered-attributes: list<key-value>,\n\n        /// The time when the measurement was recorded.\n        time: datetime,\n\n        /// The measured value.\n        value: data-value,\n\n        /// The ID of the span that was active during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        span-id: string,\n\n        /// The ID of the trace the active span belonged to during the measurement.\n        ///\n        /// If no span was active or the span was not sampled this will be empty.\n        trace-id: string,\n    }\n\n    variant data-value {\n        /// All metric data with `f64` value type\n        %f64(f64),\n\n        /// All metric data with `u64` value type\n        %u64(u64),\n\n        /// All metric data with `s64` value type\n        %s64(s64),\n    }\n\n\n    /// The identifier of a group of instruments that all perform the same function.\n    enum instrument-kind {\n        /// Identifies a group of instruments that record increasing values synchronously\n        /// with the code path they are measuring.\n        counter,\n\n        /// A group of instruments that record increasing and decreasing values\n        /// synchronously with the code path they are measuring.\n        up-down-counter,\n\n        /// A group of instruments that record a distribution of values synchronously with\n        /// the code path they are measuring.\n        histogram,\n\n        /// A group of instruments that record increasing values in an asynchronous\n        /// callback.\n        observable-counter,\n\n        /// A group of instruments that record increasing and decreasing values in an\n        /// asynchronous callback.\n        observable-up-down-counter,\n\n        /// a group of instruments that record current value synchronously with\n        /// the code path they are measuring.\n        gauge,\n\n        /// a group of instruments that record current values in an asynchronous callback.\n        observable-gauge,\n    }\n}\n";
    const _: &[u8] = b"// a Container is a collection of objects\ninterface container {\n  use wasi:io/streams@0.2.6.{\n    input-stream,\n    output-stream,\n  };\n\n  use types.{\n    container-metadata,\n    error,\n    incoming-value,\n    object-metadata,\n    object-name,\n    outgoing-value,\n  };\n\n  // this defines the `container` resource\n  resource container {\n    // returns container name\n    name: func() -> result<string, error>;\n\n    // returns container metadata\n    info: func() -> result<container-metadata, error>;\n\n    // retrieves an object or portion of an object, as a resource.\n    // Start and end offsets are inclusive.\n    // Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime\n    // of the data-blob resource, even if the object they came from is later deleted.\n    get-data: func(name: object-name, start: u64, end: u64) -> result<incoming-value, error>;\n\n    // creates or replaces an object with the data blob.\n    write-data: func(name: object-name, data: borrow<outgoing-value>) -> result<_, error>;\n\n    // returns list of objects in the container. Order is undefined.\n    list-objects: func() -> result<stream-object-names, error>;\n\n    // deletes object.\n    // does not return error if object did not exist.\n    delete-object: func(name: object-name) -> result<_, error>;\n\n    // deletes multiple objects in the container\n    delete-objects: func(names: list<object-name>) -> result<_, error>;\n\n    // returns true if the object exists in this container\n    has-object: func(name: object-name) -> result<bool, error>;\n\n    // returns metadata for the object\n    object-info: func(name: object-name) -> result<object-metadata, error>;\n\n    // removes all objects within the container, leaving the container empty.\n    clear: func() -> result<_, error>;\n  }\n\n  // this defines the `stream-object-names` resource which is a representation of stream<object-name>\n  resource stream-object-names {\n    // reads the next number of objects from the stream\n    //\n    // This function returns the list of objects read, and a boolean indicating if the end of the stream was reached.\n    read-stream-object-names: func(len: u64) -> result<tuple<list<object-name>, bool>, error>;\n\n    // skip the next number of objects in the stream\n    //\n    // This function returns the number of objects skipped, and a boolean indicating if the end of the stream was reached.\n    skip-stream-object-names: func(num: u64) -> result<tuple<u64, bool>, error>;\n  }\n}\n";
    const _: &[u8] = b"interface types {\n    use wasi:clocks/wall-clock@0.2.6.{datetime};\n\n    /// A key-value pair describing an attribute.\n    record key-value {\n        /// The attribute name.\n        key: key,\n        /// The attribute value.\n        value: value,\n    }\n\n    /// The key part of attribute `key-value` pairs.\n    type key = string;\n\n    /// The value part of attribute `key-value` pairs.\n    variant value {\n        /// A string value.\n        %string(string),\n        /// A boolean value.\n        %bool(bool),\n        /// A double precision floating point value.\n        %f64(f64),\n        /// A signed 64 bit integer value.\n        %s64(s64),\n        /// A homogeneous array of string values.\n        string-array(list<string>),\n        /// A homogeneous array of boolean values.\n        bool-array(list<bool>),\n        /// A homogeneous array of double precision floating point values.\n        f64-array(list<f64>),\n        /// A homogeneous array of 64 bit integer values.\n        s64-array(list<s64>),\n    }\n\n    /// The host resource describing the entity producing telemetry.\n    record %resource {\n        /// Specifies the resource attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n    }\n\n    /// Describes the instrumentation scope that produced a span.\n    record instrumentation-scope {\n        /// Name of the instrumentation scope.\n        name: string,\n\n        /// The library version.\n        version: option<string>,\n\n        /// Schema URL used by this library.\n        /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url\n        schema-url: option<string>,\n\n        /// Specifies the instrumentation scope attributes to associate with emitted telemetry.\n        attributes: list<key-value>,\n    }\n\n    /// The set of errors which may be raised by functions in this package\n    variant error {\n        /// Shutdown has already been invoked.\n        already-shutdown,\n\n        /// Operation timed out before completing.\n        timeout(u64),\n\n        /// Operation failed due to an internal error.\n        internal-failure(string)\n    }\n}\n";
    const _: &[u8] = b"package wasi:clocks@0.2.6;\n\n@since(version = 0.2.0)\nworld imports {\n    @since(version = 0.2.0)\n    import monotonic-clock;\n    @since(version = 0.2.0)\n    import wall-clock;\n    @unstable(feature = clocks-timezone)\n    import timezone;\n}\n";
}
